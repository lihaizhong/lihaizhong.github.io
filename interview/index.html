<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/jpeg" href="/images/favicon.jpeg"><meta name="generator" content="Astro v5.12.0"><!-- Canonical URL --><link rel="canonical" href="https://lihaizhong.github.io/interview/"><!-- RSS Feed Discovery --><link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"><!-- Primary Meta Tags --><title>竹简记书</title><meta name="title" content="竹简记书"><meta name="description" content="合抱之木生于毫末，九层之台起于累土，千里之行始于足下"><!-- Open Graph / Facebook --><!-- <meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} /> --><!-- Twitter --><!-- <meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} /> --><link rel="stylesheet" href="/astro_assets/asset.CTGH2W9s.css">
<style>.post-list[data-v-c357ad79]{list-style-type:none;padding:unset}.post-list .post-item[data-v-c357ad79]{display:flex}time{flex:0 0 130px;font-style:italic;color:#595959}.post-list .post-category[data-v-c357ad79]{white-space:nowrap}.post-list .post-item .post-link[data-v-c357ad79]:visited{color:#8e32dc}.pagination-container[data-v-c357ad79]{margin-top:60px}
</style></head> <body> <header class="box-border mt-9 mx-auto py-5 site-header" data-astro-cid-3ef6ksr2> <!-- <h2 class="mb-1 text-3xl font-bold">{SITE_TITLE}</h2> --> <nav class="mb-2" data-astro-cid-3ef6ksr2> <a href="/" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 首页 </a> <a href="/blog" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 博客 </a> <a href="/interview" class="text-xl inline-block no-underline font-bold underline" data-astro-cid-3ef6ksr2="true"> 面试题 </a> <a href="/archive" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 归档 </a> <a href="https://github.com/lihaizhong" class="text-xl inline-block no-underline" target="_blank" data-astro-cid-3ef6ksr2="true"> GitHub </a> </nav> <p class="my-3 text-base text-gray-400" data-astro-cid-3ef6ksr2>合抱之木生于毫末，九层之台起于累土，千里之行始于足下</p> </header>  <article> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="Z2sNbxr" component-url="/astro_assets/app.PYHgcz_E.js" component-export="default" renderer-url="/astro_assets/app.CHmg8Y6V.js" props="{&quot;posts&quot;:[1,[[0,{&quot;id&quot;:[0,&quot;分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验&quot;],&quot;category&quot;:[0,&quot;实战与架构&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T17:52:53.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 项目背景\n\n某大型电商平台的 **实时库存管理系统**，需支持 10万 + SKU 的实时库存展示、多仓调拨和库存预警，用户端包括 PC 管理后台和移动端 APP，日均 PV 50万 +。\n\n## 我的角色\n\n前端技术负责人，负责架构设计、核心功能开发和性能优化，带领 5 个团队。\n\n## 挑战与解决方案\n\n### 1. 实时性与性能矛盾\n\n- 问题：库存数据每 3 秒更新一次，传统轮询导致频繁请求，页面卡顿。\n- 解决：采用 **Web Socket + 增量更新**：\n  - 后端仅推送变化的库存数据（而非全量），减少数据传输量。\n  - 前端用 `requestAnimationFrame` 批量更新 DOM，避免频繁回流。\n\n### 2. 复杂表格交互\n\n- 问题：10万+ 行数据的表格需支持排序、筛选、冻结列，传统表格组件性能崩溃。\n- 解决：实现 **虚拟滚动表格**：\n  - 仅渲染可视区域内的行（约 50 行），滚动时动态计算渲染范围。\n  - 基于 IndexDB 缓存筛选后的全局数据，避免重复请求。\n\n### 3. 多端适配与一致性\n\n- 问题：PC 端（复杂表单）和移动端（简化操作）需共享业务逻辑，但 UI 差异大。\n- 解决：采用 **逻辑与 UI 分离** 架构：\n  - 核心逻辑（如库存计算、校验规则）封装为独立 SDK，多端共享。\n  - UI 层使用不同组件库（PC 用 AntDesign，移动端用 Vant），通过适配层统一接口。\n\n## 经验总结\n\n- **技术选型需权衡**：实时场景优先考虑 WebSocket 而非轮询，但需做好断线重连和降级方案。\n- **性能优化要量化**：通过 Lighthouse 和 Performance API 建立性能基准，针对性优化（如首屏加载从 3s 降到 1.2s）。\n- **团队协作靠规范**：制定组件设计规范和 API 文档标准，减少沟通成本（如统一用 Swagger 管理接口文档）。\n- **故障预案不可少**：针对 WebSocket 连接失败、数据同步异常等场景，设计降级方案（如自动切换为轮询）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验.mdx&quot;],&quot;digest&quot;:[0,&quot;a988ee7109a0df4b&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;分享一个你参与过的最具挑战性的前端项目你在其中扮演的角色解决的问题以及从中获得的经验&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明&quot;],&quot;category&quot;:[0,&quot;实战与架构&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T17:36:37.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;保证代码质量需建立 **全流程质量管控体系**，覆盖编码、提交、审查、测试和部署环节。\n\n## 1. 编码规范\n\n- **指定统一规范**：基于 ESLint、StyleLint配置团队规则（如 Airbnb规范），强制代码风格一致（如缩进、命名、注释）。\n- **自动化校验**：通过 `husky` 在代码提交前触发 `lint-staged`，仅检查暂存区代码，不符合规范则阻止提交。\n\n```json\n// package.json\n{\n  \&quot;lint-staged\&quot;: {\n    \&quot;*.{js,vue}\&quot;: [\&quot;eslint --fix\&quot;, \&quot;prettier --write\&quot;]\n  }\n}\n```\n\n- **编辑器配置统一**：通过 `editorconfig` 文件统一缩进、换行符等编辑器行为，避免环境差异。\n\n## 2. 代码审查（Code Review）\n\n- **建立 PR 流程**：通过 GitLab/GitHub 的 Pull Request 机制，要求代码必须经过至少 1 名团队成员审查才能合并。\n- **审查重点**：逻辑正确性、性能隐患、安全性（如 XSS 风险）、代码复用性。\n- **工具辅助**：使用 SonarQube 检测代码重复率、复杂度，通过自动化工具提前发现潜在问题。\n\n## 3. 测试体系\n\n- **单元测试**：覆盖核心工具函数、组件逻辑（如用 Jest 测试 `format.js` 的日期格式化功能），目标覆盖率 &gt;= 80%。\n- **组件测试**：通过 React Testing Library/Vue Test Utils 测试组件渲染和交互（如按钮点击是否触发回调）。\n- **E2E测试**：用 Cypress/Playwright 模拟用户全流程操作（如 登录 -&gt; 下单），确保关键业务链路可用。\n- **性能测试**：通过 Lighthouse 定期检测页面性能指标（如 FCP、LCP），设置阔值告警。\n\n## 持续集成（CI）\n\n- 配置 CI 流水线（如 GitHub Actions），每次提交自动执行；\n  - 代码 Lint -&gt; 单元测试 -&gt; 构建 -&gt; E2E测试 -&gt; 性能检测。\n- 任何环节失败则阻断部署，确保问题不流入生产环境。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明.mdx&quot;],&quot;digest&quot;:[0,&quot;ed9f63ff14a19965&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;如何保证前端项目的代码质量请从编码规范代码审查测试等方面进行说明&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对前端微服务的理解，它的实现方式和优势.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对前端微服务的理解，它的实现方式和优势&quot;],&quot;category&quot;:[0,&quot;实战与架构&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T17:22:50.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;前端微服务（又称微前端）是将大型前端应用拆分为 **独立开发**、**独立部署**、**技术栈无关** 的小型应用（微应用），通过主应用集成运行的架构模式。\n\n## 核心思想\n\n- **技术栈无关**：每个微应用可选择不同框架（如 React、Vue、Angular），团队自主决策。\n- **独立部署**：微应用单独构建、发布，不影响其他应用，CI/CD 流程高效。\n- **运行时集成**：主应用负责微应用的加载、路由分发和通信，用户体验一致。\n\n## 实现方式\n\n### 1. 基于路由分发（最常用）\n\n主应用通过路由匹配加载对应微应用（如 `/user` 加载用户微应用，`/order` 加载订单微应用）。\n\n- 代表工具：`qiankun`（基于 single-spa 封装，支持沙箱隔离和预加载）。\n- 原理：主应用动态加载微应用的 JS/CSS，通过生命周期钩子（`bootstrap`、`mount`、`unmount`）管理微应用状态。\n\n### 2. 基于 Web Components\n\n微应用封装为 Web Components 自定义元素，主应用通过标签（如 `&lt;user-app&gt;`）直接使用。\n\n- 优势：天然隔离（Shadow DOM），跨框架兼容。\n- 局限：适合组件级集成，复杂应用路由管理较繁琐。\n\n### 3. 基于 iframe\n\n主应用通过 iframe 嵌入微应用，利用 iframe 的天然隔离型。\n\n- 优势：实现简单，完全隔离（样式、JS 互不干扰）。\n- 局限：性能损耗大，通信依赖 `postMessage`，用户体验割裂（如导航同步困难）。\n\n## 优势\n\n- **团队自治**：不同团队负责不同微应用，减少协作冲突。\n- **增量升级**：可逐步将旧系统迁移为微应用，无需一次型重构。\n- **技术栈灵活**：新功能可尝试新技术栈，降低技术选型风险。\n- **故障隔离**：单个微应用崩溃不影响整个系统。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对前端微服务的理解，它的实现方式和优势.mdx&quot;],&quot;digest&quot;:[0,&quot;d63ced796997b606&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对前端微服务的理解它的实现方式和优势&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点&quot;],&quot;category&quot;:[0,&quot;实战与架构&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T17:03:45.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;前端状态管理的核心是 **统一管理应用状态**，解决组件数据共享问题。不同场景需选择不同方案，常见方案对比如下：\n\n| 方案         | 适用场景                         | 优点                                                   | 缺点                                    |\n| ------------ | -------------------------------- | ------------------------------------------------------ | --------------------------------------- |\n| 组件自身状态 | 单个组件内部状态（如表单输入值） | 简单直接，无需额外依赖                                 | 无法跨组件共享                          |\n| Props/Events | 父子组件通信                     | 原生支持，无学习成本                                   | 深层嵌套组件传递繁琐（“props 钻取”）    |\n| Context API  | 中大型应用的跨层级共享（如主题） | 原生支持，避免 props 钻取                              | 频繁更新会导致性能问题（无优化机制）    |\n| Redux        | 大型应用，复杂状态逻辑（如电商） | 严格的单向数据流，可预测性强，支持中间件（如异步处理） | 样板代码多，学习成本高                  |\n| Vuex/Pinia   | Vue 生态的中大型应用             | 继承 Vue 响应式系统，API 简洁，支持模块化              | 仅适用于 Vue，Pinia 对旧版 Vue 兼容性差 |\n| MobX         | 复杂状态且需灵活更新的应用       | 响应式自动追踪依赖，代码简洁                           | 灵活性高导致状态变更难以追踪            |\n| Zustand      | 中小型应用，React生态            | API 极简，无 Provider 包裹，支持中间件                 | 生态不如 Redux 完善                     |\n\n## 选择建议\n\n- 小型项目或简单状态：优先使用 `Props/Events` 或 `Context API`，减少依赖。\n- 中大型 React 项目：复杂状态用 `Redux`（配合 Redux Toolkit 减少样板代码），简单跨组件状态用 `Zustand`。\n- Vue 项目：首选 `Pinia`（Vuex的继任者，更简洁的 API 和更好的 TypeScript支持）。\n- 状态频繁更新逻辑复杂：MobX（自动响应式可简化代码），但需规范状态变更流程。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点.mdx&quot;],&quot;digest&quot;:[0,&quot;ce8102b94a1f888c&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;在前端项目中如何进行状态管理请对比不同状态管理方案的优缺点&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;请设计一个大型前端项目的目录结构，并说明其设计思路.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;请设计一个大型前端项目的目录结构，并说明其设计思路&quot;],&quot;category&quot;:[0,&quot;实战与架构&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T16:50:28.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;大型前端项目的目录结构设计需满足 **可扩展性**、**可维护性** 和 **团队协作效率**，核心思路是“按功能职责拆分、按业务模块鳄梨、规范通用资源位置”。以下是一个典型的目录接哦顾设计：\n\n```ts\nsrc/\n├── api/                 # 接口层：统一管理API请求\n│   ├── index.js         # 接口入口（导出所有API）\n│   ├── user.js          # 用户相关接口（登录、信息等）\n│   └── order.js         # 订单相关接口\n├── assets/images/              # 静态资源：不经过编译的资源\n│   ├── images/          # 图片资源（按业务模块子目录划分）\n│   ├── fonts/           # 字体文件\n│   └── styles/          # 全局样式（如reset.css、variables.scss）\n├── components/          # 组件库\n│   ├── common/          # 通用组件（按钮、输入框等，可复用至全项目）\n│   ├── business/        # 业务组件（如订单卡片、商品列表，与业务强相关）\n│   └── layout/          # 布局组件（头部、侧边栏、页脚等）\n├── config/              # 配置文件\n│   ├── constants.js     # 常量定义（如状态码、路由路径）\n│   ├── theme.js         # 主题配置（颜色、字体大小等）\n│   └── env.js           # 环境变量（区分开发/测试/生产）\n├── hooks/               # 自定义钩子：封装可复用的逻辑\n│   ├── useAuth.js       # 权限相关钩子（如登录状态判断）\n│   └── usePagination.js # 分页逻辑钩子\n├── layouts/             # 页面布局：不同页面的整体结构\n│   ├── MainLayout.vue   # 主布局（带侧边栏和头部）\n│   └── BlankLayout.vue  # 空白布局（如登录页）\n├── router/              # 路由配置\n│   ├── index.js         # 路由入口（创建路由实例）\n│   ├── routes.js        # 路由规则（按模块拆分）\n│   └── guard.js         # 路由守卫（权限控制、登录拦截）\n├── store/               # 状态管理\n│   ├── index.js         # 状态入口（导出store实例）\n│   ├── modules/         # 模块化状态（用户、购物车等）\n│   └── plugins/         # 状态插件（如持久化）\n├── utils/               # 工具函数\n│   ├── format.js        # 格式化工具（日期、金额等）\n│   └── validator.js     # 校验工具（表单验证规则）\n├── views/               # 页面层：与路由一一对应\n│   ├── user/            # 用户模块页面\n│   │   ├── login.vue    # 登录页\n│   │   └── profile.vue  # 个人资料页\n│   └── order/           # 订单模块页面\n├── App.vue              # 根组件\n└── main.js              # 入口文件（初始化应用）\n```\n\n## 设计思路\n\n- **分层职责清晰**：从接口层（api）、状态层（store）到视图层（views），每层专注单一职责，避免代码混杂。\n- **业务与通用分离**：`components/common` 存放全项目复用组件，`components/business` 存放业务专属组件，便于维护和复用。\n- **模版化组织**：按业务模块（如 user、order）划分目录，团队成员可聚焦各自负责的模块，减少代码冲突。\n- **资源集中管理**：静态资源、配置文件、工具函数统一存放，避免散落各处导致查找困难。\n- **可扩展性预留**：通过 `plugins`、`hooks` 等目录，方便后期接入新功能（如埋点、性能监控）而不侵入核心代码。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/请设计一个大型前端项目的目录结构，并说明其设计思路.mdx&quot;],&quot;digest&quot;:[0,&quot;b1393ce996970247&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;请设计一个大型前端项目的目录结构并说明其设计思路&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是 XSS 和 CSRF 攻击？如何防范.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是 XSS 和 CSRF 攻击？如何防范&quot;],&quot;category&quot;:[0,&quot;浏览器相关&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T15:02:10.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;网络安全是前端开发的重要环节，XSS 和 CSRF 是两种常见的攻击方式，它们利用浏览器特性和用户信任进行恶意操作，需针对性防范。\n\n## 一、XSS 攻击（Cross-Site Scripting，跨站脚本攻击）\n\n### 定义\n\nXSS 攻击是指攻击者在网页中注入恶意 JavaScript 代码，当用户访问该页面时，恶意代码在用户浏览器中执行，从而窃取用户信息（如 Cookie、账号密码）、篡改页面内容或发起其他攻击。\n\n### 攻击原理\n\n1. 攻击者将恶意脚本（如 `&lt;script&gt;stealCookie()&lt;/script&gt;`）注入到网页中 _（通常通过表单提交、URL参数等方式）_。\n2. 网页未对用户输入进行过滤，直接将恶意脚本渲染到页面中。\n3. 其他用户访问该页面时，恶意脚本被浏览器执行，导致信息泄漏或其他危害。\n\n### 常见场景\n\n- 评论区、论坛等用户可输入内容的区域，若未过滤 `&lt;script&gt;` 标签，可能被注入恶意代码。\n- URL 参数直接渲染到页面中（如 `http://example.com/?name=&lt;script&gt;...&lt;/script&gt;`）,若未处理则触发 XSS 攻击。\n\n### 防范措施\n\n1. **输入过滤与输出编码**：\n\n- 对用户输入的内容进行严格过滤，移除或转义 `&lt;script&gt;`、`&lt;img onerror&gt;` 等危险标签和属性。\n- 输出到 HTML 时，将特殊字符（如 `&lt;`、`&gt;`、 `&amp;`）转义为 HTML 实体（如 `&amp;lt;`、`&amp;gt;`、`&amp;amp;`），避免浏览器解析为脚本。\n- 示例（JavaScript 转义）：`const safeHtml = text.replace(/&lt;/g, &#39;&amp;lt;&#39;).replace(/&gt;/g, &#39;&amp;gt;&#39;)`。\n\n2. **使用 CSP（Content Security Policy，内容安全策略）**：\n\n- 通过 HTTP 响应头 `Content-Security-Policy` 限制资源加载来源，禁止执行内联脚本（`inline-script`）和未授权域名的脚本。\n- 示例：`Content-Security-Policy: default-src &#39;self&#39;; script-src &#39;self&#39; https://trusted.com`（仅允许加载自身域名和 `trusted.com` 的脚本）。\n\n3. **设置 Cookie 的 HttpOnly 属性**：\n\n- 为 Cookie 添加 `HttpOnly` 属性，使其无法通过 JavaScript 的 `document.cookie` 访问，即使发生 XSS，攻击者也无法窃取 Cookie。\n- 示例（HTTP 响应头）：`Set-Cookie: sessionId=xxx; HttpOnly; Secure`。\n\n4. **避免使用 `eval()、`innerHTML` 等危险 API**：\n\n- `eval()` 会执行字符串作为代码，易被注入攻击；`innerHTML` 会直接解析 HTML，可能执行恶意脚本。\n- 有限使用 `textContent`（仅渲染文本）或安全的模版引擎（如 Vue、React 的模版系统，自动转义 HTML）。\n\n## 二、CSRF 攻击（Cross-Site Request Forgery，跨站请求伪造）\n\n### 定义\n\nCSRF 攻击时指攻击者诱导已登录用户在不知情的情况下，向被攻击网站发送恶意请求，利用用户的身份信息（如 Cookie）执行未授权操作（如转账、修改密码）。\n\n### 攻击原理\n\n1. 用户已登录目标网站 A（如银行网站），浏览器保存了网站A的登录 Coookie。\n2. 攻击者诱导用户访问恶意网站 B，网站 B中隐藏向网站 A发送请求的代码（如表单自动提交、图片请求）。\n3. 由于浏览器会自动携带网站 A 的 Cookie，网站 A 误认为是用户主动发起的请求，从而执行恶意操作（如转账给攻击者）。\n\n### 常见场景\n\n- 银行转账操作：恶意网站通过表单提交，利用用户的登录状态发起转账请求。\n- 账号设置修改：诱导用户访问恶意页面，自动发送修改邮箱或密码的请求。\n\n### 防范措施\n\n1. **验证请求来源（Referer/Origin）**：\n\n- 服务器检查请求头中的 `Referer` 或 `Origin` 字段，验证请求是否来自可信域名（如网站自身域名）。\n- 示例：仅允许 `Referer` 为 `https://example.com` 的请求执行敏感操作。\n\n2. **使用 CSRF Token（令牌）**：\n\n- 服务器为每个用户生成一个随机的 CSRF Token，存储在 Session 或 Cookie 中，并要求敏感请求（如表单提交）必须携带该 Token。\n- 攻击网站无法获取 Token，因此即使发送请求，服务器验证 Token 失败也会拒绝执行。\n- 示例：\n  - 前端表单中添加 `&lt;input type=\&quot;hidden\&quot; name=\&quot;csrfToken\&quot; value=\&quot;xxx\&quot;&gt;`。\n  - 服务器接收请求时，对比请求中的 Token 与 Session 中的 Token 是否一致。\n\n3. **使用 SameSite Cookie 属性**：\n\n- 为 Cookie 设置 `SameSite=Strict` 或 `SameSite=Lax`，限制 Cookie 仅在同源请求中携带，阻止跨站请求携带 Cookie。\n- `SameSite=Strict`：完全禁止跨站请求携带 Cookie；`SameSite=Lax`：允许 GET 请求跨站携带 Cookie（如链接跳转），但禁止 POST 等请求。\n- 示例：`Set-Cookie: sessionId=xxx; SameSite=Strict`。\n\n4. **要求敏感操作二次验证**：\n\n- 对于转账、修改密码等高危操作，要求用户输入验证码、密码或进行其他身份验证，即使发生 CSRF，攻击者也无法完成操作。\n\n## XSS 与 CSRF 的核心区别\n\n| 维度     | XSS 攻击                           | CSRF 攻击                            |\n| -------- | ---------------------------------- | ------------------------------------ |\n| 攻击目标 | 利用用户对网站的信任，窃取用户信息 | 利用网站对用户的信息，执行未授权操作 |\n| 攻击方式 | 注入恶意脚本，在用户浏览器执行     | 诱导用户发送跨站请求，利用用户身份   |\n| 防御重点 | 过滤输入、限制脚本执行             | 验证请求来源、使用 Token             |\n\n通过上述措施，可有效降低 XSS 和 CSRF 攻击的风险，保障用户数据安全和网站正常运行。实际开发中，需结合业务场景选择合适的防御方案，多层次防护效果更佳。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是 XSS 和 CSRF 攻击？如何防范.mdx&quot;],&quot;digest&quot;:[0,&quot;7b66443674a14342&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是-xss-和-csrf-攻击如何防范&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是跨域？产生跨域的原因是什么？如何解决跨域问题.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是跨域？产生跨域的原因是什么？如何解决跨域问题&quot;],&quot;category&quot;:[0,&quot;浏览器相关&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T13:58:43.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 什么是跨域？\n\n跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的 **同源策略** 限制而产生的限制。这里的“域”由 **协议**、**域名**、**端口** 三部分组成，只要三者中有任何一个不同，就会被视为 **跨域**。\n\n- `http://www.example.com` 与 `https://www.example.com`（协议不同） -&gt; 跨域\n- `http://www.example.com` 与 `http://api.example.com` （域名不同） -&gt; 跨域\n- `http://www.example.com:8080` 与 `http://www.example.com` （端口不同） -&gt; 跨域\n\n## 产生跨域的原因：同源策略\n\n**同源策略**是浏览器的一种安全机制，目的是防止不同域名的网页之间进行恶意数据交互，保护用户信息安全。其核心限制包括：\n\n- 禁止跨域读取 Cookie、LocalStorage、SessionStorage 等本地存储。\n- 禁止跨域操作 DOM （如 iframe 嵌套的跨域页面）。\n- 禁止跨域发现 AJAX/Fetch 请求（即本文重点解决的跨域问题）。\n\n正式由于同源策略的存在，当前端页面与后端接口的域名、协议或端口不一致时，就会出现跨域请求被拦截的问题。\n\n## 跨域问题的解决方法\n\n根据场景不同，跨域问题有多种解决方案，以下是常用方法：\n\n### 1. 服务端设置 CORS （Cross-Origin Resource Sharing，跨域资源共享）\n\n这是最推荐的解决方案，通过服务器在响应头中设置允许跨域的规则，明确告知浏览器允许哪些域名的请求。\n\n#### 原理\n\n浏览器在发送跨域请求时，会先发送一个“预检请求”（OPTIONS方法），询问服务器是否允许跨域。服务器通过响应头 `Access-Control-Allow-*` 告知允许的范围，浏览器根据响应决定是否继续发送实际请求。\n\n#### 常用响应头设置\n\n- `Access-Control-Allow-Origin: http://www.client.com` -&gt; 允许指定域名跨域（* 表示允许所有域名，不推荐生产环境使用）。\n- `Access-Control-Allow-Methods: GET, POST, PUT, DELETE` -&gt; 允许的 HTTP 方法。\n- `Access-Control-Allow-Headers: Content-Type, Authorization` -&gt; 允许的请求头。\n- `Access-Control-Allow-Credentials: true` -&gt; 允许跨域请求携带 Cookie（此时 `Access-Control-Allow-Origin` 不能为 `*`，需指定具体域名）。\n\n**适用场景**：前后端分离项目，后端接口可自主配置（如 Java、Node.js等后端服务）。\n\n### 2. 代理服务器（前端代理）\n\n通过前端工程化工具（如 Webpack、Vite）配置代理，将跨域请求转发为同源请求，避开浏览器的同源策略限制。\n\n#### 原理\n\n开发环境中，前端启动的本地服务器（如 `http://localhost:3000`）与后端接口（如 `http://api.server.com`）跨域时，可配置代理规则：当前端请求 `/api/data` 时，代理服务器自动转发到 `http://api.server.com/api/data`。由于代理服务器与前端页面同源（均为 `localhost:3000`），因此不会触发跨域限制。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  devServer: {\n    proxy: {\n      &#39;/api&#39;: {\n        target: &#39;http://api.server.com&#39;, // 目标接口域名\n        changeOrigin: true, // 允许跨域\n        pathRewrite: {\n          &#39;^/api&#39;: &#39;&#39;\n        } // 去除请求路径中的 /api 前缀（可选）\n      }\n    }\n  }\n}\n```\n\n**适用场景**：开发环境下的跨域调试，无需修改后端代码。\n\n### 3. JSONP（JSON with Padding）\n\n这是一种古老的跨域方案，利用 `&lt;script&gt;` 标签不受同源策略限制的特性实现跨域请求。\n\n#### 原理\n\n- 前端定义一个回调函数（如 `handleData`），用于接收后端返回的数据。\n- 前端动态创建 `&lt;script&gt;` 标签，`src` 指向后端接口，并在 URL 中携带回调函数名（如 `http://api.server.com/data?callback=handleData`）。\n- 后端接收到请求后，将数据包裹在回调函数中返回（如 `handleData({ name: &#39;xxx&#39; })`）。\n- 前端 `&lt;script&gt;` 标签加载后，自动执行回调函数，获取数据。\n\n```js\n// 前端\nfunction handleData(data) {\n  console.log(&#39;跨域&#39;, data);\n}\n\nconst script = document.createElement(&#39;script&#39;);\n\nscript.src = &#39;http://api.server.com/data?callback=handleData&#39;;\ndocument.body.appendChild(script);\n\n// 后端\napp.get(&#39;/data&#39;, (req, res) =&gt; {\n  const data = { name: &#39;跨域数据&#39; };\n  const callback = req.query.callback;\n  \n  res.send(`${callback}(${JSON.stringify(data)})`); // 返回回调函数包裹的数据\n});\n```\n\n#### 局限性\n\n- 仅支持 GET 请求，不支持 POST、PUT 等方法。\n- 安全性低，可能遭受 XSS 攻击（需后端严格过滤数据）。\n\n**适用场景**：老旧系统兼容，或无法使用 CORS 的场景。\n\n### 4. iframe + 跨域通信 API\n\n当需要在两个跨域的 iframe 页面之间通信时，可使用 `postMessage` API。\n\n#### 原理\n\n- 发送方通过 `window.postMessage(data, targetOrigin)` 向目标窗口发送数据，`targetOrigin` 指定允许接收的域名（`*` 表示允许所有）。\n- 接收方通过监听 `message` 事件（`window.addEventListener(&#39;message&#39;, (e) =&gt; { ... })`）接收数据，并验证发送方的域名是否可信（e.origin）。\n\n```js\n// 父页面（http://parent.com）向子 iframe（http://child.com）发送数据\nconst iframe = document.getElementById(&#39;childIframe&#39;);\n\niframe.contentWindow.postMessage({ type: &#39;hello&#39; }, &#39;http://child.com&#39;);\n\n// 子 iframe 页面接收数据\nwindow.addEventListener(&#39;message&#39;, (e) =&gt; {\n  // 验证发送方域名\n  if (e.origin === &#39;http://parent.com&#39;) {\n    console.log(&#39;接收数据：&#39;, e.data);\n  }\n});\n```\n\n**适用场景**：iframe 嵌套跨域页面的通信（如第三方登录、嵌入第三方组件）。\n\n### 5. 其他方法\n\n- **Nginx 反向代理**：通过 Nginx 服务器配置跨域转发，将客户端请求代理到后端接口，本质与前端代理类似，但适用于生产环境。\n- **WebSocket**：WebSocket 协议本身不限制跨域，可通过 `ws://` 或 `wss://` 协议实现跨域实时通信（如聊天应用）。\n\n## 总结\n\n- **首选方案**：服务器端配置 CORS（简单、安全、支持所有 HTTP 方法）。\n- **开发环境**：使用 Webpack/Vite 代理（无需后端配合，方便调试）。\n- **特殊场景**：JSONP（仅 GET 请求）、postMessage（iframe 通信）、Nginx代理（生产环境部署）。\n\n选择方案时需结合项目实际（如前后端控制权、请求类型、安全性要求），有限使用标准且安全的 CORS 方案。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是跨域？产生跨域的原因是什么？如何解决跨域问题.mdx&quot;],&quot;digest&quot;:[0,&quot;82ccb2150441a08c&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是跨域产生跨域的原因是什么如何解决跨域问题&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;浏览器的本地存储方式有哪些？它们的区别和适用场景是什么.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;浏览器的本地存储方式有哪些？它们的区别和适用场景是什么&quot;],&quot;category&quot;:[0,&quot;浏览器相关&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T09:16:56.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;浏览器的本地存储是指将数据存储在用户本地设备上的技术，无需每次从服务器获取，可提升页面加载速度和离线和使用场景上有显著差异。\n\n## Cookie\n\n### 特性\n\n- 容量下，通常限制在 **4KB左右**。\n- 由服务器或客户端设置，每次 HTTP 请求都会自动携带在请求头中（包括跨域请求，需符合 CORS 策略）。\n- 有过期时间（`expires` 或 `max-age`），过期后自动删除；若未设置，则为会话级（关闭浏览器后失效）。\n- 可设置 `domain` 和 `path` 属性，限制 Cookie 的作用范围（如仅在特定域名或路径下生效）。\n- 支持 `HttpOnly` 属性（设置后无法通过 JavaScript 访问，可防止 XSS 攻击）和 `Secure` 属性（仅在 HTTPS 协议下传输）。\n\n### 适用场景\n\n- 存储用户身份标识（如 Session ID），实现会话管理（登录状态保持）。\n- 存储用户偏好设置（如语言、主题），但受限于容量，仅适合少量数据。\n- 用于追踪用户行为（如广告投放），但需注意隐私合规（如 GDPR）。\n\n## localStorage\n\n### 特性\n\n- 容量较大，通常为 **5MB ~ 10MB**（不同浏览器略有差异）。\n- 仅由客户端通过 JavaScript 操作（`localStorage.setItem()/getItem()`），不会随 HTTP 请求发送到服务器。\n- 持久化存储，除非手动删除（通过代码或浏览器设置），否则数据永久保留（关闭浏览器、重启设备后仍存在）。\n- 作用域限制在同一域名（协议、域名、端口均相同），不同域名无法共享数据。\n- 存储的数据为字符串类型，复杂数据（如对象）需通过 `JSON.stringify()` 序列化后存储。\n\n### 适用场景\n\n- 存储大量用户本地数据，_如离线缓存的商品列表、表单草稿（未提交的内容）_。\n- 保存用户长期偏好设置 _（如默认排序方式、是否开启夜间模式）_。\n- 作为前端状态管理的辅助存储（如缓存不常变化的全局数据）。\n\n## sessionStorage\n\n### 特性\n\n- 容量与 `localStorage` 相近（**5MB ~ 10MB**）。\n- 仅在当前会话（标签页或窗口）有效，关闭标签页/窗口后数据立即清除；同一页面的刷新不会删除数据，但不同标签页间无法共享（即使是同一域名）。\n- 仅由客户端 JavaScript 操作，不随 HTTP 请求发送。\n- 作用域限制在同一域名或同一会话，与 `localStorage` 相同。\n\n注意：当在一个标签页下，打开同一域名的新标签，会将 `sessionStorage` 的数据复制到新标签页中，但是当前标签页的 `sessionStorage` 数据发生改变时，不会同步到新标签页。\n\n### 适用场景\n\n- 存储临时会话数据，_如单页应用（SPA）中的路由参数、临时表单数据（仅在当前页有效）。_\n- 防止用户重复提交表单（存储提交状态，页面刷新后仍可读取）。\n- 存储敏感的临时数据（_如用户输入的验证码_），避免持久化带来的隐私风险。\n\n## IndexDB\n\n### 特性\n\n- 大容量存储，理论上无上限（受限于用户设备存储空间）。\n- 基于 NoSQL 的数据库，支持复杂数据结构（对象、二进制数据等），可通过索引高效查询。\n- 异步操作（不会阻塞主线程），适合处理大量数据。\n- 持久化存储，作用域为同一域名，数据不会随会话结束而删除。\n- 支持事物操作，保证数据的完整性。\n\n### 适用场景\n\n- 存储大量结构化数据，如离弦应用的本地数据库（_如离线地图数据、文档编辑历史_）。\n- 缓存需要频繁查询的数据（_如用户的历史订单记录_），减少服务器请求。\n- 实现复杂的前端数据交互（_如本地搜索、数据过滤_），提升操作响应速度。\n\n## 四种存储方式的核心区别\n\n| 特性             | Cookie                | localStorage        | sessionStorage       | IndexDB                    |\n| ---------------- | --------------------- | ------------------- | -------------------- | -------------------------- |\n| **容量**         | 约 4KB                | 5MB ~ 10MB          | 5MB ~ 10MB           | 理论上无上限               |\n| **有效期**       | 可设置过期时间        | 永久（手动删除）    | 会话级（关闭标签页） | 永久（手动删除）           |\n| **网络请求携带** | 是（自动）            | 否                  | 否                   | 否                         |\n| **操作方式**     | 客户端/服务器均可设置 | 仅客户端 JavaScript | 仅客户端 JavaScript  | 仅客户端 JavaScript        |\n| **数据类型**     | 字符串                | 字符串（需序列化）  | 字符串（需序列化）   | 复杂数据（对象、二进制等） |\n| **作用域**       | 同域名（可跨路径）    | 同域名              | 同域名 + 同会话      | 同域名                     |\n\n## 选择建议\n\n- 需与服务器交互的少量数据（如身份验证）-&gt; Cookie。\n- 长期存储的非敏感数据（如用户偏好）-&gt; localStorage。\n- 临时会话数据（如表单临时内容）-&gt; sessionStorage。\n- 大量结构化数据（如离线缓存）-&gt; IndexDB。\n\n实际开发中，需根据数据量、有效期、是否跨会话等需求综合选择，同时注意隐私安全（如避免存储敏感信息在 `localStorage` 中，防止 XSS 攻击）和浏览器兼容性（IndexDB 在老旧浏览器中支持有限）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/浏览器的本地存储方式有哪些？它们的区别和适用场景是什么.mdx&quot;],&quot;digest&quot;:[0,&quot;56e4cbbe5210259d&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;浏览器的本地存储方式有哪些它们的区别和适用场景是什么&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是回流和重绘？如何减少回流和重绘.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是回流和重绘？如何减少回流和重绘&quot;],&quot;category&quot;:[0,&quot;浏览器相关&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T04:33:52.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 回流（Reflow）\n\n回流也称为重排，是指浏览器为了重新计算元素的几何属性（如位置、尺寸、宽高、边距等），并重新构建渲染树的过程。当元素的几何属性发生变化时，浏览器需要重新遍历渲染树，计算每个受影响元素的新位置和大小，这个过程会消耗大量的计算资源。\n\n引发回流的常见操作包括：\n\n- 改变元素的宽高、边距、内边距等几何属性，如 `width: 200px;`\n- 改变元素的定位方式，如从 `static` 改为 `absolute` 或 `fixed`\n- 增加或删除 DOM 元素，导致渲染树结构发生变化\n- 浏览器窗口大小改变（`resize`事件）\n- 滚动页面，某些元素的位置需要重新计算\n- 读取或修改会触发浏览器即时布局的属性，如 `offsetWidth`、`scrollTop`、`getComputedStyle()` 等\n\n## 重绘（Repaint）\n\n重绘是指当元素的外观属性（如颜色、背景色、阴影等）发生变化，但几何属性未改变时，浏览器重新绘制元素外观的过程。此时元素的位置和大小没有变化，渲染树的结构也未改变，只是元素的视觉表现需要更新。\n\n引发重绘的常见操作包括：\n\n- 改变元素的颜色，如 `color: red;`\n- 改变元素的背景色，如 `background-color: #fff;`\n- 改变元素的阴影效果，如 `box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);`\n- 改变元素的透明度，如 `opacity: 0.5;`（在某些浏览器中，透明度变化可能触发回流）\n\n## 回流和重绘的关系及性能影响\n\n- 回流必然会导致重绘，因为元素的几何属性改变后，其外观也一定会发生变化，需要重新绘制。\n- 重绘不一定会引发回流，当仅元素的外观属性改变而几何属性不变时，只需要重绘即可。\n- 两者都会消耗浏览器性能，尤其是回流，由于涉及到大量的几何计算和渲染树重构，其性能消耗远大于重绘。在频繁操作下，可能会导致页面卡顿、响应变慢，影响用户体验。\n\n## 减少回流和重绘的方法\n\n### 1.集中修改样式\n\n避免频繁地单个修改元素的样式属性，而是通过一次性修改 `class` 或 `style` 属性来批量更新样式。例如：\n\n```js\n// 不好的做法：多次修改可能引发多次回流\nelement.style.width = &#39;100px&#39;;\nelement.style.height = &#39;100px&#39;;\nelement.style.margin = &#39;10px&#39;;\n\n// 好的做法：一次修改，减少回流次数\nelement.className = &#39;new-style&#39;; // 通过 class 批量应用样式\n// 或者\nelement.style.cssText = &#39;width: 100px; height: 100px; margin: 10px;&#39;;\n```\n\n### 2. 使用文档片段（DocumentFragment）\n\n当需要添加多个 DOM 元素时，先将元素添加到文档片段中，再将文档片段一次性添加到 DOM 树中，文档片段时存在于内存中的 DOM 节点容器。不会触发页面渲染，因此能减少回流次数。\n\n```js\nconst fragment = document.createDocumentFragment();\n\nfor (let i = 0; i &lt; 10; i++) {\n  const div = document.createElement(&#39;div&#39;);\n  \n  div.textContext = `Item ${i}`;\n  fragment.appendChild(div);\n}\n\ndocument.body.appendChild(fragment);\n```\n\n### 3. 隐藏元素后操作\n\n先将元素设置为 `display: none;`，使其脱离渲染树，此时对元素进行的所有修改都不会引发回流和重绘，修改完成后再恢复显示。\n\n```js\nelement.style.display = &#39;none&#39;;\n// 进行一系列样式或 DOM 操作\nelement.style.width = &#39;200px&#39;;\nelement.appendChild(newChild);\nelement.style.display = &#39;block&#39;; // 仅触发一次回流\n```\n\n### 4. 使用绝对定位或固定定位\n\n将元素设置为 `position: absolute` 或 `fixed`，使元素脱离文档流，此时元素的变化不会影响其他元素的几何属性，从而减少回流的范围。适用于需要频繁修改位置或大小的元素，如动画元素。\n\n### 5. 避免触发即时布局\n\n浏览器为了优化性能，会将多次回流操作合并成一次执行。但如果在修改样式的过程中，读取了会触发即时布局的属性（如 `offsetWidth`、`scrollheight`、`getComputedStyle()`等），浏览器会强制立即执行之前的回流操作，以保证读取到正确的属性值。因此，应避免在修改样式的过程中频繁读取这些属性。\n\n```js\n// 不好的做法：触发多次即时回流\nfor (let i = 0; i &lt; 10; i++) {\n  element.style.width = `${element.offsetWidth + 10}px`;\n}\n\n// 好的做法：先读取属性，再批量修改\nlet width = element.offsetWidth;\n\nfor (let i = 0; i &lt; 10; i++) {\n  width += 10;\n}\n\nelement.style.width = `${width}px`; // 仅触发一次回流\n```\n\n### 6. 利用 CSS 硬件加速\n\n使用 `transform`、`opacity`、`filter` 等CSS属性时，浏览器会将元素放入独立的复合图层中，这些属性的变化只会触发合成操作，而不会引发回流或重绘，从而提升性能。\n\n```css\n.animate {\n  /* 仅触发合成，无回流和重绘 */\n  transform: translate(100px, 0);\n}\n```\n\n但需要注意的是，**不要过度**使用复合图层，因为每个复合图层都需要 **占用一定的内存资源**。\n\n### 7. 优化动画性能\n\n- 对于动画元素，尽量使用 `transform` 和 `opacity` 来实现动画效果，避免使用会触发回流的属性（如 `top`、`left`、`width`等）。\n- 可以将动画元素设置为 `will-change: transform;`，提示浏览器该元素可能会发生变换，提前进行优化准备，但同样不宜过度使用。\n\n通过采用上述措施，可以有效减少回流和重绘的次数及范围，提高页面的渲染性能，使页面更加流畅。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是回流和重绘？如何减少回流和重绘.mdx&quot;],&quot;digest&quot;:[0,&quot;e99de769a134e3a7&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是回流和重绘如何减少回流和重绘&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制&quot;],&quot;category&quot;:[0,&quot;浏览器相关&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T03:10:09.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;浏览器的渲染过程是将 HTML、CSS、JavaScript 等资源转换为可视化页面的过程，主要分为以下几个核心步骤：\n\n## 1. 解析 HTML 构建 DOM 树\n\n- **解析 HTML**：浏览器接收 HTML 字节数据后，先将其转换为字符（基于编码如 UTF-8），再通过词法分析将字符转换为标签（如 `&lt;div&gt;`、`&lt;p&gt;`），最后通过语法分析构建节点间的父子关系。\n- **生成 DOM 树**：DOM（文档对象模型）是HTML的树形表示，每个标签对应一个节点，文本和属性也会作为节点的一部分。DOM 树描述了页面的结构，但不包含样式信息。\\*例如，`&lt;html&gt;&lt;body&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;`会生成以`&lt;html&gt;`为根节点，`&lt;body&gt;`为子节点，`&lt;p&gt;`为孙节点的 DOM 树。\n\n## 2. 解析 CSS 构建 CSSOM 树\n\n- **解析 CSS**：浏览器同时会解析 CSS 资源（包括`&lt;style&gt;`标签内的样式、`&lt;link&gt;`引入的外部 CSS），过程类似 HTML 解析：先转换为字符，再解析为 CSS 规则（如，选择器、属性键值对）。\n- **生成 CSSOM 树**：CSSOM（CSS 对象模型）是 CSS 规则的树形表示，每个节点对应 DOM 树中的节点，包含该节点的样式信息。CSSOM 树具有层级结构，子节点会继承父节点的样式（如`&lt;body&gt;` 的样式会被其下所有元素继承，除非被覆盖）。_例如，`body { color: black; } p { font-size: 16px; }` 会生成对应 `body` 和`p` 节点的 CSSOM 树，`p` 节点同时继承 `body` 的 `color` 属性。_\n\n## 3. 构建渲染树（Render Tree）\n\n渲染树是 DOM 树与 CSSOM 树的结合，仅包含需要显示的节点及其样式信息，不包含隐藏节点（如 `display: none` 的元素）。\n\n- 过程：遍历 DOM 树，为每个课间节点匹配 CSSOM 树中对应的样式规则，将节点和样式组合成渲染树节点。\n- 特点：渲染树中的节点（成为“渲染对象”）按其在页面中的显示顺序排列，为后续布局和绘制做准备。\n\n## 4. 布局（Layout/Reflow）\n\n布局阶段（也称“回流”）是根据渲染树计算每个节点的几何信息（如位置、尺寸、宽高）的过程。\n\n- 浏览器从渲染树的根节点开始，递归计算每个节点的坐标和大小，确定其在页面中的精确位置。\n- 布局结果会生成一个“盒模型”，描述每个元素的边距、边框、内边距、内容区域的几何信息。\n- 布局是一个流式过程，父节点的布局会影响子节点（如父元素宽度变化会导致子元素宽度重新计算）。\n\n## 5. 绘制（Painting）\n\n绘制阶段是根据渲染树和布局信息，将节点的样式（如颜色、背景、阴影）会知道屏幕上的过程。\n\n- 浏览器会渲染树的顺序，调用图形 API（如Skia、Direct2D）绘制每个节点的可视部分（如填充背景颜色、绘制文本、绘制边框）。\n- 绘制可以拆分为多个层（_例如，页面中的固定导航栏、滚动区域可作为独立层_），层之间独立绘制，提升效率。\n\n## 6. 合成（Compositing）\n\n合成阶段将页面的所有绘制层合并为一个图层，并显示在屏幕上。\n\n- 对于有重叠的层（如悬浮的弹窗覆盖在背景层上），浏览器会按层的 Z 轴顺序（层叠上下文）进行合成，确保正确的显示顺序。\n- 现代浏览器会利用 GPU 加速合成的过程，尤其是涉及动画、transform等操作时，可避免重绘整个页面，提升性能。\n\n## 总结浏览器渲染过程\n\n1. 解析 HTML -&gt; 生成 DOM 树\n2. 解析 CSS -&gt; 生成 CSSOM 树\n3. 结合 DOM 与 CSSOM -&gt; 生成渲染树\n4. 根据渲染树 -&gt; 计算布局（几何信息）\n5. 根据布局信息 -&gt; 绘制节点样式\n6. 合成所有图层 -&gt; 显示在屏幕上\n\n这个过程是逐步进行的，浏览器会优先渲染首屏内容，同时继续解析和渲染剩余内容。理解渲染过程有助于优化页面性能（如减少布局和绘制次数）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制.mdx&quot;],&quot;digest&quot;:[0,&quot;184e28f94a046acb&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;详细解释浏览器的渲染过程包括-dom-树cssom-树的构建以及页面布局和绘制&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;介绍你使用过的前端测试工具和测试框架，以及它们的使用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;介绍你使用过的前端测试工具和测试框架，以及它们的使用场景&quot;],&quot;category&quot;:[0,&quot;工程化与工具&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-15T02:34:44.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;前端测试是保证代码质量的重要手段，不同的测试工具和框架适用于不同的测试场景，以下是我常用的工具及场景：\n\n## 1. 单元测试工具\n\n- **Jest**：\n  - 是一个由 Facebook 开发的全功能测试框架，内置断言库、测试运行器、mocking 工具和代码覆盖率报告功能，零配置即可使用。\n  - **适用场景**：React、Vue等框架的组件单元测试，JavaScript函数、工具类的逻辑测试。_例如：测试一个计算金额的工具函数是否正确处理各种边界情况，或者测试一个 React 组件在不同 props 下的渲染结果。_\n  - **优势**：API 简洁，支持快照测试（通过对比组件渲染的快照判断是否发生意外变化），运行速度快，对异步代码测试支持友好。\n- **Mocha + Chai**：\n  - Mocha 是一个灵活的测试运行器，需要配合断言库（如 Chai）使用，本身不提供断言功能，扩展性强。\n  - **使用场景**：复杂页面逻辑的单元测试，需要自定义测试流程或使用特定断言封国（如 Chai 的 `expect/should/assert`）的场景。_比如，测试一个包含多个步骤的表单验证逻辑，可通过 Mocha 的钩子函数（`before/after`）设置测试前置条件和清理工作。_\n  - **优势**：灵活性高，支持多种测试风格，生态丰富，可与 Sinon （用于 mocking 和 stubbing）等工具配合使用。\n\n## 2. 组件测试工具\n\n- **React Testing Library**：\n  - 基于 DOM 测试库，专注于从用户使用角度测试 React 组件，强调测试组件的行为而非实现细节。\n  - **适用场景**：React 组件的交互测试，如点击按钮后是否显示正确内容、表单输入是否触发验证等。_例如，测试一个登录按钮，点击后是否跳转到首页或显示错误提示。_\n  - **优势**：鼓励编写更健壮的测试（不依赖组件内部实现），当组件重构时测试仍能通过，与 React 生态继承良好。\n- **Vue Test Utils**：\n  - 是 Vue 官方的组件测试工具库，提供了一系列 API 用于挂载组件、模拟用户交互、访问组件内部状态等。\n  - **适用场景**：Vue组件的单元测试和集成测试，_比如，测试一个弹窗组件在不同状态下的显示/隐藏逻辑，或者测试组件的生命周期钩子是否正确执行。_\n  - **优势**：专为 Vue 设计，能深度访问组件实例，支持 Vue 的特性（如 v-model、指令）测试。\n\n## 3. 端到端（E2E）测试工具\n\n- **Cypress**：\n  - 是一个现代化的 E2E 测试工具，基于浏览器运行，提供实时重载、时间旅行（可会看测试执行过程）、自动等待等功能，无需配置即可录制测试视频。\n  - **适用场景**：模拟真实用户操作的全流程测试，_如电商网站的“加入购物车 -&gt; 结算 -&gt; 支付”完整流程，验证页面在真实浏览器环境中的交互是否正常_。\n  - **优势**：操作简单、调试方便，无需处理异步等待问题（内置智能等待），对单页应用（SPA）支持良好。\n- **Playwright**：\n  - 由 Microsoft 开发，支持多浏览器（Chrome、Firefox、Safari等）测试，可跨平台运行，提供强大的自动化 API。\n  - **适用场景**：需要在不同浏览器中验证兼容性的 E2E 测试，_例如测试一个响应式网站在不同浏览器和设备尺寸下的布局是否正确，或者测试涉及文件上传、下载的复杂交互流程。_\n  - **优势**：浏览器兼容性好，支持无头模式（无界面运行，提升 CI 环境测试速度），API设计直观。\n\n## 4. 其他测试工具\n\n- **Enzyme**：\n  - 常与 Jest 配合使用，是 React 的组件测试工具，提供了更灵活的组件查询和操作方式，可深入组件内部获取状态和属性。\n  - **适用场景**：需要详细测试 React 组件内部状态变化的单元测试，_例如，测试一个表单组件的输入值是否正确更新组件 state。_\n- **Karma**：\n  - 是一个测试运行器，可在多种真实浏览器或Headless浏览器中执行测试，常与 Jasmine、Mocha 等框架配合使用。\n  - **适用场景**：需要在不同浏览器环境中验证代码兼容性的测试，_例如，确保一个工具函数在 IE 11和现代浏览器中表现一致。_\n  \n## 总结\n\n- 单元测试优先选择 **Jest**（简单场景）或 **Mocha + Chai**（复杂场景），搭配框架专属工具（如 React Testing Library、Vue Test Utils）测试组件。\n- E2E 测试根据需求选择 **Cypress**（单浏览器快速测试）或 **Playwright**（多浏览器兼容性测试）。\n- 实际项目中，通常会结合多种工具构建测试体系：单元测试覆盖核心逻辑，组件测试保证 UI 正确性，E2E 测试验证关键业务流程，全方位提升代码质量。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/介绍你使用过的前端测试工具和测试框架，以及它们的使用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;e23242314a8ea1bd&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;介绍你使用过的前端测试工具和测试框架以及它们的使用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint&quot;],&quot;category&quot;:[0,&quot;工程化与工具&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T18:38:35.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;ESLint是一个开源的 JavaScript 代码检查工具，它通过预设的规则或自定义规则分析代码，识别并报告不符合规则的语法、风格或潜在错误，帮助开发者写出更规范、更健壮的代码。\n\n## 核心作用\n\n- **统一代码风格**：确保团队成员遵循一致的编码规范（如缩进、命名规则、引号类型等），减少因风格差异导致的协作成本。\n- **提前发现错误**：检测语法错误（如未声明的变量、函数参数不匹配）、逻辑隐患（如死循环、未使用的变量），在代码运行前规避问题。\n- **提升代码质量**：约束不良编程习惯（如全局变量滥用、回调地狱），促进写出可维护、高性能的代码。\n- **集成自动化流程**：可与 Git Hooks（如提交代码前）、CI/CD流程结合，阻止不符合规范的代码提交或部署。\n\n## 项目中配置 ESLint 的步骤（以 Vue/React 项目为例）\n\n### 1. 安装依赖\n\n首先在项目中安装 ESLint 及相关插件（根据项目类型选择）：\n\n```bash\n# 基础安装\nnpm install eslint -C\n\n# React 项目需额外安装\nnpm install eslint-plugin-react eslint-plugin-react-hooks -D\n\n# Vue 项目需额外安装（配合 Vue 3）\nnpm install eslint-plugin-vue @vue/eslint-config-prettier -D\n\n# TypeScript 项目需额外安装\nnpm install @typescript-eslint/parser @typescript-eslint/eslint-plugin -D\n```\n\n### 2. 初始化配置文件\n\n执行以下命令生成配置文件（`.eslintrc.js` 或 `.eslintrc.json`），根据提示选择项目类型、模块系统、框架等：\n\n```bash\nnpx eslint --init\n```\n\n配置文件核心内容包括：\n\n- `parser`：指定解析器（如 `@typescript-eslint/parser` 用于 TS）。\n- `extends`：继承预设规则集（如 `eslint:recommended`、 `plugin:react/recommended`）。\n- `plugins`：引入插件（如 `react`、`vue`）。\n- `rules`：自定义规则（值为 `off` 禁用、`error` 报错、`warn` 警告）\n\n示例（Vue项目的 `.eslintrc.js`）：\n\n```js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  extends: [\n    \&quot;eslint:recommended\&quot;,\n    \&quot;plugin:vue/vue3-essential\&quot;, // Vue 3核心规则\n    \&quot;prettier\&quot; // 与Prettier兼容（需配合eslint-config-prettier）\n  ],\n  parserOptions: {\n    ecmaVersion: \&quot;latest\&quot;,\n    sourceType: \&quot;module\&quot;,\n  },\n  plugins: [\&quot;vue\&quot;],\n  rules: {\n    \&quot;no-console\&quot;: \&quot;warn\&quot;, // 警告使用console\n    \&quot;vue/multi-word-component-names\&quot;: \&quot;off\&quot;, // 关闭Vue组件名必须多单词的规则\n    \&quot;indent\&quot;: [\&quot;error\&quot;, 2], // 强制2空格缩进\n  },\n};\n```\n\n### 3. 添加忽略文件（可选）\n\n创建 `.eslintignore` 文件，指定无需检查的文件/目录（如 `node_modules`、打包后的 `dist` 文件夹）\n\n```\nnode_modules/\ndist/\n*.min.js\n```\n\n### 4. 配置脚本命令\n\n在 `package.json` 中添加脚本，方便手动执行检查或修复：\n\n```json\n{\n  \&quot;scripts\&quot;: {\n    \&quot;lint\&quot;: \&quot;eslint .\&quot;, // 检查所有文件\n    \&quot;lint:fix\&quot;: \&quot;eslint . --fix\&quot; // 自动修复可修复的错误\n  }\n}\n```\n\n### 5. 集成开发工具\n\n在 VS Code 中安装 `ESLint` 插件，开启自动修复（`settings.json`）\n\n```json\n{\n  \&quot;editor.codeActionsOnSave\&quot;: {\n    \&quot;source.fixAll.eslint\&quot;: true // 保存时自动修复 ESLint 问题\n  }\n}\n```\n\n### 6. 结合 Git Hooks\n\n通过 `husky` 在代码提交前自动执行 ESLint 检查，阻止不规范代码提交：\n\n```bash\n# 安装 husky\nnpm install husky -D\n# 初始化 husky\nnpx husky install\n# 添加 pre-commit 钩子\nnpx husky add .husky/pre-commit \&quot;npx lint-staged\&quot;\n```\n\n再配置 `lint-staged`（仅检查暂存区文件）\n\n```json\n// package.json\n{\n  \&quot;lint-staged\&quot;: {\n    \&quot;*.{js,jsx,vue,ts,tsx}\&quot;: \&quot;eslint --fix\&quot;\n  }\n}\n```\n\n通过以上配置，ESLint可在开发、提交、部署全流程中发挥作用，从源头保障代码质量和团队协作效率。实际使用中，可根据项目需求灵活调整规则，平衡规范严格性与开发效率。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint.mdx&quot;],&quot;digest&quot;:[0,&quot;04db1e031a00acae&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是-eslint它的作用是什么如何在项目中配置-eslint&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别&quot;],&quot;category&quot;:[0,&quot;工程化与工具&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T17:57:44.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;模块化是将复杂程序拆分为可复用、可维护的独立模块的开发模式，每个模块拥有自己的作用域，通过特定语法暴露接口供其他模块使用，同时可依赖其他模块。其核心价值在于解决代码复用、命名冲突、依赖管理等问题，是现代前端工程化的基础。\n\n## CommonJS、AMD、CMD 和 ES6 模块的区别\n\n| 维度     | CommonJS                      | AMD                      | CMD                                    | ES6模块（ESM）             |\n| ------------ | ----------------------------- | ------------------------ | -------------------------------------- | -------------------------- |\n| **适用环境** | 服务端（Node.js） ｜ 浏览器端 | 浏览器端                 | 浏览器端、服务端（Node.js 13.2+ 支持） |\n| **加载方式** | 同步加载（运行时加载）        | 异步加载（提前加载依赖） | 异步加载（就近加载依赖）               | 静态加载（编译时确定依赖） |\n| **依赖处理** | 运行时才解析依赖，加载顺序由代码执行顺序决定 | 定义模块时需提前声明所有依赖（`deps` 数组） | 依赖就近书写，在 `require` 时才加载 | 编译时分析依赖，`import` 必须放在模块顶部 |\n| **暴露模块方式** | `module.exports` 或 `exports` | `define` 函数的返回值 | `define` 函数的返回值 | `export`（命名导出）或`export default`（默认导入） |\n| **引入模块方式** | `require(&#39;模块路径&#39;)` | `require`回调函数中获取依赖 | `require(&#39;模块路径&#39;)` | `import(&#39;命名导入&#39;)` 或 `import ... from`（默认导入） |\n| **执行时机** | 模块加载时执行，缓存结果，再次加载直接取缓存 | 依赖加载完成后执行模块回调 | 模块加载后，遇到 `require` 时执行依赖 | 编译时静态分析，模块内代码在导入时执行（只执行一次） |\n| **典型实现/工具** | Node.js原生支持 | RequireJS | SeaJS | 浏览器原生支持（`&lt;script type=\&quot;module\&quot;&gt;`）、Webpack等 | \n\n## 关键差异解析\n\n### 1. 加载机制\n\n- CommonJS 为同步加载，适合服务器端（文件存储在本地，加载速度快），但不适合浏览器端（同步加载会阻塞页面渲染）。\n- AMD/CMD 为异步加载，专为浏览器端设计，避免阻塞。AMD 强调 “依赖前置”（提前声明所有依赖），CMD 强调“依赖就近”（用到时再加载）。\n\n### 2. 模块作用域\n\n- CommonJS 模块中，`module.exports` 是模块的对外接口，每个模块是一个独立的 `module` 对象。\n- ES6 模块中，`export` 导出的是绑定（而非值），导入的变量会跟随导出端变化（动态关联），而 CommonJS 导出的是值的拷贝。\n\n### 3. 循环依赖处理\n\n- CommonJS 处理循环依赖时，会返回未完全执行的模块缓存，可能导致部分变量未定义。\n- ES6 模块通过静态分析，循环依赖时能正确饮用模块的实时状态，更可靠。\n\n## 总结\n\n- CommonJS 是服务器端模块化的标准，同步加载合适本地文件。\n- AMD/CMD 是浏览器端早期异步模块化方案，现已逐渐被 ES6 模块取代。\n- ES6 模块是官方标准，兼顾浏览器和服务器端，静态加载、动态绑定等特性使其成为现代前端模块化的首选，也是 Webpack、Vite等构建工具的默认模块系统。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别.mdx&quot;],&quot;digest&quot;:[0,&quot;6c7f93eb66cce5c8&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对模块化的理解commonjsamdcmd-和-es6-模块有哪些区别&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载&quot;],&quot;category&quot;:[0,&quot;工程化与工具&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T14:33:05.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## Webpack 工作原理\n\nWebpack 是一个现代 JavaScript 应用的静态模块打包工具，其核心思想是“一切皆模块”，通过递归解析项目中所有模块的依赖关系，最终将这些模块打包成一个或多个静态资源（bundle）。\n\n### 工作流程主要包括\n\n1. **入口（Entry）**：Webpack 以 `entry` 配置指定的文件为起点，递归解析其依赖的所有模块（如 JS、CSS、图片等）。\n2. **模块解析（Module Resolution）**：根据 `resolve` 配置解析模块路径，找到对应的文件（如处理 `import &#39;./utils&#39;`时，自动查找 `utils.js`、`utils/index.js`等）。\n3. **模块转换（Module Transformation）**：通过 `module.rules` 配置的 Loader 对不同类型的模块进行转换（如用 `babel-loader` 将 ES6+ 转换为 ES5，用 `css-loader` 处理 CSS 模块，用 `url-loader` 处理图片）。\n4. **依赖图谱构建（Dependency Graph）**：在解析和转换过程中，Webpack会构建一个包含所有模块及依赖关系的依赖图谱。\n5. **代码优化与chunk生成**：根据 `optimization` 配置进行优化（如 Tree-Shaking 剔除未使用代码、代码压缩），并将依赖图谱中的模块按规则拆分为多个 `chunk`(代码块)。\n6. **输出（Output）**：最后通过 `output` 配置将 `chunk` 输出到指定目录（如 `dist` 文件夹），生成可在浏览器运行的静态资源。\n\n## 代码分割（Code Splitting）\n\n代码分割时将代码拆分为多个独立的 `chunk`，实现按需加载或并行加载，减少单个 bundle 体积，提升加载速度。Webpack实现代码分割的方式有：\n\n### 1. 多入口分割\n\n通过 `entry` 配置多个入口，每个入口生成一个独立 bundle。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: {\n    home: &#39;./src/home.js&#39;,\n    about: &#39;./src/about.js&#39;\n  },\n  output: {\n    filename: &#39;[name].bundle.js&#39;, // 输出home.bundle.js, about.bundle.js\n    path: path.resolve(__dirname, &#39;dist&#39;)\n  }\n};\n```\n\n### 2. 公共代码分割\n\n通过 `splitChunks` 提取多入口或模块间的公共依赖（如 React、Vue 等库），避免重复打包。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: &#39;all&#39;, // 对所有类型的 chunk（入口chunk、异步chunk）生效\n      cacheGroups: {\n        // 提取第三方库\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: &#39;vendors&#39;,\n          chunks: &#39;all&#39;\n        },\n        // 提取公共模块\n        common: {\n          minChunks: 2, // 模块至少被引用两次才提取\n          name: &#39;common&#39;,\n          chunks: &#39;all&#39;\n        }\n      }\n    }\n  }\n};\n```\n\n### 3. 动态导入分割\n\n通过 ES6 的 `import()` 语法动态导入模块，Webpack 会自动将其拆分为独立 chunk，实现按需加载（配合懒加载使用）。\n\n## 懒加载（Lazy Loading）\n\nWebpack 的懒加载依赖动态导入（`import()`），通过将非首屏必要的模块拆分为独立chunk，在用户需要时（如点击按钮、路由切换）再加载，减少首屏加载时间。\n\n### 1. 路由懒加载（以 React Router 为例）\n\n- `React.lazy` 接收一个返回 `import()` 的函数，`import()` 返回 Promise，加载成功后返回组件。\n- `&lt;Suspense&gt;` 用于在懒加载组件加载完成前显示占用内容（如加载动画）。\n\n```js\n// 不使用懒加载（一次性加载所有路由组件）\nimport Home from &#39;./pages/Home&#39;;\nimport About from &#39;./pages/About&#39;;\n\n// 使用懒加载（Webpack自动拆分Home、About为独立chunk）\nconst Home = React.lazy(() =&gt; import(&#39;./pages/Home&#39;));\nconst About = React.lazy(() =&gt; import(&#39;./pages/About&#39;));\n\n// 路由配置\n&lt;Route path=\&quot;/home\&quot; element={&lt;Suspense fallback={&lt;Loading /&gt;}&gt;}&gt;&lt;/Route&gt;\n```\n\n### 2. 组件/功能懒加载（按需触发）\n\n```js\n// 点击按钮时加载弹窗组件\nconst handleClick = () =&gt; {\n  const { Modal } = await import(&#39;./components/Modal&#39;); // 动态导入\n  \n  Modal.show(&#39;这是懒加载的弹窗&#39;);\n};\n```\n\n## 总结\n\nWebpack 通过解析依赖图谱将模块打包为 bundle，代码分割通过多个入口、公共代码提取、动态导入实现 chunk 拆分，懒加载则基于动态导入实现模块按需加载。两者结合可显著优化大型项目的加载性能，是前端工程化中提升用户体验的关键手段。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载.mdx&quot;],&quot;digest&quot;:[0,&quot;1b71e10dc01c6a20&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;介绍-webpack-的工作原理以及如何通过-webpack-进行代码分割和懒加载&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是前端工程化？它包含哪些方面的内容.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是前端工程化？它包含哪些方面的内容&quot;],&quot;category&quot;:[0,&quot;工程化与工具&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T08:39:23.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;前端工程化是指将前端开发流程规范化、标准化，通过工具和技术手段解决开发效率、代码质量、协作流程等问题，使前端开发“碎片化”、“手工化”向“系统化”、“自动化”转变的过程。其核心目标是提高开发效率、保证代码质量、降低维护成本。让团队能更高效地开发和交付大型前端项目。\n\n## 前端工程化包含以下几个方面\n\n### 项目初始化和脚手架\n\n通过脚手架工具（如 vite、taro cli等）快速生成标准化的项目结构，包括预设的目录布局、配置文件、依赖管理等。避免重复搭建项目的繁琐工作，确保团队项目结构一致。\n\n### 模块化和组件化\n\n- **模块化**：将代码按功能拆分为独立模块（如 JS模块、CSS模块等），通过模块系统（如 ES Module、CommonJS）实现依赖管理和代码复用，避免全局变量污染，提高代码可维护性。\n- **组件话**：将 UI 界面拆分为独立可复用的组件（如 React组件、Vue组件），每个组件包含自身的结构、样式和逻辑，实现“一次开发，多处使用”，简化复杂界面的开发和维护。\n\n### 构建工具与自动化\n\n- **代码转换**：通过 Babel 将 ES6+ 语法转换为浏览器兼容的 ES5 语法；通过 PostCSS 处理 CSS（如自动添加浏览器前缀、转换CSS变量）。\n- **资源优化**：对 JS、CSS 等资源进行压缩（如 Terser 对 JS 进行压缩，CSSNano 对 CSS 进行压缩）、合并、Tree-Sharking（剔除未使用的代码），减少资源体积。\n- **自动化构建**：使用 Webpack、Vite、Rollup等构建工具，通过配置实现“一键构建”，自动完成代码转换、资源优化、打包输出等流程，代替手动操作。\n\n### 代码质量与规范\n\n- **代码规范**：通过 ESLint、StyleLint等工具强制遵循团队编码规范（如缩进、命名、语法错误等），避免代码风格混乱。\n- **代码审查**：结合 Git Hooks（如 husky）在代码提交前自动执行 lint 检查、单元测试，确保不符合规范的代码无法提交，减少代码缺陷。\n- **测试自动化**：通过 Jest、Mocha 等框架编写单元测试、集成测试，通过 Cypress、Playwright 等进行 E2E 测试，自动化验证代码功能，提前发现问题。\n\n### 版本控制与协作流程\n\n基于 Git 进行版本管理，制定分支策略（如 Git Flow、Github Flow），规范代码提交（如通过 commitlint 强制提交信息格式），确保团队协作有序，便于版本回溯和问题定位。\n\n### 部署与 CI/CD\n\n- **自动化部署**：通过 CI/CD 工具（如 Jenkins、GitHub Actions、GitLab CI）实现代码提交后自动构建、测试、部署到开发/测试/生产环境，避免手动部署的错误和时间成本。\n- **环境管理**：通过配置文件区分开发、测试、生产环境的变量（如 API地址），避免硬编码，实现环境隔离。\n\n### 监控与日志\n\n- **前端监控**：通过 Sentry、Fundebug 等工具监控线上代码错误、性能指标（如首屏页面加载时间、接口响应时间），及时发现和修复问题。\n- **日志收集**：收集用户行为日志、错误日志，为产品优化和问题排查提供数据支持。\n\n前端工程化不是单一工具或技术，而是一套涵盖 `开发 -&gt; 构建 -&gt; 测试 -&gt; 部署 -&gt; 监控` 全流程的解决方案，其核心是通过标准化和自动化提升团队效率和项目质量，尤其在大型前端项目和多人协作场景中不可或缺。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是前端工程化？它包含哪些方面的内容.mdx&quot;],&quot;digest&quot;:[0,&quot;f8fb8ef5ccc8fb8f&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是前端工程化它包含哪些方面的内容&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;如何优化 JavaScript 的执行性能.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;如何优化 JavaScript 的执行性能&quot;],&quot;category&quot;:[0,&quot;性能优化&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T07:54:10.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;JavaScript 的执行性能直接影响页面的响应速度和用户体验，尤其是长任务阻塞主线程会导致页面卡顿。优化方向主要集中在减少执行时间、避免主线程阻塞、提升代码效率等方面。\n\n## 1. 减少主线程阻塞\n\n- **拆分长任务**：将执行时间超过 50ms 的长任务拆分为多个短任务，利用 `requestIdleCallback` 或 `setTimeout` 在浏览器空闲时执行，避免长时间占用主线程。\n\n例如：用 `requestIdleCallback` 处理非紧急计算：\n\n```js\nrequestIdleCallback((deadline) =&gt; {\n  while (deadline.timeRemaining() &gt; 0 &amp;&amp; hasMoreWork()) {\n    doWork(); // 每次处理一小部分任务\n  }\n});\n```\n\n- **使用 Web Worker**：将复杂计算、数据处理等耗时操作移至 Web Worker 中执行，避免阻塞主线程（Web Worker 无法操作 DOM，需通过消息传递数据）。\n\n例如：创建 Worker 处理计算：\n\n```js\n// 主线程\nconst worker = new Worker(&#39;worker.js&#39;);\n\nworker.postMessage(data); // 发送数据\nworker.onmessage = （event) =&gt; {\n  console.log(&#39;处理结果&#39;, event.data);\n}\n\n// worker.js\nself.onmessage = (event) =&gt; {\n  const result = heavyCalculation(event.data); // 耗时计算\n  \n  self.postMessage(result); // 发送结果\n}\n```\n\n## 2. 优化代码执行效率\n\n- **减少不必要的计算**：避免重复计算（如将计算结果缓存）、简化复杂逻辑（如用哈希表 `Map/Object` 替代嵌套循环查找，将 O(n&lt;sup&gt;2&lt;/sup&gt;) 复杂度优化为 O(n)）。\n\n例如，缓存 DOM 查询结果：\n\n```js\n// 优化前：每次都查询 DOM\nfor (let i = 0; i &lt; 100; i++) {\n  document.getElementById(&#39;list&#39;).appendChild(item);\n}\n\n// 优化后：缓存 DOM 节点\nconst list = document.getElementById(&#39;list&#39;);\n\nfor (let i = 0; i &lt; 100; i++) {\n  list.appendChild(item);\n}\n```\n\n- **避免全局变量**：全局变量会挂载在 `widow` 上，查找链长且容易引发命名冲突，尽量使用局部变量（访问速度更快）。\n- **优化循环与条件判断**：减少循环嵌套，将高频执行的条件判断放在循环外，使用 `break/continue` 提前退出无效循环。\n\n## 3. 优化 DOM 操作\n\n- **批量操作 DOM**：频繁修改 DOM 会触发多次回流/重绘，可先将 DOM 从文档流中移除（如 `display: none`），批量修改后再插入，或使用 `DocumentFragment` 临时存储节点。\n\n例如，用 `DocumentFragment` 批量添加节点：\n\n```js\nconst fragment = document.createDocumentFragment();\n\nfor (let i = 0; i &lt; 100; i++) {\n  const li = document.createElement(&#39;li&#39;);\n  \n  fragment.appendChild(li); // 先添加到文档片段\n}\n\ndocument.getElementById(&#39;list&#39;).appendChild(fragment);\n```\n\n- **避免强制同步布局**：读取 DOM 样式（如 `offsetHeight`）后立即修改样式，会触发浏览器强制同步布局（先计算布局再修改，增加开销），应批量读取后再批量修改。\n\n例如，优化布局操作顺序：\n\n```js\n// 优化前：强制同步布局\nelements.forEach((element) =&gt; {\n  element.style.width = &#39;100px&#39;; // 修改样式\n  \n  const height = element.offsetHeight; // 立即读取，触发强制布局\n});\n\n// 优化后，先读再改\nconst heights = elements.map(element =&gt; element.offsetHeight); // 批量读取\n\nelements.forEach((element, i) =&gt; {\n  element.style.width = &#39;100px&#39;;\n  element.style.height = heights[i] + &#39;px&#39;; // 使用缓存值\n});\n```\n\n## 4. 减少内存泄漏\n\n- **及时清理引用**：避免意外保留 DOM 节点引用（如将 DOM 节点存在数组中未清空）、定时器/事件监听器未移除（如 `setInterval` 未用`clearInterval`清除）。\n\n例如，组件卸载时移除事件监听：\n\n```js\n// React 组件中\nuseEffect(() =&gt; {\n  const handleScroll = () =&gt; { ... };\n  \n  window.addEventListener(&#39;scroll&#39;, handleScroll);\n  \n  return () =&gt; {\n    window.removeEventListener(&#39;scroll&#39;, handleScroll); // 卸载时清理\n  };\n}, []);\n```\n\n- **避免闭包导致的内存驻留**：合理使用闭包，避免长期持有大对象引用（如在循环中创建闭包存储大量数据）。\n\n## 5. 其他优化\n\n- **使用高效 API**：优先使用原生 API（如 `Array.prototype.map/filter` 比手动循环更高效）、避免使用 `eval`（执行慢且不安全）。\n- **代码压缩与 Tree Sharking**：通过 Webpack、Tarser 等工具压缩代码（移除空格、重命名变量），Tree Sharking 剔除未使用的代码，减少 JS 文件体积，加快解析和执行速度。\n\n通过以上方法，可显著提升 JavaScript 的执行性能，减少页面卡顿，提升用户交互体验，尤其在大型应用和复杂交互场景中效果显著。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/如何优化 JavaScript 的执行性能.mdx&quot;],&quot;digest&quot;:[0,&quot;4b58ff48ebd6b3cc&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;如何优化-javascript-的执行性能&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景&quot;],&quot;category&quot;:[0,&quot;性能优化&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T06:31:58.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 懒加载（Lazy Loading）\n\n懒加载是一种 \&quot;按需加载\&quot; 的策略，指资源（如图片、组件、数据）在初始化时不加载，仅当用户需要访问（如滚动到可视区域）时才加载，目的是减少首屏加载时间和资源消耗。\n\n### 实现方式\n\n1. **图片懒加载**：\n\n- 初始化时，图片的 `src` 属性设为占位符（或不设置），将真实地址存放在 `data-src` （或 `data-lazy`）属性中。\n- 通过监听 `scroll`、`resize` 事件或使用 `IntersectionObserver` API，判断图片是否进入可视区域。\n- 当图片进入可视区域时，将 `data-src` 的指赋给 `src`，触发图片加载。\n\n```html\n&lt;img\n  class=\&quot;lazy\&quot;\n  src=\&quot;placeholder.jpg\&quot;\n  data-src=\&quot;real.jpg\&quot;\n  alt=\&quot;Lazy Loaded Image\&quot;\n/&gt;\n\n&lt;script&gt;\n  const observer = new IntersectionObserver((entries) =&gt; {\n    entries.forEach((entry) =&gt; {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n\n        img.src = img.dataset.src;\n        // 加载后停止观察\n        observer.unobserve(img);\n      }\n    });\n  });\n\n  document.querySelectorAll(\&quot;.lazy\&quot;).forEach((img) =&gt; observer.observe(img));\n&lt;/script&gt;\n```\n\n2. **组件/路由懒加载**：\n\n- 在 SPA（单页应用）中，通过 Webpack 的 `import()` 语法实现路由组件按需加载。\n- 示例（React）：const Home = React.lazy(() =&gt; import(&#39;./Home&#39;));\n- 示例（Vue）：const Home = () =&gt; import(&#39;./Home.vue&#39;);\n\n### 适用场景\n\n- 长列表图片（如电商商品列表、社交媒体 feed 流）。\n- 内容较多的页面（如新闻详情页中的非首屏图片）。\n- 路由组件较多的 SPA，避免首屏加载所有组件导致的性能问题。\n\n## 预加载（Preloading）\n\n预加载是一种“提前加载”策略，指在浏览器空闲时或提前加载用户可能即将需要的资源（如后续页面的图片、关键 JS/CSS），当用户访问时可直接从缓存中获取，提升响应速度。\n\n### 实现方式\n\n- `&lt;link rel=\&quot;preload\&quot;&gt;`：\n  - 用于提前加载关键资源（如字体、核心 JS/CSS），浏览器会优先加载这些资源，不阻塞页面渲染。\n  - 示例：`&lt;link rel=\&quot;preload\&quot; href=\&quot;critical.css\&quot; as=\&quot;style&gt;`（`as`指定资源类型，确保正确加载）。\n- `&lt;link rel=\&quot;prefetch\&quot;&gt;`：\n  - 用于加载未来可能需要的资源（如下一页数据、非首屏组件），浏览器会在空闲时加载，优先级较低。\n  - 示例：`&lt;link rel=\&quot;prefetch\&quot; href=\&quot;next-page.js\&quot;&gt;`。\n- **JS 动态预加载**：\n  - 通过 `new Image()` 预加载图片，或 `import()` 预加载 JS 模块。\n  - 示例：`const img = new Image(); img.src = &#39;future-image.jpg&#39;;`。\n\n### 适用场景\n\n- 首屏关键资源（如核心 CSS、字体文件），确保快速渲染。\n- 用户大概率会访问的后续内容（如分页列表的下一页数据、导航菜单对应的页面资源）。\n- 交互触发的资源（如点击按钮后弹出的弹窗组件）。\n\n## 懒加载与预加载的区别\n\n| 维度       | 懒加载                     | 预加载                            |\n| ---------- | -------------------------- | --------------------------------- |\n| 加载时机   | 资源进入可视区域/需要时    | 浏览器空闲时/提前加载             |\n| 目的       | 减少首屏加载时间，节省带宽 | 提升后续操作的响应速度            |\n| 资源优先级 | 低（按需加载）             | 高（`preload`）或低（`prefetch`） |\n| 适用资源   | 非首屏、非关键资源         | 即将需要的关键/可能需要的资源     |\n\n## 注意事项\n\n- 懒加载避免过度使用，否则可能导致用户滚动时资源加载延迟、影响体验（可配合占位符优化）。\n- 预加载需合理选择资源，避免加载过多不必要的资源导致带宽浪费和性能损耗（如 `prefetch` 过多会占用空闲资源）。\n\n两者结合使用可最大化优化用户体验：懒加载减少首屏负担，预加载提升后续交互速度，是前端性能优化的重要手段。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;cc91412e3c899160&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对懒加载和预加载的理解它们的实现方式和适用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略&quot;],&quot;category&quot;:[0,&quot;性能优化&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T05:11:58.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;浏览器缓存是指浏览器将已请求过的资源存储在本地，当再次请求相同资源时，直接从本地获取以减少网络请求，提升加速度。缓存机制主要分为**强缓存**和**协商缓存**，两者配合工作。\n\n## 强缓存\n\n强缓存是指浏览器直接根据本地缓存判断资源是否过期，若未过期则直接使用本地缓存，不向服务器发送请求。\n\n- **判断依据**：基于 HTTP 响应头中的 `Expires` 或 `Cache-Control` 字段。\n  - `Expires`（HTTP/1.0）: 是一个绝对相同（如 `Expires: Wed, 21 Oct 2026 07:28:00 GMT`），表示资源过期时间。若当前时间早于 `Expires`，则使用缓存。\n    - 缺点：依赖本地时间，若本地时间被修改，可能导致缓存失效或过期资源被使用。\n  - `Cache-Control`（HTTP/1.1，优先级高于 `Expires`）：通过相对时间控制缓存，常用值：\n    - `max-age=3600`：资源有效期为 3600 秒（1 小时），从请求成功时间开始计算。\n    - `public`：允许浏览器和中间代理（如 CDN）缓存该资源。\n    - `private`：仅允许浏览器缓存（默认值），中间代理不可缓存。\n    - `no-cache`：不使用强缓存，需进入协商缓存。\n    - `no-store`：完全不缓存资源，每次都需请求服务器。\n\n## 协商缓存\n\n当强缓存失效（资源过期）时，浏览器会想服务器发送请求，由服务器判断资源是否更新：若未更新，返回 304 状态码，浏览器使用本地缓存；若已更新，返回 200 状态码和新资源。\n\n- **判断依据**：基于请求头和响应头的 `Last-Modified/If-Modified-Since` 或 `ETag/If-None-Match` 字段。\n  - `Last-Modified/If-Modified-Since`：\n    - 服务器响应时通过 `Last-Modified` 返回资源最后修改（如 `Last-Modified: Wed, 21 Oct 2026 07:28:00 GMT`）。\n    - 浏览器再次请求时，通过 `If-Modified-Since` 携带该时间，服务器对比：若资源未修改，返回 304 状态码；若已修改，返回新资源和 200 状态码。\n      - 缺点：无法识别资源的细微修改（如内容不变但修改时间更新），精度为秒级。\n  - `ETag/If-None-Match`（优先级高于 `Last-Modified`）：\n    - 服务器响应时通过 `ETag` 返回资源的唯一标识（如 `ETag: \&quot;5f8d02a1-1234\&quot;`，由资源内容哈希生成）。\n    - 浏览器再次请求时，通过 `If-None-Match` 携带该标识，服务器对比：若标识一致（资源未变），返回 304 状态码；若已修改，返回新资源和 200 状态码。\n      - 优点：能更精准判断是否修改，适用于动态内容。\n  \n## 缓存策略设置\n\n- **静态资源（如 JS、CSS、图片）**：\n  - 采用 “强缓存为主，协商缓存为辅”。\n  - 设置较长的 `Cache-Control: max-age=31536000`（1年），同时对资源进行哈希命名（如 app.8f2d7.js）。当资源更新时，哈希值变化，浏览器会视为新资源并重新请求，避免缓存失效问题。\n- **动态资源（如 API 接口数据）**：\n  - 不使用强缓存（设置 `Cache-Control: no-cache`），依赖协商缓存。\n  - 服务器通过 `ETag` 或 `Last-Modified` 判断数据是否更新，减少重复数据传输。\n- **特殊资源（如 HTML）**：\n  - 通常设置 `Cache-Control: no-cache`（或短时间 `max-age`），确保用户每次访问都能获取最新页面结构，再通过协商缓存判断是否需要更新。\n\n## 缓存流程总结\n\n1. **浏览器请求资源时，先检查强缓存**：若未过期，直接使用本地缓存（状态码 200 OK (form cache)）。\n2. **若强缓存过期，进入协商缓存**：向服务器发送请求，服务器判断资源是否更新。\n3. **若资源未更新，返回 304，浏览器使用本地缓存**：若已更新，返回 200 和新资源，浏览器更新本地缓存。\n\n合理的缓存策略可大幅减少服务器压力，提升页面加载速度，是前端性能优化的核心手段之一。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略.mdx&quot;],&quot;digest&quot;:[0,&quot;503e146659a7f060&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;解释浏览器的缓存机制包括强缓存和协商缓存以及如何设置缓存策略&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;如何减少 HTTP 请求？有哪些具体的方法.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;如何减少 HTTP 请求？有哪些具体的方法&quot;],&quot;category&quot;:[0,&quot;性能优化&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T04:32:39.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;减少 HTTP 请求是前端性能优化的核心手段之一，因为每个 HTTP 请求都存在建立连接、传输数据等开销，请求数量越多，页面加载速度越慢。\n\n## 具体实施方法\n\n### 资源合并\n\n- **JS/CSS 合并**：将多个小型 JS 文件合并为一个（如用 Webpack 的 `splitChunks` 合并公共库），多个 CSS 文件合并为一个，减少请求次数。\n- **图片合并（CSS Sprite）**：将多个小图标（如按钮、图标）合并成一张雪碧图，通过 CSS 的 `background-position` 定位显示不同图标，将多次图片请求缩减为一次。\n\n### 资源压缩与格式优化\n\n- **使用高效图片格式**：采用 WebP、AVIF 等现代图片格式，在相同画质下体积比 JPEG/PNG 小 **30% 以上**，减少单张图片的请求体积。\n- **字体图标替代图片**：用 Font Awesome 等字体图标库替代小图标图片，一个字体文件可包含多个图标，且支持缩放不失真，减少图片请求。\n\n### 懒加载与按需加载\n\n- **图片懒加载**：初始至加载可视区域内的图片，当用户滚动到相应区域时再加载其他图片（通过 **data-src** 存储真实地址，滚动时替换为 _src_）。\n- **路由懒加载**：在 SPA（单页应用）中，通过 Webpack 的 `import()` 语法实现路由组件按需加载，仅当用户访问对应路由时才加载该组件的 JS/CSS，避免首屏加载所有资源。\n\n### 利用缓存减少重复请求\n\n- **通过 HTTP 缓存**：强缓存如 `Cache-Control: max-age=31536000`，协商缓存如 `ETag/Last-Modified`。让浏览器缓存静态资源，用户二次访问时直接从本地读取，无需重新向服务器请求。\n\n### 使用 CDN 与资源复用\n\n- **CDN 的边缘节点会缓存静态资源**，用户请求时优先从 CDN 获取，减少对源服务器的请求；同时，CDN 的资源复用机制（如同一域名下的资源共享连接）可降低连接建立开销。\n\n### 内联小型资源\n\n- **将小型 JS/CSS 代码通过 `&lt;script&gt;/&lt;style&gt;` 标签内联到 HTML 中**，避免额外的 HTTP 请求（适用于体积极小的资源，过大内联惠增加 HTML 体积）。\n\n通过上述方法，可显著减少页面的 HTTP 请求总量，降低网络传输成本，提升页面加载速度。实际优化中需结合资源大小、使用频率等因素灵活选择，避免过度合并导致单次请求体积过大。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/如何减少 HTTP 请求？有哪些具体的方法.mdx&quot;],&quot;digest&quot;:[0,&quot;32b7ad3a2f3d648e&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;如何减少-http-请求有哪些具体的方法&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化&quot;],&quot;category&quot;:[0,&quot;性能优化&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-14T04:03:28.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 性能优化的重要性\n\n- **提升用户体验**：页面加载速度快、交互流畅，能减少用户等待时间，降低跳出率，提升用户满意度和留存率。\n- **增强业务转化**：对于电商、支付等场景，性能优化可直接影响用户决策。（例如加载速度每提升1秒，转化率可能显著提升）\n- **改善搜索引擎排名**：Google等搜索引擎将页面加载速度作为排名因素之一，性能好的网站更容易获得更高曝光。\n- **降低服务器成本**：通过缓存、资源压缩等优化，可减少服务器请求量和带宽消耗，降低运维成本。\n\n## 前端性能优化的主要方向\n\n1. **资源加载优化**\n  - **压缩与合并**：对JS、CSS、图片等资源进行压缩（如JS/CSS用Terser、CSSNano，图片用 WebP 格式），合并小文件减少 HTTP 请求。\n  - **懒加载与预加载**：非首屏图片、组件采用懒加载（按需加载）；提前加载可能用到的关键资源（如预加载字体、下一页数据）。\n  - **CDN 加速**：将静态资源部署到 CDN，利用其分布式节点让用户从最近节点获取资源，降低延迟。\n  - **合理设置缓存**：通过 HTTP 缓存（强缓存、协商缓存）减少重复资源请求，提升二次加载速度。\n2. **代码优化**\n  - **减少 DOM 操作**：避免频繁操作 DOM（如批量修改用文档片段 DocumentFragment），减少回流/重绘。\n  - **优化 JavaScript 执行**：避免长任务阻塞主线程（用 Web Worker 处理复杂计算），减少不必要的全局变量和闭包导致的内存泄漏。\n  - **CSS 优化**：避免复杂选择器（如嵌套过深），减少 `@import`（会阻塞渲染），使用 CSS Sprite 合并小图标。\n3. **首屏加载优化**\n  - **关键资源优先加载**：通过 `&lt;link rel=\&quot;preload\&quot;&gt;` 指定关键 CSS/JS 优先加载，延迟加载非关键资源。\n  - **代码分割**：用 Webpack 等工具拆分代码，首屏只加载必要代码（如路由懒加载），其余按需加载。\n  - **服务端渲染（SSR）/静态站点生成（SSG）**：对于首屏内容复杂的页面，通过 SSR/SSG 在服务端生成 HTML，减少客户端渲染时间。\n4. **网络优化**\n  - **使用 HTTP 2/3**：利用多路复用、头部压缩等特性提升传输效率，减少连接建立开销。\n  - **减少请求体积**：移除代码中未使用的部分（Tree Sharking），接口返回数据采用压缩格式（如 gzip、br）。\n5. **其他优化**\n  - **优化第三方脚本**：延迟加载非必要的第三方脚本（如广告、统计工具），避免其阻塞页面渲染。\n  - **监控与分析**：通过 Lighthouse、Web Vitals 等工具监控性能指标，针对性优化瓶颈问题。\n  \n性能优化需结合具体场景，遵循“先量化后优化”原则，优先解决对用户体验影响最大的问题（如首屏加载时间、交互响应速度）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化.mdx&quot;],&quot;digest&quot;:[0,&quot;06d30597b5fd33f4&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;前端性能优化的重要性是什么从哪些方面可以进行前端性能优化&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景&quot;],&quot;category&quot;:[0,&quot;前端框架&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T20:00:53.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;Vue 中组件通信方式多样，需根据组件关系（父子、兄弟、跨级等）选择合适的方式。\n\n## 组件通信方式\n\n### props/emit（父子组件通信）\n\n- **用法**：父组件通过 `props` 向子组件传递数据；子组件通过 `$emit` 触发事件，父组件监听事件获取子组件数据。\n- **适用场景**：最基础的父子组件通信，适用于数据流向清晰的简单场景。\n\n```vue\n&lt;!-- 父组件 --&gt;\n&lt;Child :msg=\&quot;parentMsg\&quot; @childEvent=\&quot;handleEvent\&quot; /&gt;\n\n&lt;!-- 子组件 --&gt;\n&lt;script&gt;\nexport default {\n  props: [&#39;msg&#39;],\n  methods: {\n    sendData() {\n      this.$emit(&#39;childEvent&#39;, &#39;子组件数据&#39;)\n    }\n  }\n}\n&lt;/script&gt;\n```\n\n### \\$parent/$children（父子组件通信）\n\n- **用法**：子组件通过 `this.$parent` 访问父组件实例；父组件通过 `this.$children` 访问子组件实例（返回子组件数组）。\n- **适用场景**：临时性、简单的父子组件交互，但不推荐频繁使用，会增加组件耦合度。\n\n### $refs（父子组件通信）\n\n- **用法**：父组件给子组件添加 `ref` 属性（如 `&lt;Child ref=\&quot;childRef\&quot; /&gt;`），通过 `this.$refs.childRef` 直接访问子组件实例（包括数据和方法）。\n- **适用场景**：需要主动调用子组件方法或获取子组件数据的场景（如表单重置），需在组件挂载后使用。\n\n### EventBus（兄弟/跨级组件通信）\n\n- **用法**：创建一个全局事件总线（如`const bus = new Vue()`），组件通过 `bus.$emit` 触发事件传递数据。\n- **适用场景**：中小型项目中无直接关系的组件通信，大型项目易导致事件混乱，需谨慎使用。\n\n```js\n// main.js\nVue.prototype.$bus = new Vue();\n// 组件 A（发送数据）\nthis.$bus.$emit(&#39;eventName&#39;, data);\n// 组件 B（接收数据）\nthis.$bus.$on(&#39;eventName&#39;, (data) =&gt; { ... });\n```\n\n### Vuex/Pinia（全局状态管理器）\n\n- **用法**：通过集中式存储管理应用的所有组件状态，组件通过 `dispatch/commit` 修改状态，通过 `mapState` 等获取状态。\n- **适用场景**：大型项目中多组件共享数据（如用户信息、购物车等），或跨多级组件通信，能清晰追踪状态变化。\n\n### Provide/Inject（跨级组件通信）\n\n- **用法**：祖先组件通过 `provide` 提供数据，后代组件通过 `inject` 注入数据，无视组件层级。\n- **适用场景**：深层嵌套组件通信（如组件库开发），但数据是非响应式的（需配合`ref/reactive`实现响应式）。\n\n```vue\n&lt;!-- 祖先组件 --&gt;\n&lt;script&gt;\nexport default {\n  provide() {\n    return { key: &#39;共享数据&#39; }\n  }\n}\n&lt;/script&gt;\n\n&lt;!-- 后代组件 --&gt;\n&lt;script&gt;\nexport default {\n  inject: [&#39;key&#39;],\n  mounted() {\n    console.log(this.key);\n  }\n}\n&lt;/script&gt;\n```\n\n### 路由参数（跳转组件通信）\n\n- **用法**：通过路由跳转时在 URL 中携带参数（`params` 或 `query`），目标组件通过 `$route.params/$route.query` 获取。\n- **适用场景**：页面级组件通过路由跳转传递数据。\n\n## 选择通信方式的核心原则\n\n优先使用 `props/emit`（父子）、`Vuex/Pinia`（全局），避免过度使用 `$parent/EventBus` 导致代码维护困难。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;cd617850203af26e&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;在-vue-中如何实现组件之间的通信请列举多种方式并说明其适用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些&quot;],&quot;category&quot;:[0,&quot;前端框架&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T19:20:47.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;React Hooks 是 React 16.8 引入的特性，允许开发者在函数组件中使用状态（state）和其他 React 特性（如生命周期、上下文等），无需编写类组件。它的核心是将组件逻辑拆分为可复用的函数，让代码更简洁、易维护。\n\n## 解决的问题\n\n1. **类组件的复杂性**：类组件中存在 `this` 指向混乱、生命周期钩子函数中逻辑混杂（如同一逻辑分散在 `componentDidMount` 和 `componentDidUpdate` 中）等问题，Hooks 通过函数式编程简化了组件写法。\n2. **代码复用难题**：类组件中复用逻辑需依赖高阶组件（HOC）或渲染属性（Render Props），容易导致组件嵌套过深（“嵌套地狱”），Hooks 可直接将逻辑封装为自定义 Hook，实现更直观的复用。\n3. **状态与逻辑耦合**：类组件中相关的状态和操作逻辑常被拆分在不同生命周期中，Hooks 能将关联逻辑聚合在同一函数中，增强代码可读性。\n\n## 常用的 Hooks\n\n- **useState**：用于在函数中定义状态。\n- **useEffect**：处理组件的副作用（如数据请求、订阅、DOM 操作等），替代类组件的生命周期钩子。\n  - 第二个参数为空数组 `[]` 时，仅在组件挂载和卸载时执行（类似于 `componentDidMount` 和 `componentWillUnmount`）。\n  - 传入依赖数组 `[dep]`，当 `dep` 发生改变时执行（类似于 `componentDidUpdate`）。\n- **useContext**：用于访问 React 的上下文（Context），避免通过 Props 层层传递数据。\n- **useReducer**：用于管理复杂状态逻辑，类似 Redux 的 reducer，适合状态之间存在依赖或需要复杂更新的场景。\n- **useCallback**：缓存函数，避免因组件重新渲染导致子组件不必要的重新渲染（配合 `React.memo` 使用）。\n- **useMemo**：缓存计算结果，避免每次渲染时重复执行昂贵的计算。\n- **useRef**：用于获取 DOM 元素或存储跨渲染周期的可变值（其值改变不会触发组件重渲染）。\n\n此外，开发者还可以基于内置 Hooks 封装自定义 Hook（比如 useRequest 处理请求逻辑，useLocalStorage 操作本地存储）,进一步提升代码复用性。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些.mdx&quot;],&quot;digest&quot;:[0,&quot;df992168ff5cd7d6&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对-react-hooks-的理解它解决了什么问题常用的-hooks-有哪些&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Vue 的响应式原理是什么？请详细说明.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;Vue 的响应式原理是什么？请详细说明&quot;],&quot;category&quot;:[0,&quot;前端框架&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T18:09:15.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;Vue 的响应式原理是指 Vue 在数据发生变化后，会自动更新视图。核心是通过数据劫持 + 依赖收集实现的。在 Vue 2 和 Vue 3 中，实现方式存在一定差异。\n\n## Vue 2 响应式\n\n- **数据劫持**：通过 `Object.defineProperty` 方法劫持对象属性的 `getter` 和 `setter`，当数据被访问时，会触发 `getter` 方法；当数据被修改时，会触发 `setter` 方法。\n- **依赖收集**：在 `getter` 方法中收集依赖（即使用该数据的组件或视图），将依赖存储在 `Dep` （依赖管理器）中。\n- **视图更新**：当数据发生变化时，`setter` 方法会被触发，`Dep` 会通知所有收集到的依赖进行更新，从而触发视图更新。\n\n不过 Vue 2 的响应式原理存在一些缺陷：无法监听对象属性的添加/删除，无法监听数组通过索引修改的元素或修改数组的长度，需要通过 `Vue.set` 或 `this.$set` 方法手动触发响应式。\n\n## Vue 3 响应式\n\n- **数据劫持**：通过 `Proxy` 代理整个数据对象（而非像 Vue 2 那样劫持单个属性），`Proxy` 可以拦截对象属性的读取、删除和修改等多种操作，解决了 Vue 2 的局限性。\n- **依赖收集**：在 `Proxy` 的 `get` 等拦截器中收集依赖，依赖仍由 `Dep` 管理，但 Vue 3 的 `effect` 函数实现了更灵活的依赖追踪。\n- **视图更新**：当数据变化时，`Proxy` 的 `set` 等拦截器被触发，`Dep` 通知依赖执行更新函数，完成视图更新。\n\nVue 3 的响应式原理不仅支持对象和数组的所有操作，还能监听 `Set` 和 `Map` 等数据结构，响应式能力更加全面。\n\n## 核心流程总结\n\n1. **初始化**：组件初始化时，Vue 会对 `data` 中的数据进行响应式处理。\n2. **依赖收集**：当模板渲染或计算属性使用数据时，触发 `getter` 或拦截器，将当前依赖加入到 `Dep` 。\n3. **数据更新**：数据被修改时，触发 `setter` 或拦截器，`Dep` 通知依赖执行更新函数，完成视图更新。\n\n这种机制让开发者无需手动操作 DOM，只需关注数据变化，极大提升了开发效率。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/Vue 的响应式原理是什么？请详细说明.mdx&quot;],&quot;digest&quot;:[0,&quot;f5a80fc5bcd43b38&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;vue-的响应式原理是什么请详细说明&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;解释 React 中的虚拟 DOM，它的工作原理及优势.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;解释 React 中的虚拟 DOM，它的工作原理及优势&quot;],&quot;category&quot;:[0,&quot;前端框架&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T17:36:22.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;虚拟 DOM（Virtual DOM）是 React 中对真实 DOM 的一种轻量级内存抽象表示，本质上是一个 JavaScript 对象，它包含了真实 DOM 的结构和属性信息（如标签名、属性、子元素等）。\n\n## 工作原理\n\n1. **初始化渲染**：当组件首次渲染时，React 会根据 JSX 代码生成对应的虚拟 DOM 树。\n2. **生成真实 DOM**：React 将虚拟 DOM 树转换为真实 DOM，并插入到页面中。\n3. **状态更新**：当组件状态（state）或属性（props）发生变化时，React 会重新生成一个新的虚拟 DOM 树。\n4. **Diff 算法对比**：通过 Diff 算法（差异对比算法）对比新旧两棵虚拟 DOM 树，找出两者之间的差异（如节点新增、删除、属性变化等）。\n5. **更新真实 DOM**：React 只将找出的差异部分转换为真实 DOM 操作，批量更新到页面中，而非重新渲染整个 DOM 树。\n\n## 优势\n\n- **提升性能**：真实 DOM 操作代价是昂贵的（会触发重排、重绘），虚拟 DOM 通过 Diff 算法精准找出差异，减少了不必要的 DOM 操作，尤其在复杂页面频繁更新时，性能提升明显。\n- **跨平台能力**：虚拟 DOM 是平台无关的抽象层，React 可基于虚拟 DOM 将组件渲染到不同平台（如Web端的真实DOM、移动端的原生组件等），实现一次编译多端运行。\n- **简化开发流程**：开发者无需手动操作 DOM，只需关注组件状态变化，React 会自动处理 DOM 更新，降低了开发复杂度和出错概率。\n- **支持批量更新**：React 会将多个状态更新合并为一次虚拟 DOM 对比和真实 DOM 更新，减少了页面重绘次数，进一步优化性能。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/解释 React 中的虚拟 DOM，它的工作原理及优势.mdx&quot;],&quot;digest&quot;:[0,&quot;0abdb3d2fcdfb682&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;解释-react-中的虚拟-dom它的工作原理及优势&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;请对比 React、Vue 和 Angular 三大框架的特点和适用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;请对比 React、Vue 和 Angular 三大框架的特点和适用场景&quot;],&quot;category&quot;:[0,&quot;前端框架&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T16:54:28.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## React\n\n### 特点\n\n- **采用 JSX 语法，** 将 HTML 与 JavaScript 逻辑结合，代码结构清晰。\n- **基于组件化开发，强调单向数据流**，状态管理需结合 Redux 等工具。\n- **灵活性高，生态丰富，** 可用于Web端，移动端等多平台。\n- **学习曲线中等，需理解虚拟 DOM、生命周期（hooks时代为副作用管理）等概念。**\n\n### 适用场景\n\n大型复杂应用（如电商平台、管理系统等）、需要跨平台开发的项目，适合团队协作能力强、追求灵活性的团队。\n\n## Vue\n\n### 特点\n\n- **采用 HTML 模版语法**，更贴近传统前端开发习惯，易于上手。\n- **双向数据绑定**（Vue 2 基于 `Object.defineProperty`，Vue 3 基于 `Proxy`），简化表单处理等场景。\n- **渐进式框架**，可按需引入路由、状态管理（Vuex/Pinia）等功能，灵活性与易用性平衡。\n- **官方文档完整，社区活跃，生态体系健全（Vue Router、Vuex、Pinia等）。**\n\n### 适用场景\n\n中小型项目快速开发，初创公司产品快速迭代，对开发效率要求高的场景，也可胜任大型项目（如阿里、百度部分业务）。\n\n## Angular\n\n### 特点\n\n- **由 Google 开发，是一套完整的 MVC 框架。** 包括模板、依赖注入、路由等全套解决方案。\n- **基于 TypeScript 开发，** 强类型检查提升代码健壮性，但学习成本高。\n- **强调规范化，** 有严格的代码组织方式和开发流程，适合大型团队协作。\n- **内置功能丰富，**（如表单验证、HTTP客户端），但体积较大，初期加载速度可能受影响。\n\n### 适用场景\n\n企业级大型应用（如银行金融、政务系统等），需要严格规范和强类型支持的项目，适合有后端开发经验、注重工程化的团队。\n\n## 核心差异总结\n\n- **开发范式**：React偏函数式，Vue偏声明式，Angular偏面向对象。\n- **灵活性**：React &gt; Vue &gt; Angular。\n- **学习成本**：Angular &gt; React &gt; Vue。\n- **生态成熟度**：三者均有成熟生态体系。React 生态最广，Angular 最全面，Vue 最轻量化。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/请对比 React、Vue 和 Angular 三大框架的特点和适用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;1b98da083341e06c&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;请对比-reactvue-和-angular-三大框架的特点和适用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势&quot;],&quot;category&quot;:[0,&quot;CSS 进阶&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T15:48:24.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;CSS 预处理器是一种扩展 CSS 语法的工具，它引入了编程语言的特性（如变量、函数、嵌套、混合等），允许开发者使用更高效的可维护的方式编写 CSS 代码，最终会被编译成普通的 CSS 代码供浏览器识别。常见的预编译器有 Sass、Less、Stylus 等。\n\n## 核心特性\n\n- **变量（Variables）**：可定义重复使用的值（如颜色、尺寸等），修改变量时所有引用处自动更新，减少冗余。\n- **嵌套（Nesting）**：允许样式按 HTML 层级嵌套编写，清晰反映 DOM 结构，避免重复书写父选择器。\n- **混入（Mixins）**：封装可复用的样式片段（如兼容代码、复杂布局），通过 `@include` 调用，支持参数传递。\n- **继承（Inheritance）**：通过 `@extend` 让一个选择器继承另一个选择器的样式，减少代码重复。\n- **函数与运算（Functions &amp; Operations）**：支持数学计算（如加减、颜色计算等）和自定义函数，动态生成样式值。\n- **模块化（Modules）**：可将样式拆分到多个文件，通过 `@import` 合并，便于大型项目的代码组织。\n\n## 优势\n\n1. **提高开发效率**：变量、混入等特性减少重复代码，嵌套语法简化层级样式编写。\n2. **增强可维护性**：模块化拆分使代码结构清晰，变量和继承让样式修改更便捷，降低维护成本。\n3. **支持复杂逻辑**：通过函数、条件判断、循环等特性，实现动态样式生成（如主题切换、响应式适配）。\n4. **规范开发流程**：强制团队采用统一的变量命名、文件结构，提高代码一致性。\n5. **兼容旧环境**：可通过混入生成浏览器前缀（如 `-webkit-`、`-moz-` 等），简化兼容处理。\n\n总之，预处理器解决了原生 CSS 在大型项目中面临的冗余、维护难等问题，是现代前端工程化中不可或缺的工具。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势.mdx&quot;],&quot;digest&quot;:[0,&quot;f11194c21922b290&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对-css-预处理器如-sassless的理解它们有哪些特性和优势&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序&quot;],&quot;category&quot;:[0,&quot;CSS 进阶&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T09:10:51.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;层叠上下文（Stacking Context）是 CSS 中一个三维概念，指元素在 Z 轴（垂直于屏幕的轴线）上的渲染层级关系。拥有层叠上下文的元素会像一个“容器”，其内部元素的层叠顺序仅在该容器内生效，不会影响外部元素的层叠关系。\n\n## 层叠上下文的创建方式（常见）\n\n- 根元素（`&lt;html&gt;`）默认创建根层叠上下文。\n- 元素设置 `position: absolute` 或 `relative` 且 `z-index` 值不为 `auto`。\n- 元素设置 `position: fixed` 或 `sticky`。\n- 元素设置 `display: flex` 或 `inline-flex`，且子元素 `z-index` 值不为 `auto`（此时子元素会创建层叠上下文）。\n- 元素设置 `opacity` 值小于 1。\n- 元素设置 `transform` 值不为 `none`。\n- 元素设置 `mix-blend-mode` 值不为 `normal` 等。\n\n## 层叠顺序（同一层叠上下文中元素的 Z 轴排列规则，从后到前）\n\n- **层叠上下文的背景和边框**：位于最底层。\n- **负`z-index`值的子元素**：值越小越靠后。\n- **非定位元素（`position: static`）**：按文档流顺序排列。\n- **`z-index: auto` 或 `z-index: 0`的定位元素**。\n- **正 `z-index` 值的子元素**：值越大越靠前。\n\n## 控制元素层叠顺序的方法\n\n- **利用 `z-index` 属性**：在同一层叠上下文中，通过设置 `z-index` 的正负值调整顺序（仅对定位元素或弹性盒子子元素生效）。注意：**`z-index` 仅在当前层叠上下文中有效，不同层叠上下文的元素比较时，父级层叠上下文的层级决定了子元素的整体层级。**\n- **调整层叠上下文的创建**：通过设置 `opacity`、`transform` 等属性让元素创建新的层叠上下文，使内部元素的层级顺序独立于外部。\n- **遵循文档流和定位规则**：非定位元素默认按文档流顺序层叠，后出现的元素会覆盖先出现的元素；定位元素会覆盖非定位元素（除非被更高级的层叠元素遮挡）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序.mdx&quot;],&quot;digest&quot;:[0,&quot;5f01afcfb82ed615&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;详细解释-css-中的层叠上下文以及如何控制元素的层叠顺序&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;如何实现元素的水平居中、垂直居中以及水平垂直居中.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;如何实现元素的水平居中、垂直居中以及水平垂直居中&quot;],&quot;category&quot;:[0,&quot;CSS 进阶&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T08:41:35.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;## 水平居中\n\n- **行内元素/文本**\n  - 给父元素设置 `text-align: center`，适用于 `&lt;span&gt;`、`&lt;a&gt;`、文本等行内元素。\n- **块级元素（定宽）**\n  - 给元素设置 `margin: 0 auto`，需指定 `width`（否则元素默认占满父容器宽度，居中无效果）。\n- **块级元素（不定宽）**\n  - **Flexbox**：父元素设置 `display: flex; justify-content: center;`，子元素宽度可自适应。\n  - **Grid**：父元素设置 `display: grid; justify-content: center;`。\n- **Position**：父元素设置 `position: relative;`，子元素设置 `position: absolute; left: 50%; transform: translateX(-50%);`，无需知道子元素宽度。\n\n## 垂直居中\n\n- **行内元素/文本(单行)**\n  - 给父元素设置 `line-height` 等于父元素高度，适用于单行文本或行内元素。\n- **行内元素/文本(多行)**\n  - 父元素设置 `display: table-cell; vertical-align: middle;`，同时指定父元素高度。\n- **块级元素**\n  - **Flexbox**：父元素设置 `display: flex; aligin-items: center;`，兼容性较好且灵活。\n  - **Grid**：父元素设置 `display: grid; align-items: center;`。\n  - **Position**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 50%; left: 50%; transform: translateY(-50%)`，无需知道子元素高度。\n  - **已知父元素高度且子元素高度固定**：子元素设置 `margin-top: (父高 - 子高) / 2`。\n\n## 水平垂直居中\n\n- **Flexbox**：父元素设置 `display: flex; justify-content: center; align-items: center;`，最简单常用，支持不定宽高元素。\n- **Grid**：父元素设置 `display: grid; place-items: center;`（`place-items` 是 `align-items` 和 `justify-items` 的简写）。\n- **Position + transform**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)`，适用于不定高元素。\n- **Position + margin**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;`，需指定子元素宽高。\n- **table-cell**：父元素设置 `display: table-cell; vertical-align: middle; text-align: center;`，子元素设置 `display: inline-block;`（将会计元素转为行内块，配合父元素文本居中）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/如何实现元素的水平居中、垂直居中以及水平垂直居中.mdx&quot;],&quot;digest&quot;:[0,&quot;5fababaa89c6eeb7&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;如何实现元素的水平居中垂直居中以及水平垂直居中&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;请介绍 CSS 中的 BFC，它的触发条件和应用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;请介绍 CSS 中的 BFC，它的触发条件和应用场景&quot;],&quot;category&quot;:[0,&quot;CSS 进阶&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T08:00:40.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;BFC（Block Formatting Context, 块级格式化上下文）是 CSS 中一种特殊的渲染环境，它就像一个容器的“容器”，容器内部的元素布局不会影响到外部元素，外部元素的布局也不会干扰容器内部。\n\n## 触发条件\n\n- 根元素（`&lt;html&gt;`）\n- 浮动元素（`float` 值为 `left` 或 `right`，且不为 `none`）\n- 绝对定位元素（`position` 值为 `absolute` 或 `fixed`）\n- 行内块元素（`display: inline-block`）\n- 表格单元格（`display: table-cell`，默认属性）\n- 表格标题（`display: table-caption`，默认属性）\n- overflow 值不为 `visible` 的块元素（如 `overflow: hidden`、`auto`、`scroll`）\n- 弹性元素（`display: flex`、`inline-flex` 的直接子元素）\n- 网格元素（`display: grid` 或 `inline-grid` 的直接子元素）等\n\n## 应用场景\n\n### 解决 margin 重叠问题\n\n当两个相邻的块级元素都设置了 margin 时，可能会出现 margin 重叠（取较大值），将她们放入不同的 BFC 容器中可避免重叠。\n\n### 清除浮动\n\n父元素内部子元素浮动时，父元素可能会因没有内容支撑而高度坍塌，给父元素触发 BFC 后，父元素会包裹住浮动的子元素，从而清除浮动影响。\n\n### 阻止元素被浮动元素覆盖\n\n当一个元素浮动时，可能会覆盖旁边的非浮动元素，给非浮动元素触发 BFC，可使它不被覆盖，保持与浮动元素并列的布局。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/请介绍 CSS 中的 BFC，它的触发条件和应用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;2e75c336680a54f5&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;请介绍-css-中的-bfc它的触发条件和应用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景&quot;],&quot;category&quot;:[0,&quot;JavaScript 深入理解&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T07:46:33.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;Generator 函数是 ES6 中引入的一种特殊函数，通过 `function*` 语法定义，内部使用 `yield` 关键字暂停函数执行，配合 `next()` 方法恢复执行，能实现函数的分步执行和状态保存。\n\n## 工作原理\n\nGenerator 函数执行后不会立即运行函数体，而是返回一个迭代器对象（Iterator）。调用迭代器的 `next()` 方法时，函数开始执行，直到遇到 `yield` 关键字暂停，`yield` 后面的表达式值作为 `next()` 返回对象的 `value` 属性；再次调用 `next()`，函数从暂停处继续执行，直到下一个 `yield` 或函数结束，若函数结束则返回对象的 `done` 属性为 true。\n\n## 应用场景\n\n### 异步操作控制\n\n可将异步操作拆分为多个步骤，通过 `yield` 依次执行，使异步代码逻辑更清晰，累死 `async/await` 的早期替代方案。\n\n```js\nfunction* asyncTask() {\n  const result1 = yield fetch(&#39;url1&#39;);\n  const result2 = yield fetch(&#39;url2&#39;);\n  return result2;\n}\n```\n\n### 迭代器生成\n\n利用 Generator 函数的迭代特性，可便捷地创建自定义迭代器，用于遍历复杂数据结构。\n\n```js\nfunction* iterateData(data) {\n  for (let item of data) {\n    yield item;\n  }\n}\nconst iterator = iterateData([1, 2, 3]);\nconsole.log(iterator.next().value); // 1\n```\n\n### 状态机\n\n由于 Generator 函数能保存执行状态，适合实现具有多种状态切换的逻辑，如有限状态机。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景.mdx&quot;],&quot;digest&quot;:[0,&quot;f65fc368636a1bcd&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是-generator-函数它的工作原理是什么在实际开发中有哪些应用场景&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别&quot;],&quot;category&quot;:[0,&quot;JavaScript 深入理解&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T06:57:23.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;ES6 中的箭头函数是一种简洁的函数声明方式，语法上使用 `=&gt;` 来定义函数，其基本语法为 `(args) =&gt; {/* function body */}`，当参数只有一个时可以省略括号，函数体只有一条语句时可省略大括号和 `return` 关键字。\n\n## 箭头函数与普通函数的区别\n\n### 1. this指向\n\n这是最核心的区别。普通函数的 `this` 指向调用它的对象，在不同调用场景下（比如全局调用、对象方法调用、构造函数调用等） `this` 指向会动态变化；箭头函数没有自己的 `this`，它的 `this` 继承自外层作用域的 `this`，且在函数定义时就已确定，不会随调用方式改变。\n\n```js\nconst obj = {\n  name: &#39;箭头函数&#39;,\n  normalFunc: function() {\n    // 普通函数 this 指向调用者 obj，输出 ‘箭头函数’\n    console.log(this.name);\n  },\n  arrowFunc: () =&gt; {\n    // 箭头函数 this 继承自外层，若外层是全局则为 undefined\n    console.log(this.name);\n  }\n}\n\nobj.normalFunc();\nobj.arrowFunc();\n```\n\n### 2. 构造函数\n\n普通函数可以作为构造函数使用 `new` 关键字创建实例，箭头函数不能作为构造函数，使用 `new` 调用会报错，因为箭头函数没有 `prototype` 属性。\n\n```js\nfunction NormalFunc() {}\nconst normalObj = new NormalFunc(); // 正常创建实例\n\nconst ArrowFunc = () =&gt; {};\nconst arrowObj = new ArrowFunc(); // 报错：ArrowFunc is not a constructor\n```\n\n### 3. arguments 对象\n\n普通函数内部有 `arguments` 对象，用于获取函数接收的所有参数；箭头函数没有 `arguments` 对象，若需获取参数可使用剩余参数 `...args`。\n\n```js\nfunction normalFunc() {\n  console.log(arguments); // 输出传入的参数列表\n}\nnormalFunc(1, 2, 3);\n\nconst arrowFunc = (...args) =&gt; {\n  console.log(args); // 使用剩余参数获取参数，输出[1, 2, 3]\n  // console.log(arguments); // 报错：arguments is not defined\n};\narrowFunc(1, 2, 3);\n```\n\n### 4. 原型\n\n普通函数有 `prototype` 原型对象，箭头函数没有 `prototype`。\n\n```js\nfunction normalFunc() {}\nconsole.log(normalFunc.prototype); // 存在原型对象\n\nconst arrowFunc = () =&gt; {};\nconsole.log(arrowFunc.prototype); // undefined\n```\n\n### 5. yield 关键字\n\n箭头函数不能用作 Generator 函数，不能使用 `yield` 关键字，普通函数可以通过 `function*` 定义 Generator 函数并使用 `yield`。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别.mdx&quot;],&quot;digest&quot;:[0,&quot;feee0dc0efdf0e3b&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;谈谈你对-es6-中箭头函数的理解它与普通函数有哪些区别&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作&quot;],&quot;category&quot;:[0,&quot;JavaScript 深入理解&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-13T06:13:29.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;Promise 有三种状态，分别是 **pending（等待态）**、**fulfilled（成功态）**、**rejected（失败态）**。\n\n- **pending（等待态）**：这是 Promise 的初始状态，当 Promise 对象被创建时，处于该状态，表示异步操作正在进行中，尚未有结果。\n- **fulfilled（成功态）**：当异步操作成功完成时，Promise 会从 pending 状态转换为 fulfilled 状态，此时会携带异步操作的成功结果。\n- **rejected（失败态）**：当异步操作失败时，Promise 会从 pending 状态转换为 rejected 状态，此时会携带异步操作的错误信息。\n\n三种状态的转换关系是**不可逆**的：\n\n- 从 pending 状态可以转换为 fulfilled 状态，一旦转换为 fulfilled 状态，就不能再变回 pending 状态，也不能转换为 rejected 状态。\n- 从 pending 状态可以转换为 rejected 状态，一旦转换为 rejected 状态，同样不能再变回 pending 状态，也不能转换为 fulfilled 状态。\n\n## 使用 Promise 处理异步操作\n\n### 创建 Promise 对象\n\n通过 `new Promise((resolve) =&gt; {...})` 创建，在 executor 函数中执行异步操作。当异步操作成功时，调用 `resolve(value)`将状态从 pending 转换为 fulfilled，并将成功结果 value 传递出去；当异步操作失败时，调用 `reject(error)` 将状态从 pending 转换为 rejected，并将错误信息 error 传递出去。\n\n```js\nconst promise = new Promise((resolve, reject) =&gt; {\n  // 模拟异步操作，如网络请求\n  setTimeout(() =&gt; {\n    const success = Math.random() &gt; 0.5;\n    \n    if (success) {\n      resolve(&#39;操作成功，这是结果&#39;);\n    } else {\n      reject(&#39;操作失败，这是错误信息&#39;);\n    }\n  }, 1000);\n});\n```\n\n### 处理结果\n\n使用 `then()` 方法处理 fulfilled 状态的结果，`catch()` 方法处理 rejected 状态的错误，也可以在 `then()` 方法的第二个参数中处理错误。\n\n```js\npromise.then((result) =&gt; {\n  console.log(&#39;成功处理结果：&#39;, result);\n  \n  // 可以返回新的 Promise 进行链式操作\n  return result + &#39;，已处理&#39;;\n}).then((processedResult) =&gt; {\n  console.log(&#39;进一步处理结果：&#39;, processedResult);\n}).catch((error) =&gt; {\n  console.error(&#39;捕获到错误：&#39;, error.message);\n});\n```\n\n### 多个异步操作处理\n\n可以使用 `Promise.all()`、`Promise.race()` 等方法处理多个 Promise。`Promise.all()` 等待所有 Promise 都变为 fulfilled 状态后，返回一个包含所有结果的数组；如果有一个 Promise 变为 rejected 状态，则立即返回该错误。`Promise.race()` 只要有一个 Promise 状态发生改变（无论是 fulfilled 还是 rejected），就返回该结果。\n\n```js\nconst promise1 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 1000));\nconst promise2 = new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000));\n\nPromise.all([promise1, promise2])\n  .then(results =&gt; console.log(&#39;所有操作完成：&#39;, results)) // [1, 2]\n  .catch(error =&gt; console.error(&#39;错误：&#39;, error));\n\nPromise.race([promise1, promise2])\n  .then(result =&gt; console.log(&#39;最快完成的操作结果：&#39;, result)) // 1\n  .catch(error =&gt; console.error(&#39;错误：&#39;, error));\n```&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作.mdx&quot;],&quot;digest&quot;:[0,&quot;77da42125a832c58&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;解释-promise-的三种状态及其转换关系如何使用-promise-处理异步操作&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点&quot;],&quot;category&quot;:[0,&quot;JavaScript 深入理解&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-12T05:17:23.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;异步编程是指在程序执行过程中，当遇到耗时操作（如网络请求、文件读写、定时器等）时，不会阻塞后续代码的执行，而是继续执行其他任务，待耗时操作执行完成后再用特定方式通知并处理结果的编程方式。**其核心意义在于提高程序的执行效率，避免因等待耗时操作而造成的资源浪费。**\n\n## JavaScript 中实现异步编程的方式及其优缺点对比\n\n### 1. 回调函数（Callback）\n\n```js\nsetTimeout(() =&gt; {\n  console.log(\&quot;异步操作完成！\&quot;);\n}, 1000);\n```\n\n- 原理：将一个函数作为参数传递给另一个函数，当异步操作完成后，调用该函数来处理结果。\n- 优点：实现简单，易于理解和使用。是最基础的异步编程方式。\n- 缺点：多层嵌套时，会形成“回调地狱”，代码可读性差，维护困难；无法使用 `try/catch` 捕获异常，错误处理不方便。\n\n### 2. Promise\n\n```js\nnew Promise((resolve) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(\&quot;异步操作完成！\&quot;);\n  }, 1000);\n})\n  .then((result) =&gt; {\n    console.log(result);\n  })\n  .catch((error) =&gt; {\n    console.error(error);\n  });\n```\n\n- 原理：通过构造函数创建一个对象，代表异步操作的最终完成成或失败，并提供 `then`、 `catch` 等方法处理结果或错误，支持链式调用。\n- 优点：解决了“回调地狱”的问题，代码结构清晰；支持错误捕获和链式操作，便于流程控制。\n- 缺点：无法中途取消；如果不设置 `catch` ，错误可能会被静默忽略；链式调用过长时，代码可读性仍有进一步提升空间。\n\n### 3. Generator 函数\n\n```js\nfunction* asyncGenerator() {\n  yield new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(1), 1000));\n\n  yield new Promise((resolve) =&gt; setTimeout(() =&gt; resolve(2), 1000));\n}\n\nconst generator = asyncGenerator();\n\ngenerator\n  .next()\n  .value.then((result) =&gt; {\n    console.log(result); // 1\n\n    return generator.next().value;\n  })\n  .then((result) =&gt; {\n    console.log(result); // 2\n  });\n```\n\n- 原理：通过 `function*` 定义，使用 `yield` 关键字暂停函数执行，`next()` 方法恢复执行，可以配合 `yield` 处理异步任务，实现分步执行。\n- 优点：可以控制异步操作的执行顺序，手动暂停和恢复；能在异步过程中返回中间结果。\n- 缺点：使用方式相对复杂，需要手动调用 `next()`；流程管理不够直观，可读性不如 `async/await`。\n\n### 4. async/await\n\n```js\nasync function asyncFunction() {\n  try {\n    const result = await new Promise((resolve) =&gt;\n      setTimeout(() =&gt; resolve(\&quot;异步操作完成！\&quot;), 1000),\n    );\n    console.log(result);\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n- 原理：基于 `Promise` 的语法糖，`async` 关键字声明异步函数，`await` 关键字用于等待 `Promise` 对象的结果，使异步代码看起来像同步代码。\n- 优点：代码结构清晰，可读性强，接近同步代码的写法；支持 `try/catch` 捕获错误，错误处理方便；能直观地控制异步处理顺序。\n- 缺点：`await` 只能在异步函数中使用；对于多个并行的异步操作，必须使用 `Promise.all()` 等方法来处理，否则可能导致性能问题。\n\n### 5. EventEmitter\n\n```js\nconst EventEmitter = require(\&quot;events\&quot;);\nconst emitter = new EventEmitter();\n\nemitter.on(\&quot;done\&quot;, (result) =&gt; {\n  console.log(result);\n});\n\nsetTimeout(() =&gt; {\n  emitter.emit(\&quot;done\&quot;, \&quot;异步操作完成！\&quot;);\n}, 1000);\n```\n\n- 原理：通过发布-订阅模式，异步操作完成后触发特定事件，通过监听该事件处理结果。\n- 优点：适合多对多的异步通信场景，一个事件可以被多个监听器处理。\n- 缺点：事件名称容易冲突，流程追踪困难，不易调试；多个事件存在复杂关系时，管理难度大。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点.mdx&quot;],&quot;digest&quot;:[0,&quot;9daf0bfae8932a5d&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是异步编程javascript-中实现异步编程的方式有哪些请对比它们的优缺点&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题&quot;],&quot;category&quot;:[0,&quot;JavaScript 深入理解&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-12T03:22:01.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;闭包是指在 JavaScript 中，一个函数内部嵌套了另一个函数，内部函数引用了外部函数的变量或参数，并且内部函数在外部函数执行完成后仍能够访问这些变量或参数，这样就形成了闭包。\n\n## 闭包的形成条件\n\n- 存在函数嵌套，即一个函数内部定义了另一个函数。\n- 内部函数引用了外部函数的变量或参数。\n- 内部函数被外部函数返回，或在外部函数外被引用。\n\n## 工作原理\n\n当外部函数执行时，会创建一个**执行上下文**，其中包含**函数的参数**、**局部变量**等信息。通常情况下，外部函数执行完成后，其执行上下文会被销毁，内部变量会被回收。但如果存在闭包，内部函数会**保留对外部函数变量对象的引用**，使外部函数的**执行上下文不会被销毁**，从而使内部函数在后续仍能访问这些变量。\n\n## 闭包的用途\n\n- **实现数据私有化**：通过闭包可以将变量封装在外部函数中，只允许内部函数提供的接口访问或修改，避免变量被外部随意访问或修改。例如：\n\n```js\nfunction createCounter() {\n  let count = 0;\n  \n  return {\n    increment: function () {\n      count++;\n    },\n    decrement: function () {\n      count--;\n    },\n    getCount: function () {\n      return count;\n    }\n  }\n}\n\nconst counter = createCounter();\n\ncounter.increment();\ncounter.decrement();\nconsole.log(&#39;getCount: &#39;, counter.getCount());\n```\n\n- **保存变量状态**：在循环或异步操作中，闭包可以保存每次迭代的变量值，避免因变量共享导致的问题，比如：\n\n```js\nfor (let i = 0; i &lt; 3; i++) {\n  (function (index) {\n    setTimeout(() =&gt; {\n      console.log(index);\n    }, 1000);\n  })(i);\n}\n```\n\n- **模块化开发**：利用闭包可以创建独立的模块，将模块内的函数和变量隐藏起来，只暴露必要的接口，实现代码的封装和隔离。\n\n## 可能带来的问题\n\n- **内存泄漏**：由于闭包会保留对外部函数变量对象的引用，导致这些变量无法被垃圾回收机制回收，长期累积可能会占用过多内存，影响页面性能。\n- **变量共享问题**：如果多个闭包引用同一个外部变量，可能出现变量值被意外修改的情况，需要谨慎处理。\n- **调试困难**：闭包使得变量的作用域链变得复杂，增加代码调试的难度。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题.mdx&quot;],&quot;digest&quot;:[0,&quot;9fde409091a7224a&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;详细阐述-javascript-中的闭包闭包的用途及可能带来的问题&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获&quot;],&quot;category&quot;:[0,&quot;基础概念&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-10T18:28:26.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;- **事件冒泡**：事件冒泡是指当一个元素触发某个事件后，该事件会从触发事件的元素开始，按照 DOM 树的顺序向上冒泡，依次触发其父元素、祖父元素等祖先元素上的相同事件，直到传递到 document 对象。_例如，在一个嵌套元素中，点击子元素，若父元素和父祖元素也绑定了相同的点击事件，那么这些事件会按照 `子 -&gt; 父 -&gt; 祖父` 的顺序依次触发。_\n- **事件捕获**：事件捕获与事件冒泡相反，它是事件从最顶层的祖先元素开始向下传播，依次触发各级子元素上的相同事件，直到到达触发事件的目标元素。_比如上述嵌套结构，点击子元素时，事件会按照 `祖父 -&gt; 父 -&gt; 子` 的顺序传播并触发相应的事件。_\n\n在 JavaScript 中，可以通过以下方法阻止事件冒泡和事件捕获：\n\n- **阻止事件冒泡**：可以使用 `event.stopPropagation()` 方法来阻止事件冒泡。该方法会阻止事件继续向上传播，但不会影响该元素上其他事件处理程序的执行。\n- **阻止事件捕获**：同样可以使用 `event.stopPropagation()` 方法。在事件捕获阶段调用该方法，能阻止事件继续向下传播到目标元素及其子元素。\n\n需要注意的是，`event.stopImmediatePropagation()` 方法不仅能阻止事件的冒泡和捕获，还能阻止该元素上后续的事件处理程序执行，**使用时需根据实际需求选择。**&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获.mdx&quot;],&quot;digest&quot;:[0,&quot;f45711bf69eacbb5&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;解释事件冒泡和事件捕获的概念以及如何阻止事件冒泡和事件捕获&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;什么是 JavaScript 的原型链？请举例说明原型链的工作机制.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;什么是 JavaScript 的原型链？请举例说明原型链的工作机制&quot;],&quot;category&quot;:[0,&quot;基础概念&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-10T18:00:53.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;在 JavaScript 中，所有对象都有一个原型（prototype），原型本身也是一个对象，而这个原型对象也有自己的原型，这样就形成了一条链式结构，**这就是原型链**。原型链的存在使得对象可以继承它的原型及其原型的原型上的属性和方法。\n\n## 原型链的工作机制\n\n原型链的工作机制主要体现在属性和方法的查找过程中：当访问一个对象的属性或方法时，JavaScript 会优先在 **其自身查找**，如果找到则直接使用；如果未找到，则会去 **该对象的原型中查找**；如果还是未找到，则会继续**向上查找**，直到找到或到达原型链的顶端（即 null）；如果仍然未找到，则返回 `undefined`。\n\n![prototype](../../assets/images/prototype.png)\n\n例如，我们创建一个构造函数 `Person`，并给其原型添加一个方法 `sayHello`：\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function sayHello() {\n  console.log(\&quot;hello, my name is \&quot; + this.name);\n};\n```\n\n然后通过这个构造函数创建一个实例对象 `person1`：\n\n```js\nconst person1 = new Person(\&quot;Alice\&quot;);\n```\n\n当我们调用引擎 `person1.sayHello()` 时，JavaScript 引擎现在自身查找 `sayHello` 方法，没找到后，就去 `person1` 的原型上（即 `Person.prototype`）查找，在这里找到该方法，于是调用成功。\n\n再比如，`person1` 的原型 `Person.prototype` 的原型是 `Object.prototype`，`Object.prototype` 上有 `toString` 等方法。当我们调用 `person1.toString()` 时，在 `person1` 自身和 `person1.prototype` 上都没有找到 `toString` 方法，最终在 `Object.prototype` 上找到了该方法，于是调用成功。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/什么是 JavaScript 的原型链？请举例说明原型链的工作机制.mdx&quot;],&quot;digest&quot;:[0,&quot;3c00725fce22a021&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;什么是-javascript-的原型链请举例说明原型链的工作机制&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换&quot;],&quot;category&quot;:[0,&quot;基础概念&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-10T17:42:32.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;CSS 盒模型是 CSS 布局的基础，它规定了元素在页面中占据空间的计算方式，每个元素都可以看作一个盒子，由 **内容（content）**、**边框（border）**、**内边距（padding）**、**外边距（margin）** 四部分组成。\n\n## 标准盒模型与怪异盒模型的区别\n\n标准盒模型和怪异盒模型（也称为 IE 盒模型）的核心区别在于**元素总宽度和总高度的计算方式**：\n\n### **标准盒模型**\n\n- 元素总宽度 = 内容区宽度（width） + 左右内边距（padding-left + padding-right） + 左右边框宽度（border-left + border-right）\n- 元素总高度 = 内容区高度（height） + 上下内边距（padding-top + padding-bottom) + 上下边框宽度（border-top + border-bottom）\n\n也就是说，**标准盒模型中设置的 width 和 height 仅指代内容区的尺寸。**\n\n### **怪异盒模型**\n\n- 元素总宽度 = 设置的 width 值（width 包含内容区宽度 + 左右内边距 + 左右边框宽度）\n- 元素总高度 = 设置的 height 值（height 包含内容区高度 + 上下内边距 + 上下边框宽度）\n\n## CSS 切换盒模型\n\n通过 CSS 的 `box-sizing` 属性可以切换这两种盒模型：\n\n- 当 `box-sizing` 属性的值为 `content-box` 时，采用标准盒模型（默认值）。\n- 当 `box-sizing` 属性的值为 `border-box` 时，采用怪异盒模型。\n\n例如，若一个元素设置 CSS 属性为 `width: 200px; padding: 10px; border: 5px solid #000;`，在标准盒模型下，其总宽度为 `230px`，在怪异盒模型下，其总宽度为 `200px`。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换.mdx&quot;],&quot;digest&quot;:[0,&quot;7332be30a36dd761&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;简述-css-的盒模型包括标准盒模型和怪异盒模型的区别以及如何通过-css-进行切换&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;请详细解释 HTML5 中的语义化标签及其作用.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;请详细解释 HTML5 中的语义化标签及其作用&quot;],&quot;category&quot;:[0,&quot;基础概念&quot;],&quot;pubDate&quot;:[3,&quot;2025-07-10T16:59:10.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;HTML5 中的语义化标签是指那些能清晰描述自身内容含义的标签，例如：`&lt;header&gt;`、`&lt;nav&gt;`、`&lt;aside&gt;`、`&lt;header&gt;`、`&lt;main&gt;`、`&lt;footer&gt;`、`&lt;article&gt;`、`&lt;section&gt;`等。\n\n## 标签介绍\n\n常见的 HTML5 语义化标签如下\n\n### \\&lt;header&gt;\n\n用于定义页面或页面中某个区块的头部，通常包含标题、Logo、导航等内容。_比如网站的顶部导航栏区域可以用 `&lt;header&gt;` 标签包裹。_\n\n### \\&lt;nav&gt;\n\n专用于表示页面中的导航部分，集中放置链接，方便用户快速跳转到其他页面或页面内的其他部分，向网站的主导航菜单就适合放在 `&lt;nav&gt;` 标签中。\n\n### \\&lt;aside&gt;\n\n表示与主要内容相关但又可以独立的辅助内容信息，_如侧边栏的广告位、相关文章推荐、作者介绍等。_\n\n### \\&lt;main&gt;\n\n表示页面的主要内容区域，一个页面中通常只有一个 `&lt;main&gt;` 标签，它包含了与页面核心主题相关的内容，帮助开发者和浏览器快速定位页面的核心信息。\n\n### \\&lt;footer&gt;\n\n定义页面或者页面某个区块的底部，一般包含版本信息、联系方式、隐私政策链接等内容，_例如页面当中的版权声明区域一般用 `&lt;footer&gt;` 标签包裹。_\n\n### \\&lt;article&gt;\n\n用于定义独立的、完整的内容块，*如一篇博客文章、一条新闻、一个论坛帖子等，*这些内容即使脱离页面其他部分也能独立存在并被理解。\n\n### \\&lt;section&gt;\n\n用于将页面内容划分为多个不同的区块，每个区块通常有自己的主题，它可以包括标题、段落等内容，_比如在一篇博客文章内可以通过 `&lt;section&gt;` 标签来分隔不同章节。_\n\n## 总结\n\n语义化标签的作用主要体现在以下几个方面：\n\n- **提升代码的可读性和可维护性**：开发者通过页面标签就可以快速了解页面结构，便于团队协作和代码后期维护。\n- **有利于搜索引擎优化（SEO）**：搜索引擎可以通过语义化标签更准确地抓取和理解页面内容，提高页面在搜索结果中的排名。\n- **改善无障碍访问**：屏幕阅读器等辅助设备能借助语义化标签更好地解析页面内容，帮助残障人士更好地获取页面信息。\n- **规范页面结构**：是页面结构更清晰、合理，符合 Web 标准，减少了因使用无意义标签导致的结构混乱问题。&quot;],&quot;filePath&quot;:[0,&quot;src/content/interview/请详细解释 HTML5 中的语义化标签及其作用.mdx&quot;],&quot;digest&quot;:[0,&quot;859ad070b8e0caa5&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;interview&quot;],&quot;slug&quot;:[0,&quot;请详细解释-html5-中的语义化标签及其作用&quot;],&quot;render&quot;:[0,null]}]]],&quot;prefix&quot;:[0,&quot;interview&quot;]}" ssr client="only" opts="{&quot;name&quot;:&quot;PostList&quot;,&quot;value&quot;:&quot;vue&quot;}"></astro-island> </article> <footer class="p-6 text-center"> <a class="no-underline text-inherit" href="javascript: void(0);">&copy; 2025 lihzsky.</a> All rights reserved.
</footer> </body></html>