const _astro_dataLayerContent = [["Map",1,2,9,10,132,133,178,179],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.12.0","content-config-digest","57d45038e08d6741","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://lihaizhong.github.io\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"attribute\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"astro_assets\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/noop\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":{\"type\":\"shiki\",\"excludeLangs\":[\"math\"]},\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null],\"rehypePlugins\":[null],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"rawEnvValues\":false},\"legacy\":{\"collections\":false}}","blog",["Map",11,12,22,23,31,32,40,41,50,51,60,61,69,70,78,79,87,88,97,98,106,107,115,116,124,125],"git中reset和revert的区别",{id:11,data:13,body:17,filePath:18,digest:19,legacyId:20,deferredRender:21},{title:14,description:15,pubDate:16,heroImage:15},"Git中reset和revert的区别","",["Date","2023-08-29T13:15:19.000Z"],"在现代程序开发过程中，我们常常使用**Git**作为我们的版本控制工具。**Git**的功能非常丰富，这里我就不做过多的介绍，只是介绍回退功能。在日常团队开发中，我们偶尔会遇到操作不当导致需要回退到特定版本的情况。这个时候，我们今天的主角就登场了————`git reset`和`git revert`。\n\n首先，我们可以使用`git log --pretty=oneline --abbrev-commit`来展示`commit记录`信息。大概会长这样：\n\n```bash\n51b41d2d3 (HEAD -> dev_gift, origin/v11.1.35, origin/pianli_dev, origin/dev_gift) chore: @2dfire/meal-meta@1.0.117\nd5aa83954 share页面，售后详情页跳转模式修改\n8df946cf6 Merge branch 'v11.1.35' of git.2dfire.net:firecode/firecode-mercury into v11.1.35\n39ad07ff2  share页面，会员卡页面跳转模式修改\n8ab1f776d update: AuthBox 渲染修复\n4eca779d2 Merge branch 'v11.1.35' of https://git.2dfire.net/firecode/firecode-mercury into v11.1.35\na32cdfe32 update: AuthBox 组件 appId 获取改造，模版菜单特权卡0元商品领取流程修复\n720b4910b 小程序appId获取修改\naf22a2c0e update: meta sync\n6693f6337 Merge branch 'dev_message' into v11.1.35\n405c45b8e Merge branch 'v11.1.35' of git.2dfire.net:firecode/firecode-mercury into v11.1.35\n17bdd051b Merge branch 'dev_entrance' into v11.1.35\nbb8ab8bf9 update: version\n8bc1418b4 Merge branch 'dev_meal_code' into v11.1.35\n21c8aa53f Merge branch 'dev_gift_0821' into v11.1.35\n```\n\n## git reset\n\n最先想到的应该是`git reset`，这是**Git**很早就有的功能。它会将`HEAD`指向指定的`commit记录`，并遗弃在它之后的所有记录。\n\n![git reset](../../assets/images/git-reset.png)\n\n```bash\n# 后面的commit内容存入工作区\ngit reset B<commit id>\n\n# 后面的commit内容直接丢弃\ngit reset --hard B<commit id>\n\n# 后面的commit内容存入暂存区\ngit reset --soft B<commit id>\n```\n\n从图中我们可以看到，这个过程会将`HEAD`指针指向记录B的位置。后续的提交会紧跟着记录B进行，而记录C和记录D将被抛弃。\n\n这里需要注意，`git reset`有一些参数，不同的参数会有不同的影响，可以指定是否复原索引或工作树内容。\n\n- **--mixed**（默认）：**重置索引，但不重置工作树**。即HEAD指向指定的`commit记录`，该`commit记录`后面所有的更改被存入工作区。\n- **--hard**：**重置索引和工作树**。即HEAD指向指定的commit记录，该`commit记录`后面所有更改被全部丢弃。\n- **--soft**：**不重置索引和工作树，但重置HEAD位置**。即HEAD指向指定的`commit记录`，该`commit记录`后面所有的更改被存入暂存区。\n\n另外还有 **--merge** 和 **--keep** 指令，这里不做过多介绍。如果想要了解更多，可以去[官网](https://git-scm.com/docs/git-reset/zh_HANS-CN)了解。\n\n使用上面的命令就可以做到回退到某个`commit记录`。注意因为回退会导致本地仓库的记录落后于远程仓库而无法同步，如需同步这次操作，必须**使用`git push --force`强制推送**。\n\n> **注意**\n>\n> 将`git reset`与`--hard`一起使用时要非常小心，因为它会重置你的提交、暂存区和你的工作树。如果为正确使用此选项，则最终可能会丢失所编写的代码。\n\n## git revert\n\n如果你已经将提交推送到远程仓库，则建议尽量不要使用`git reset`，因为它会重建提交的历史记录。这会使与其他开发人员一起处理仓库并维护一致的提交历史变得非常困难。**这时候使用`git revert`可能会更好**。它通过创建一个全新的相反的提交来撤销先前提交所做的更改，所有这些都不会改变原有的`commit记录`。\n\n![git revert](../../assets/images/git-revert.png)\n\n```bash\ngit revert B<commit id>\n```\n\n从图中我们看到，这个过程并不会回退`HEAD`，只是在原有的基础上添加一条`commit记录`。这条`commit记录`与需要回退的记录保持相反的操作，已达到行为上的回撤效果。\n\n## 结论\n\n好了，两种回退的方式我们都简单介绍过了，相信大家也已经基本掌握了吧。我认为，只要掌握这两条基本准则，我们就能在回退时尽最大可能保证保证其他合作者。\n\n1. 如果需要回退的`commit记录`没有同步远程仓库，使用`git reset`操作。\n2. 如果需要回退的`commit记录`已同步远程仓库，使用`git revert`操作。\n\n我这里只对`git reset`和`git revert`做我们相对常用的介绍，仍然推荐大家到[官网](https://git-scm.com/book/en/v2)接受最新的资料学习。","src/content/blog/Git中reset和revert的区别.mdx","5a202a66e1545757","Git中reset和revert的区别.mdx",true,"ecmascript之箭头函数",{id:22,data:24,body:27,filePath:28,digest:29,legacyId:30,deferredRender:21},{title:25,description:15,pubDate:26,heroImage:15},"ECMAScript之箭头函数",["Date","2019-04-09T11:19:09.000Z"],"随着前端最近几年的快速发展，前端语言也带来翻天覆地的变化，沉寂多年的 JavaScript 也迎来大变革，许多新特性加入到了 JavaScript 语言当中。今天我们就来聊聊 ES6 带来的一个新特性 —— 箭头函数。\n\n## 什么是箭头函数\n\n箭头函数是 ES6 引入的新特性。相对于普通函数，箭头函数的写法非常简单，同时箭头函数还有很多与普通函数不同的特点。在下面的篇幅中，我会详细介绍这些特点。\n\n## 箭头函数的特点\n\n前面我们讲了箭头函数是 ES6 引入的新特性，那么它到底与普通函数有什么区别呢？在使用箭头函数时，我们需要注意些什么呢？\n\n《ES 6标准入门》(第二版)中有这样四个注意点：\n\n1. **函数体内的`this`对象就是定义时所在的对象，而不是使用时所在的对象。**\n2. **不可以当做构造函数。也就是说，不可以使用`new`命令，否则会抛出一个错误。**\n3. **不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以使用rest参数代替。**\n4. **不可以使用`yield`命令，因此箭头函数不能用作`Generator`函数。**\n\n这本书简单概括了箭头函数的特点，但是我觉得还不够详细。下面我就来将每一个特点展开讲解，并配合代码示例，希望能帮助大家更好地理解箭头函数。\n\n## 更简单的语法\n\n相对于普通的函数，箭头函数的语法更加的简单。下面我们来举几个例子。\n\n```javascript\n// 普通函数声明\nvar func1 = function() {}\n// 箭头函数声明\nvar func1 = () => {}\n\n// 普通函数带一个参数\nvar func2 = function(arg0) {}\n// 箭头函数带一个参数\nvar func2 = arg0 => {}\n\n// 普通函数带多个参数\nvar func3 = function(arg0, arg1) {}\n// 箭头函数带多个参数\nvar func3 = (arg0, arg1) => {}\n\n// 普通函数返回值\nvar func4 = function() { return '返回值' }\n// 箭头函数返回值\nvar func4 = () => '返回值'\n\n// 普通函数多条语句\nvar func5 = function() {\n  var a = '一条语句'\n  return a\n}\n// 箭头函数多条语句\nvar func5 = () => {\n  var a = '一条语句'\n  return a\n}\n```\n\n怎么样，是不是感觉箭头函数更加的简单明了。我们不仅写起来方便快捷，还增加了代码的可读性。简洁的语法使它受到了许多开发者的喜爱。目前在我经历的项目中，能用箭头函数的，绝不会使用普通函数。尤其是在回调函数的时候，我会优先考虑使用箭头函数代替普通函数，当然这不仅仅因为它的简洁性，还有一个非常重要的特性让我选择使用它，那就是箭头函数的`this`指向。\n\n## this 指向问题\n\n箭头函数的`this`指向规则和普通函数有很大的区别。这里我用代码来解释下箭头函数的`this`指向问题，请看下面的代码。\n\n```javascript\nvar obj ={\n  a: function() {\n    console.log(this)\n  },\n  b: () => {\n    console.log(this)\n  }\n}\n\n// { a: ..., b: ... } 返回obj对象\nobj.a()\n// Window{...} 返回window对象\nobj.b()\n\nvar a = obj.a\n// Window{...} 返回window对象\na()\n\nvar b = obj.b\n// Window{...} 返回window对象\nb()\n```\n\n![执行结果](../../assets/images/WX20190411-015056.png)\n\n我们可以看到，我同样在`obj`对象中定义了属性方法，并且使用同样的方式执行它们，但是结果却不一样。这是为什么呢？\n\n刚接触不久的前端同学应该深有感触，在 JavaScript 语言中，`this`是个淘气的孩子，总喜欢调皮捣蛋，有时候你看着外套都一样，可以一叫才发现已经换了一个人儿。所以使用`this`时，我们总是非常谨慎，深怕一不注意就出错了。但是在箭头函数中不会出现这样的问题。原因是普通函数是在使用时才能确定`this`的指向（即`this`是调用这个函数的对象，如果在全局调用，那调用的对象就是`window`或者`undefined`，这与是否是严格模式有关），而箭头函数的`this`是在定义时就已经确定了。\n\n### 箭头函数本身没有`prototype`（原型）对象，所以箭头函数本身是没有`this`的。\n\n```javascript\nvar a = () => {}\nconsole.log(a.prototype) // undefined\n```\n\n![执行结果](../../assets/images/WX20190411-015358.png)\n\n### 箭头函数的`this`指向在定义时就继承了外层第一个普通函数的`this`。\n\n请看下面这段代码，它能更好地让我们理解这条规则。\n\n```javascript\nvar a, b;\nvar bar = { xxx: 'this 指向 bar' }\nvar foo = { xxx: 'this 指向 foo' }\n\nfunction barFn() {\n  // 我们在 barFn 函数中定义了箭头函数 a\n  a = () => console.log(this)\n  // 我们在 barFn 函数中定义了普通函数 b\n  b = function() { console.log(this) }\n}\n\nfunction fooFn() {\n  // 我们在 fooFn 函数中调用函数 a\n  a()\n  // 我们在 fooFn 函数中调用函数 b\n  b()\n}\n\n// 我们修改 barFn 的 `this` 指向\nbarFn.call(bar)\n// 我们修改 fooFn 的 `this` 指向\nfooFn.call(foo)\n```\n\n![执行结果](../../assets/images/WX20190411-014914.png)\n\n这个例子我们可以得出两个结论：\n\n1. 箭头函数的`this`指向定义时所在的第一个外层函数，跟使用的位置无关。\n2. 当被继承的外层函数的`this`发生改变时，箭头函数的`this`也会跟着改变。\n\n### 我们不能直接修改箭头函数的this指向\n\n下面我们对上面的fooFn函数做一些修改\n\n```javascript\nfunction fooFn() {\n  a.call(this)\n  b.call(this)\n}\n```\n\n![执行结果](../../assets/images/WX20190411-015235.png)\n\n这里我们可以看到即使我们手动修改了`this`的指向，也不会影响到箭头函数的`this`指向。\n\n使用`bind`、`apply`、`call`无法改变箭头函数的`this`指向，但是仍然可以将实参传入箭头函数。当然箭头函数的`this`并非完全不可修改，我们可以修改被继承的外层函数的`this`来间接地修改箭头函数的`this`指向。这个在上一个例子中有所体现。\n\n### 箭头函数外层没有普通函数包裹时，无论是否在严格模式下，this 都会指向 window 对象。\n\n之前我们说了 “箭头函数的`this`指向第一个外层函数的`this`” 这句话确实没错。但是仔细想想，如果箭头函数外层没有函数时它又指向哪里呢？\n\n我们知道普通函数在非严格模式下`this`是指向`window`的，而在严格模式下`this`是`undefined`。但是箭头函数的规则不同，无论是否在严格模式下，`this`都会指向`window`。\n\n以上就是箭头函数中，`this`的特点。正是这些特点，我们在回调函数和多层嵌套的函数中经常会使用它，尤其是函数内正好需要使用外层函数的`this`时。这使我们不需要专门定义一个变量来保存`this`，增强了代码的可读性。\n\n## 不能将箭头函数作为构造函数使用\n\n```javascript\nvar A = () => {}\nnew A()\n```\n\n![执行结果](../../assets/images/WX20190731-110410.png)\n\n上图我们可以看到，我们使用箭头函数`new`了一个实例，结果却报了语法错误。\n\n```javascript\nfunction A() {\n  this.arrow = () => {\n    super()\n  }\n}\n\nvar a = new A()\n\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-024631@2x.png)\n\n上面的执行结果，当箭头函数中执行`super`时报错了，因为箭头函数不是构造函数，函数体中没有`super`函数。\n\n```javascript\nfunction A() {\n  this.arrow = () => {\n    console.log(new.target)\n  }\n}\n\nvar a = new A()\n\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-024807@2x.png)\n\n```javascript\nfunction A() {\n  \n}\n\nA.prototype.b = function() {\n  this.arrow = () => {\n    console.log(new.target)\n  }\n}\n\nvar a = new A()\n\na.b()\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-025710@2x.png)\n\n从上面两个例子中，我们可以看出，`new.target`的值是不一样的，这也证明了箭头函数不能作为构造函数。\n\n## 箭头函数没有 arguments 对象\n\n```javascript\nvar a = () => { console.log(arguments) }\na(1, 2)\n```\n\n![执行结果](../../assets/images/WX20190411-020421.png)\n\n这里可以看到，当在箭头函数中调用`arguments`会出现报错的情况。但是你以为这样就完了吗？通过图片我们可以看到错误信息是指引用错误`ReferenceError`。那么，如果我们在`this`对象上定义一个`arguments`参数会怎么样呢？我们试试吧。\n\n```javascript\nwindow.arguments = ['a', 'b']\nvar a = () => { console.log(arguments) }\na(1, 2)\n```\n\n![执行结果](../../assets/images/WX20190411-021151.png)\n\n没错，正如我们所想。`arguments`返回的是我们全局定义的属性的值。\n\n到这里我们可以看到，箭头函数的函数体中并不存在`arguments`对象。我们知道`arguments`方便了我们获取函数的参数，在箭头函数中，是否可以有一种方式能获取函数的所有参数呢？答案当然是肯定的，而且比`arguments`的功能更加的强大。这就不得不讲到的另一个 ES 6 引入的特性——`rest参数`。而且`rest参数`返回的是一个真正的数组（`arguments`返回的是一个类数组，不能调用数组的一些方法，需要手动做一次转义）。对于`rest参数`，我这里就不细讲了，感兴趣的同学可以自己去查阅资料，内容也不复杂，非常容易理解，使用也非常方便。\n\n```javascript\nvar a = (...rest) => console.log(rest)\na(1, 3, 5)\n```\n\n![执行结果](../../assets/images/WX20190411-023144.png)\n\n## 箭头函数不能使用 yield 命令\n\n```javascript\nvar a = num => {\n  var b = yield num + 1\n  return b\n}\n```\n\n![执行结果](../../assets/images/WX20190411-105952.png)\n\n```javascript\nvar a = *(num) => {\n  var b = yield num + 1;\n  return b;\n}\n```\n\n![执行结果](../../assets/images/WX20190411-110824.png)\n\n首先，箭头函数没有`function`关键字，所以实际是不能写成 Generator 函数，这样`yield`自然也是没有用了。\n\n## 总结\n\n1. 什么是箭头函数\n2. 箭头函数的特点\n3. 更简单的语法\n4. this 指向问题\n   1. 箭头函数本身没有`prototype`（原型）对象，所以箭头函数本身是没有`this`的。\n   2. 箭头函数的`this`指向在定义时就继承了外层第一个普通函数的`this`。\n   3. 我们不能直接修改箭头函数的this指向\n   4. 箭头函数外层没有普通函数包裹时，无论是否在严格模式下，this 都会指向 window 对象。\n5. 不能将箭头函数作为构造函数使用\n6. 箭头函数没有 arguments 对象\n7. 箭头函数不能使用 yield 命令\n8. 总结","src/content/blog/ECMAScript之箭头函数.mdx","5cf322795b9d4f56","ECMAScript之箭头函数.mdx","http的强缓存与协商缓存",{id:31,data:33,body:36,filePath:37,digest:38,legacyId:39,deferredRender:21},{title:34,description:15,pubDate:35,heroImage:15},"HTTP的强缓存与协商缓存",["Date","2020-04-10T02:47:15.000Z"],"对于前端而言，我们经常需要与后端进行数据交互，常用的数据交互方式就是**HTTP请求**。在HTTP请求的过程中，有一些静态资源很少发生变化，但每次都要重新请求并从服务端下载，这不仅影响资源的响应时长，还会增加了服务器的压力。为了解决这个问题就有了HTTP缓存机制。它是浏览器与服务器之间的一种优化策略，*为了加快用户的访问速度，增强用户体验，减轻服务器压力。*\n\n![HTTP缓存](../../assets/images/1355655874_6620.jpg)\n\n## HTTP缓存有什么优点\n\n1. 减少冗余的数据传输，节省网络资源。\n2. 减少服务器的负担，提升网站的性能。\n3. 加快客户端加载网页的速度，增强用户体验。\n\n**我们知道，HTTP的缓存分为强缓存和协商缓存。**\n\n- 那他们之间有什么区别呢？\n- 如何判断是否使用了缓存以及使用了哪种缓存？\n- 如何开启强缓存和协商缓存？\n\n带着这些问题，我们一起来探索HTTP缓存机制。\n\n## 强缓存与协商缓存的区别\n\n1. 强缓存不需要请求服务器，协商缓存需要请求服务器。\n2. 强缓存返回的HTTP状态码是200，协商缓存返回的HTTP状态码是304。\n\n他们之间的共同点是**强缓存与协商缓存都是从客户端获取缓存数据的**。\n\n## 如何判断浏览器是否使用了缓存，使用了哪种缓存\n\n我们可以打开Chrome浏览器的控制台工具，点击Network，可以查看我们的http请求情况。下面两个是我的真实请求情况。\n\n![强缓存](../../assets/images/WX20200416-142801.png)\n\n上图中有两条请求信息是从缓存中获得的。我们可以看右数第三列，这里告诉我们这个请求的数据是从磁盘缓存中获取的。\n\n![协商缓存](../../assets/images/WX20200416-142909.png)\n\n上图中有两条信息是通过协商缓存获得的。我们可以看左数第二列，他们的状态码都是304。\n\n## 如何开启强缓存和协商缓存\n\n### 开启HTTP强缓存\n\n对于强制缓存，可以通过在Nginx上配置**Expires**或者**Cache-Control**来开启。\n\n*Expires的值是一个固定的过期时间。在这个时间内，所有的信息都会从HTTP缓存中获取。这样的方式并不灵活。*\n\n1. 如果时间未过期，即使服务器更新了最新的数据，浏览器也可能在较长一段时间内不去更新数据。\n2. 如果时间过期了，即使服务器依然是老的数据，浏览器还是会重新去服务器请求。\n\n*Cache-Control的值是一个相对时间。也就是在一定时间内，浏览器依然会读取缓存，过了这个时间间隔，浏览器会再次请求数据，并重新计算相对时间。这种方案相对于第一种更加灵活，能更好地利用缓存，也能更及时地更新数据。*\n\n#### 客户端可以在HTTP中设置的Cache-Control指令。\n\n- Cache-Control: max-age=\\<seconds\\>\n- Cache-Control: max-stale\\[=\\<seconds\\>\\]\n- Cache-Control: min-fresh=\\<seconds\\>\n- Cache-Control: no-cache\n- Cache-Control: no-store\n- Cache-Control: no-transform\n- Cache-Control: only-if-cached\n\n#### 服务器可以在HTTP中设置的Cache-Control指令。\n\n- Cache-Control: must-revalidate\n- Cache-Control: no-cache\n- Cache-Control: no-store\n- Cache-Control: no-transform\n- Cache-Control: public\n- Cache-Control: private\n- Cache-Control: proxy-revalidate\n- Cache-Control: max-age=\\<seconds\\>\n- Cache-Control: s-maxage=\\<seconds\\>\n\n#### 扩展指令。不是核心HTTP请求标准的一部分，请谨慎使用，注意兼容性。\n\n- Cache-Control: immutable\n- Cache-Control: stale-while-revalidate=\\<seconds\\>\n- Cache-Control: stale-if-error=\\<seconds\\>\n\nCache-Control各种属性有很多，具体的含义可以参看[MDN上的Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)。这里我们主要来讲讲**no-cache**、**no-store**以及**max-age**这三个属性。\n\n**no-cache** 在使用缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存验证）。也就是说，请求一定会发送，但请求的结果可能是直接返回数据，也可能告诉浏览器读取当前缓存。\n\n**no-store** 不在客户端存储任何请求的内容（包括请求内容和服务器响应的内容），即不使用任何缓存策略。\n\n**max-age** 设置缓存的最大存储周期。超过了这个时间（*单位：秒*），将不使用本地缓存。与Expires不同的是，这个时间是一个相对时间，是指请求返回后的*max-age*秒。\n\n**这两种方案都是不错的强缓存策略，但是对于频繁发布的系统，显然这两种方案都无法满足要求。**\n\n### 开启HTTP协商缓存\n\n协商缓存依然需要向服务器发送信息，但是服务器会根据相应的情况返回数据或者告诉浏览器可以从本地缓存中获得。当我们使用`Cache-Control: no-cache`时，服务器是怎么知道当前的缓存是否过期了呢？\n\n这里我们就讲讲服务器检查HTTP缓存是否过期的两个属性**Last-Modify/If-Modify-Since**和**Etag/If-None-Match**。\n\n对于**Last-Modify/If-Modify-Since**，浏览器第一次请求时会返回一个Last-Modify，这个属性表示服务器资源上次修改的时间。再次请求时，客户端会在request头中加上If-Modify-Since，用于服务器验证表示资源是否已过期。 **If-Modify-Since的值就是上次Last-Modify的值。** 如果时间匹配不一致，就返回新数据，并覆盖当前的缓存；否则服务器返回304请求（不返回任何数据），浏览器会从本地缓存中读取数据信息。\n\n*既然已经有了Last-Modify/If-Modify-Since，为什么还需要ETag呢？这里我们先讲讲ETag的值，然后在解释为什么，以及他们的优劣。*\n\n**ETag/If-None-Match**的值是hash值，表示当前文件对应的hash。随着文件的变化，hash也会相应改变。整体的验证流程与Last-Modify/If-Modify-Since相同，**ETag的生成由服务器决定**。\n\n*好了，讲完他们的定义，我们来看看它们两个有什么不同，怎么选择他们的设置呢？*\n\n1. **在多机运行的情况下，每台服务器的时间不一定一致，会导致Last-Modify失效；而ETag每次都会计算最新的文件hash值，确保了精度，在多机部署的情况下能保证hash值的一致性。**\n2. **在性能上，Last-Modify只需要获取文件改变的时间即可，而ETag需要算法计算最新的hash值。相对来说，Last-Modify的性能优于ETag。**\n3. **服务器校验时，优先考虑ETag的校验。**\n\n从上面的情况看，如果你只是单机运行，推荐使用Last-Modify/If-Modify-Since，这样相对来说能提升性能；如果你是多机运行，推荐使用ETag/If-None-Match，这样能解决服务器时间不一致导致的失效问题。\n\n### HTTP缓存的过程\n\n1. 第一次请求加载时，浏览器会下载远程资源，服务器返回HTTP STATUS为200。浏览器将response headers和请求数据一并缓存下来。\n2. 第二次请求加载时，浏览器会先计算当前时间和上一次200请求的时间差，与Cache-Control的有效时间进行比较，如果没有过期，则命中强缓存，不做HTTP请求；（如果浏览器不支持HTTP 1.1，则会比较Expires上的时间）\n3. 如果没有命中强缓存，浏览器会带上上次请求的信息（将Last-Modify的值设置到If-Modify-Since上；将ETag的值，设置到If-None-Match上）发送给服务器，服务器根据这两个属性判断是否命中协商缓存。\n4. 服务器收到请求后，优先判断ETag是否一致。如果一致，则返回HTTP STATUS为304，不返回数据，浏览器根据这个状态码，使用本地缓存数据；否则服务器返回HTTP STATUS为200，最新的ETag和新数据。\n5. 服务器如果没有收到ETag的值，服务器将比较Last-Modify是否一致。如果一致，则返回HTTP STATUS为304，不返回数据，浏览器根据这个状态码，使用本地缓存数据；否则服务器返回HTTP STATUS为200，返回最新的数据覆盖当前缓存。\n\n## 结论\n\n合理地使用缓存策略，能大大提升我们服务器的性能。Cache-Control属性的选择，ETag/If-None-Match与Last-Modify/If-Modify-Since的选择，需要根据实际情况来定。一些接口请求涉及到数据更新频率较高，不建议使用缓存策略。\n\n## 参考\n\n- [强制缓存和协商缓存的区别](https://blog.csdn.net/wsymcxy/article/details/82154397)\n- [浏览器缓存详解:expires,cache-control,last-modified,etag详细说明](https://blog.csdn.net/eroswang/article/details/8302191)","src/content/blog/HTTP的强缓存与协商缓存.mdx","0fd2b3feaf21e504","HTTP的强缓存与协商缓存.mdx","v8引擎的垃圾回收机制",{id:40,data:42,body:46,filePath:47,digest:48,legacyId:49,deferredRender:21},{title:43,description:44,pubDate:45,heroImage:15},"V8引擎的垃圾回收机制","V8引擎作为目前最流行的JavaScript引擎，在浏览器端和NodeJS端都有使用。尤其在浏览器端，正是V8引擎的保驾护航，奠定了Chrome在浏览器端的霸主地位。早期的V8引擎采用Full-Codegen+Crankshaft架构，现在已经更换为Ignition+TurboFan架构。在垃圾回收方面是基于弱分代假说实现，并做了很多优化策略，进一步提升性能。",["Date","2023-08-15T07:15:01.000Z"],"V8引擎作为目前最流行的JavaScript引擎，在浏览器端和NodeJS端都有使用。尤其在浏览器端，正是V8引擎的保驾护航，奠定了Chrome在浏览器端的霸主地位。早期的V8引擎采用`Full-Codegen` + `Crankshaft`架构，现在已经更换为`Ignition` + `TurboFan`架构。在垃圾回收方面是基于**弱分代假说**实现，并做了很多优化策略，进一步提升性能。\n\n**弱分代假说认为，大多数对象只会存在很短的时间，而另一部分对象则会接近于永生。** 根据这个理论，V8把需要执行GC的内存空间**分为新生代和老生代**两部分，分别放置生命周期长度不同的对象并**使用不同的GC策略，从而显著提升 GC 效率**。\n\n## V8的内存构成\n\nV8管理的内存是有限制的。在64位操作系统环境中，新生代的默认大小为**32MB**，老生代的默认大小约为**1.4GB**；在32位操作系统环境减半。这样的设置基本上能胜任浏览器环境，但是对于有大文件场景的NodeJS环境有些吃力了。不过不用担心，V8为此已经做了很多的优化工作，以尽可能保证应用的流畅性。今天，我们先简单了解下V8的内存划分：\n\n- 新生代内存区（Young Generation/New Space）：大多数对象都在这里。\n- 老生代内存区（Old Generation/Old Space）：常驻内存的对象在这里。\n- 大对象区（Large Object Space）：大于1MB的对象会被放在这里，GC不会回收这部分内存。\n- 代码区（Code Space）：唯一拥有执行权限的内存。\n- Cell区、PropertyCell区、Map区（Cell Space、Property Cell Space、Map Space）：隐藏类的存放位置。这些空间中的每个空间都包含相同大小的对象，并且对它们指向的对象有一些限制，从而简化了回收。\n\n![V8内存构成](../../assets/images/memory-structure-of-V8.png)\n\n> 这些空间中的每一个都由一组Pages组成。Page是使用[mmap](https://baike.baidu.com/item/mmap/1322217?fr=ge_ala)从操作系统分配的连续内存块。除大对象空间外，每个页面的大小均为1MB。 **垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。** 每个区里面的内存页开头都有一个header，里面包括：\n> \n> - 各种**元数据和flag**（比如本页数据哪个区），GC需要使用的各种统计数据，GC各个阶段在本页的进展状况等。\n> - 一个**slots buffer**，记录了所有指向本页内对象的指针，以节省回收时的一些扫描操作。\n> - 一个**skip list**，将本页划分位多个区（region）并维护各个区的边界，用于快速搜索页上的对象。\n> \n> 紧跟着header的是一个**bitmap**，上面的每个bit对应页上的一个字，用于后面会介绍的marking。前面的部分按32个字对齐后，剩余的空间才是用于存储对象的。\n\n**注意：** 我们这里说的垃圾回收器只作用于**堆内存**。因为**栈内存**由操作系统直接管理，不在我们本文的讨论范围内。\n\n## 新生代的GC策略\n\n垃圾回收算法：**Scavenge(具体实现上采用Cheney算法)**\n\n新生代会将内存分成相等大小的两块**Semi-Space**，分别叫做**From Space**和**To Space**。**From Space**是真正的使用内存，**To Space**是空闲的，在GC的时候才会用到。也就是说，实际利用起来的新生代内存只有整体新生代内存的一半。\n\n新生代使用的是Scavenge算法，具体实现使用了*Cheney算法*，流程如下：\n\n1. 广度优先遍历**From Space**中的对象，把存活的对象复制到**To Space**。\n2. 遍历完成后，清空**From Space**。\n3. **From Space**和**To Space**角色互换（称为翻转）。\n\n另外，复制后的对象在**To Space**中占用的内存空间是连续的，不会出现碎片的问题。因为新生代的GC相对比较频繁，所以更侧重速度上尽可能快。\n\n**注意：** **From Space**又会被划分为`Nursery`和`Intermediate`两块区域。对象第一次分配内存时在`Nursery`区域，经历过一次GC后转移到`Intermediate`区域。\n\n## 对象晋升策略\n\n新生代的对象不会一直存在于该区域。当满足一定条件的情况下，新生代的对象会得到**晋升（Promote）**，即从新生代转移到老生代。晋升的情况一般有两种：\n\n- 经历一次GC后仍然存活的对象，即`Intermediate`中的。\n- 对象复制到**To Space**时，**To Space**的空间已经使用了25%以上。\n\n## 老生代的GC策略\n\n垃圾回收算法：**Mark-Sweep(标记清除算法)** + **Mark-Compact(标记整理算法)**\n\n老生代内存也分为两部分：\n\n- **指针区（Old Pointer Space）**：如果对象可能有指向其他对象的指针，保存在这里。大多数晋升的对象都在这里。\n- **数据区（Old Data Space）**：只保存原始对象哎那个，没有指向其他对象的指针。\n\n老生代做垃圾回收时包含了两种算法：**标记清除(Mark Sweep)**和**标记整理（Mark Compact）**。只有三个步骤：\n\n1. Marking 标记\n2. Sweeping 清除\n3. Compacting 整理\n\n### Marking 标记\n\n标记就是找到所有可访问对象的过程。两种算法的标记流程是一样的。使用了**三色标记法**：\n\n- **00**：白色。表示未被引用。\n- **10**：灰色。表示被引用，但是其引用的对象还没有遍历完。\n- **11**：黑色。表示被引用，并且其引用的对象已经遍历完成。\n\n首先将所有对象标记为**白色**，然后从根集*Root Set*（执行栈和全局对象）开始，以**深度优先遍历**的方式为访问到的对象添加**灰/黑色**。\n\n### Sweeping 清除\n\n清除被标记为白色的对象。这个结果会造成内存空间不连续的情况。清除的本质是**将内存的地址标记位空闲**，代码层面上是把内存地址保存到一个叫`Free List`的数据结构中。\n\n### Compacting 整理\n\n修改仍然存活的对象的内存地址，将不同内存页上的对象整合到一起，使得内存空间紧凑有序。这个过程比较消耗性能。\n\n## 回收算法比较\n\n| 回收算法     | Scavenge           | Mark-Sweep   | Mark-Compact |\n|--------------|--------------------|--------------|--------------|\n| 速度         | 快                 | 中           | 慢           |\n| 空间         | 双倍空间（无碎片） | 少（有碎片） | 少（无碎片） |\n| 是否移动对象 | 是                 | 否           | 是           |\n\n基于**弱分代假说**理论，实现不同分代采用不同策略的垃圾回收算法，以达到空间与时间的最优平衡解。\n\n## 垃圾回收机制的进阶问题\n\n对于进阶问题，这里只做简单了解。如果你有兴趣，可以自行查阅资料了解更多信息。毕竟真正的知识不是一篇文章能够讲明白的。比起做一个知识的定义者，我更希望能够成为知识的启蒙者，让大家能带着更多的疑问去思考，去整理自己的知识库。\n\n### 为什么V8引擎需要限制内存大小\n\n1. 浏览器环境很少会遇到使用大量内存的场景，因此没有必要将最大内存设置得过高。\n2. JavaScript是单线程机制，垃圾回收同样会阻塞JS主线程逻辑的执行。\n3. 垃圾回收本身也是一件非常耗时的操作，所以使用内存过大会导致主线程出现卡顿现象（这种现象叫做全停顿`Stop The World`），造成浏览器长时间无法得到响应。\n\n按照官方的说法，以1.5GB的垃圾回收的堆内存为例，V8做一次**小的垃圾回收**需要**50ms**以上，而做一次**非增量式回收**甚至需要**1s以上**，可见其耗时之久，而在这1s的时间内，**应用的性能和响应时间会大大下降**，这样的情况无论是前端还是后端，都是无法接受的。因此在当时的情况下，直接限制堆内存是一个好的选择。\n\n### 什么是增量标记、延迟清除和增量整理\n\n为了进一步提升V8的性能，垃圾回收器已经开始往增量式、并发式、并行式改进了。目前主要的优化发生在老生代的GC上，因为新生代的GC一般很短暂，可优化的空间和意义不大。从官方的说法上我们可以得知，一次完整的垃圾回收非常耗时，采用增量的方式可以将时间拆分以达到更理想的效果（运行时间不超过5ms）。\n\n在标记阶段，V8引入了增量标记的概念；在清除阶段，V8引入了并发、并行和延迟清除的概念；在整理阶段，V8同样引入了增量整理的概念。\n\n*当然采用增量的方式最大的问题是如何保证对象的误标记。* 为了解决这个问题，V8在写屏障的基础上，额外添加了一个需要记录的情形：**每次产生从黑色对象指向白色对象的引用的时候，将被指的对象重新标记为灰色，放回标记的队列中，这样便不会误将存活的对象标记为死亡了。**\n\n### 什么是写屏障\n\n根据前面所学的知识，我们来想一个问题。**如果新生代有一个对象，它只有一个引用，而它的引用在老生代，这时候如果保证新生代进行垃圾回收时，这个对象不会被清除掉呢？**\n\n对于这个问题，V8选择的解决方案是使用**写屏障（write barrier）**，即每次往一个对象写入一个指针（*添加引用*）的时候，都执行一段代码，这段代码会检查这个被写入的指针是否是由老生代对象指向新生代对象的，这样我们就能明确地记录下所有从老生代指向新生代的指针了。这个用于记录的数据结构叫做**StoreBuffer**，每个堆维护一个，为了防止它无限增长下去，会定期地进行清理、去重和更新。这样，我们可以通过扫描，得知`根对象->新生代`和`新生代->新生代`的引用，通过检查**StoreBuffer**，得知`老生代->新生代`的引用，就没有漏网之鱼，可以安心地对新生代进行回收了。\n\n### 什么是隐藏类\n\n在阅读下面的内容之前，请明确两个重点：\n\n1. V8会为每个对象关联一个隐藏类。\n2. 隐藏类的目的是优化属性的访问速度。\n\n隐藏类的出现是为了优化JavaScript属性值的查找问题，提升这块的性能。由于JavaScript是动态语言，变量随时可以变换类型。也就是说它不能像Java那样，在运行时就确定属性的值（或者指针）在内存的偏移量，这就导致了JavaScript的属性查找相较于静态语言会慢很多。\n\nV8使用了**隐藏类**的方式来模拟类似静态语言的查找方式，做到尽可能地提升查找速度。从结构上来说，隐藏类和Java中的固定对象结构非常相似。\n\n### 什么是内联缓存\n\n除了隐藏类，V8还利用了**内联缓存**的方式，进一步提升了JavaScript的性能。V8会维护一个记录最近有一段时间内调用方法时传入的参数类型。一旦V8引擎对参数的类型进行了正确的预测，将使得引擎越过解析如何访问类属性的过程，直接使用之前缓存的信息直接获得隐藏类并对对象属性的进行访问。\n\n### 什么是HotSpot热点代码收集\n\n对于反复多次被使用的代码，V8会将这块代码的字节码编译成更为高效的机器码，然后当再次被执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就可以大大提升代码的执行效率。\n\n## 总结\n\n以上就是垃圾回收机制的内容了，那么最后我来做下总结：\n\n1. 垃圾回收分为`新生代`和`老生代`。\n2. 新生代采用的是`Scavenge算法`。\n3. 老生代采用的是`标记清除`+`标记整理`算法。\n\n## 提问\n\n1. 新生代变量是如何进行提升的？\n2. 新生代对象仅被老生代引用时，新生代检查时如何识别对象被引用？\n3. 由于JavaScript的灵活性，导致只有在运行时才能确定数据占用空间的大小，这样会使内存读时需要耗费更多的时间。那么V8内存管理机制是如何解决这个问题的？","src/content/blog/V8引擎的垃圾回收机制.mdx","8b0101728e8107e9","V8引擎的垃圾回收机制.mdx","homebrew常用命令",{id:50,data:52,body:56,filePath:57,digest:58,legacyId:59,deferredRender:21},{title:53,description:54,pubDate:55,heroImage:15},"Homebrew常用命令","Homebrew是Mac上强大的包管理器，它用于更加方便和直观的帮助我们管理Mac上的软件包以及相关的服务。",["Date","2022-04-27T18:54:23.000Z"],"今天，我们主要讲的是Homebrew中对我们日常工作特别有帮助的指令。如果您还想了解更多的Homebrew知识，欢迎您访问[Homebrew文档官网](https://docs.brew.sh/)查看更多命令。\n\n## 安装软件包\n\n```bash\nbrew install $FORMULA\n```\n\n安装指定的包\n\n## 更新Homebrew\n\n要获取最新的包列表，首先得更新 Homebrew 自己。这可以用`brew update`。\n\n```bash\nbrew update\n\n# Updated 2 taps (homebrew/core and homebrew/cask).\n# ==> Updated Formulae\n# adios2               cpufetch             etcd                 libopenmpt           mitmproxy            pwntools             vnstat\n# athenacli            croaring             etcd-cpp-apiv3       libpipeline          mpi4py               pygments             wcslib\n# aws-sdk-cpp          cruft                flowgrind            liquidprompt         ns-3                 rtorrent             xmlrpc-c\n# cgif                 deno                 gnu-getopt           luarocks             oh-my-posh           staticcheck          xpdf\n# charm-tools          duplicity            harfbuzz             macvim               parallel             termius              zeek\n# ciphey               eccodes              hlint                magic-wormhole       phoronix-test-suite  theharvester\n# ==> Updated Casks\n# android-studio       calibre              gitfox               rambox               rectangle-pro        resolume-arena       tableau\n```\n\n## 更新软件包(formula)\n\n要获取需要更新的软件包列表，可以使用`brew outdated`。\n\n```bash\nbrew outdated\n```\n\n更新需要更新的软件包\n\n```bash\n# 更新所有的包\nbrew upgrade\n# 更新指定的包\nbrew upgrade $FORMULA\n```\n\n## 清理旧版本软件包\n\n一般情况下，新版本安装了，旧版本就不需要了。我们可以使用`brew cleanup`清除旧的软件包以及缓存文件。\n\n**PS：Homebrew只会清除比当前版本旧的软件包，所以不用担心没更新的包也被删了。**\n\n## 锁定不想更新的软件包\n\nHomebrew一次性更新包是一件非常方便的事。但是有时候我们会有一些包不想更新。比如我们在使用mongodb，数据库的跨版本更新需要同时更新数据，这样不利于我们方便的使用。\n\n这时候，我们可以使用`brew pin`来锁定这个包。当Homebrew更新操作时，会忽略掉被锁定的包。\n\n```bash\n# 锁定指定包\nbrew pin $FORMULA\n\n# 取消锁定指定包\nbrew unpin $FORMULA\n```\n\n## 查看软件包\n\n如果我们想知道自己已经安装了哪些软件包，可以使用`brew list`。\n\n```bash\nbrew list\n```\n\nHomebrew可以通过命令查看包的相关信息，这些信息会在包安装完成后自动显示。如果后期还想查看，可以通过`brew info`和`brew deps --installed --tree`进行指定的查看。\n\n```bash\n# 显示指定包的信息\nbrew info $FORMULA\n\n# 显示安装包的数量，文件数量，和总占用空间\nbrew info\n```\n\n我们可以通过`brew deps`查看包的依赖关系，当想删除指定包时，这非常有用。\n\n比如，我想删除`node@14`这个包，我使用`brew deps`查看依赖关系，知晓我是否能安全删除`node@14`这个包，最后发现我的`mongosh`依赖它。\n\n```bash\n# 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。\nbrew deps\n\n# 查看已安装的包的依赖，树形显示\nbrew deps --installed --tree\n\n# mongodb/brew/mongodb-community\n# ├── mongodb-database-tools\n# └── mongosh\n#     └── node@14\n#         ├── brotli\n#         ├── c-ares\n#         ├── icu4c\n#         ├── libnghttp2\n#         ├── libuv\n#         ├── openssl@1.1\n#         │   └── ca-certificates\n#         └── macos-term-size\n# node\n# ├── brotli\n# ├── c-ares\n# ├── icu4c\n# ├── libnghttp2\n# ├── libuv\n# └── openssl@1.1\n#     └── ca-certificates\n\n# node@14\n# ├── brotli\n# ├── c-ares\n# ├── icu4c\n# ├── libnghttp2\n# ├── libuv\n# ├── openssl@1.1\n# │   └── ca-certificates\n# └── macos-term-size\n```\n\n可以使用`brew search`来搜索软件包，支持使用正则表达式进行复杂的搜索。例如，我们查询下静态博客生成工具hugo。\n\n```bash\nbrew search hugo\n\n# ==> Searching local taps...\n# hugo ✔\n# ==> Searching taps on GitHub...\n# ==> Searching blacklisted, migrated and deleted formulae...\n```\n\n## 服务管理\n\n`brew services`用于方便的管理brew安装的服务软件，类似于Linux下的service命令。\n\n```bash\n\n# List all running services for the current user (or root).\n# 获取当前用户（或者管理员）的所有服务列表\nbrew services list\n# Name              Status User File\n# mongodb-community none        \n# php               none \n\n# Run the service formula without registering to launch at login (or boot).\n# 运行指定的服务软件并且不注册到登录时启动。\nbrew services run $FORMULA\n# 运行所有服务软件并且不注册到登录时启动。\nbrew services run --all\n\n# Start the service formula immediately and register it to launch at login (or boot).\n# 运行指定的服务软件并且注册到登录时启动。\nbrew services start $FORMULA\n# 运行指定的服务软件并且注册到登录时启动。\nbrew services start --all\n\n# Stop the service formula immediately and unregister it from launching at login (or boot).\n# 停止运行指定的服务并且注销登录时启动。\nbrew services stop $FORMULA\n# 停止运行指定的服务并且注销登录时启动。\nbrew services stop --all\n\n# Stop (if necessary) and start the service formula immediately and register it to launch at login (or boot).\n# 立即停止并启动指定服务，并且注册到登录时启动。\nbrew services restart $FORMULA\n# 立即停止并启动所有服务，并注册到登录时启动。\nbrew services restart --all\n\n# Remove all unused services.\n# 移除所有无用的服务。\nbrew services cleanup\n\n\n# If sudo is passed, operate on /Library/LaunchDaemons (started at boot).\n# Otherwise, operate on ~/Library/LaunchAgents (started at login).\n```\n\n## 查看Homebrew的配置信息\n\n用于查看Homebrew所在环境及相关的配置情况。\n\n```bash\nbrew config\n```\n\n## 诊断问题\n\n诊断当前Homebrew存在哪些问题，并**给出解决方案**。\n\n```bash\nbrew doctor\n```\n\n## 仓库管理\n\n```bash\n# 已安装的仓库列表\nbrew tap\n\n# 添加仓库\nbrew tap [--full] user/repo [URL]\n\n# 移除仓库\nbrew untap tap\n```\n\n## Homebrew可视化管理\n\n如果你不想去记忆这么多复杂的命令，也可以使用[Cakebrew](https://www.cakebrew.com/)可视化管理。\n\n安装命令如下：\n\n```bash\nbrew cask install cakebrew\n```\n\n然后我们就可以愉快地使用Homebrew了。\n\n## Homebrew services 可视化管理\n\n[LaunchRocket](https://github.com/jimbojsb/launchrocket)是非常友好的图形界面，使用起来简单快捷。比如你使用Homebrew安装的 Mysql、Redis、MongoDB，是让它自启动呢，还是手动启动，传统方式需要使用命令行的命令，而使用`LaunchRocket`则可以在图形界面中进行管理了！\n\n以上是Homebrew常用功能。\n\n最后的最后，感谢您的阅读！！！","src/content/blog/Homebrew常用命令.mdx","8a8bc0ebbb1dd5de","Homebrew常用命令.mdx","javascript中的constlet和var的区别",{id:60,data:62,body:65,filePath:66,digest:67,legacyId:68,deferredRender:21},{title:63,description:15,pubDate:64,heroImage:15},"JavaScript中的const、let和var的区别",["Date","2020-06-01T14:03:00.000Z"],"JavaScript是一门弱类型语言。在ES3和ES5时期，我们都是通过 **var** 来声明一个变量的。那个时候的前端开发相对简单，JavaScript通常是被用来做些景上添花的小功能，所以完全能够应付我们的日常开发工作。随着移动互联网的兴起，H5应用适应快速迭代的属性使前端得到了快速发展，不断叠加的业务需求也凸显出了JavaScript在大型项目中的劣势（可维护性差）。因此，语言的升级势在必行，而变量声明的方式则是其中需要优化的内容之一。今天我们的主题就来说说变量声明 —— **const** 和 **let**。\n\n## 变量的创建\n\n首先，我要讲清楚变量声明存在三个步骤：\n1. **创建** 变量；\n2. **初始化** 变量；\n3. **更新** 变量。\n\n这三个步骤的 *微妙差异*，正是 **const**、**let**、 **var** 三者之间的不同之处。\n\n## const和let\n\n**`const`命令是声明一个常量。`const`只能进行变量的创建和变量初始化，而不能进行变量更新。** \n\n```javascript\nconst a = 1\na = 2 // Uncaught TypeError: Assignment to constant variable.\n```\n\n可以看到，当我们对 **const** 声明的变量进行更新时，浏览器报了相应的错误。\n\n**`let`命令是指声明一个变量。`let`可以进行变量的创建、变量的初始化和变量的更新。**\n\n```javascript\nlet a = 1\na = 2\nconsole.log(a) // 2\n```\n\n可以看到，当我们对 **let** 声明的变量进行更新时，变量对应的值会进行相应的改变。\n\n## const、let与var的区别\n\nJavaScript是一门弱类型语言。它不会在声明时要求变量确定类型，甚至你可以随时修改变量的类型。那既然是弱类型语言，**var** 似乎足以满足所有的需求了，为什么还需要 **const** 和 **let** 呢？\n\n**原因是`var`太灵活了。** 很多时候，我们无法对 **var** 进行约束，这会导致我们的程序中出现意想不到的问题。\n\n1. **`var`存在变量提升的问题。**\n2. **`var`不支持块级作用域。**\n3. **`var`可以在静默状态下重复声明。**\n\n而 **const** 和 **let** 就是用来约束我们变量的使用，尽可能地减少意想不到的问题。上面我们已经讲到了 **var** 的问题，那么我就从这三个问题出发来讲讲 **const**、**let** 在解决这些问题上做了哪些努力？\n\n## 作用域\n\n首先，我们先来聊下 **作用域**。**作用域在高级语言中是一个非常重要的概念**。它相当于一个容器，变量和函数都放在这个容器里面。理论上来说，容器外面不能访问容器里面声明的变量和函数，但容器内可以调用父祖级容器的变量和函数。*即外部不能访问内部，内部可以访问外部*。举个栗子：\n\n``` javascript\nvar a = 1\n\nfunction foo() {\n  var b = 2\n  console.log(a) // 1\n}\n\nfoo()\nconsole.log(b) // Uncaught ReferenceError: b is not defined\n```\n\n这里`function foo`创建了一个**foo（scope）**，全局有一个**global（scope）**。**global**中存在`a`（变量）和`foo`（函数），**foo**中存在`b`（变量）。\n\n1. 在 **global** 中，我们能访问到`a`，但访问不到`b`，这就是 **作用域**。\n2. 在 **foo** 中，我们不仅能访问到`b`，也能访问到`a`，我们称之为 **作用域链**。\n\nES3和ES5中，**作用域的创建方式**只有**function**、**with**和**catch**。\n\n- **function** 是常用的创建作用域的方式；\n- **with** 已经被抛弃，因为它会导致作用域链发生变化（因此，浏览器所有的优化都会失效）；\n- **catch** 经常用于捕获错误。\n\nES6有了 **块级作用域** 的概念。**const** 和 **let** 命令就是作用于块级作用域。\n\n```javascript\n{\n  var a = 1\n  let b = 2\n  const c = 3\n}\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\nconsole.log(c) // Uncaught ReferenceError: c is not defined\n```\n\n从上面的例子中可以看到，**var** 命令不受块级作用域的影响，可以正常访问；**const** 和 **let** 受到块级作用域的影响，在块级作用域以外无法正常访问。\n\n依据这个特性，我想理解 **for** 循环的这个问题应该会变得容易很多：\n\n```javascript\nfor (var i = 0; i < 6; i++) {\n  setTimeout(function() {\n    console.log(i) // 6, 6, 6, 6, 6, 6\n  }, 20)\n}\n\nfor (let i = 0; i < 6; i++) {\n  setTimeout(function() {\n    console.log(i) // 0, 1, 2, 3, 4, 5\n  }, 20)\n}\n```\n\n这道题非常的经典，从 **作用域** 和 **作用域链** 的角度能很好的解释问题产生的原因。\n\n## 变量提升\n\n谈到JavaScript，我们知道 **var** 和 **function** 会存在变量提升的情况，也就是即使调用在声明之前，变量和方法依然能够访问而不会报错。\n\n```javascript\nconsole.log(a) // undefined\nfoo() // foo\n\nvar a = 1\n\nfunction foo() {\n  console.log('foo')\n}\n```\n\n上面的例子我们发现，即使 **var** 定义的变量写在声明之前依然能够访问，只是返回的值为 **undefined**；**function** 也是能正常访问，还能得到预期的结果，**这就是变量提升**。\n\n在JavaScript中，变量首先会被 **创建**，然后 **初始化**，最后 **更新**。我们从上面的代码来看这三个操作：\n\n1. JavaScript引擎会找到`var a`，然后告诉作用域 **创建一个名称为a的变量**；\n2. **立即初始化** 变量`a`，此时初始化的值为 **undefined**；\n3. 代码执行到编写的位置时会将变量`a` **更新为1**。\n\n也就是说，我们`console.log(a)`的结果为`undefined`的原因是 **`a`的创建和初始化的过程被提升了**。\n\n```javascript\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\nconsole.log(c) // Uncaught ReferenceError: c is not defined\n\nvar a = 1\nlet b = 2\nconst c = 3\n```\n\n这里我们试验一下 **const** 和 **let** 命令，发现他们都报错了。那么是不是说 **const** 和 **let** 不存在变量提升呢？\n\n其实严格意义上来讲， **`const`和`let`依然存在变量提升的情况** 。只是与 **var** 不同的是，**const** 和 **let** 只是创建被提升了。我们来看看ES6标准的原话。\n\n<blockquote>The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.</blockquote>\n\n*简单来说就是当环境作用域被创建时，变量就都已经被创建了*。只是这个时候我们还未进行声明，在这个时间点访问会导致直接报错。而从创建变量到声明变量这个时间段，我们就称它为**临时性死区（Temporal Dead Zone）**\n\n## 重复声明\n\n```javascript\nvar a = 1\nvar a = 2\nlet a = 3 // Uncaught SyntaxError: Identifier 'a' has already been declared\nlet b = 1\nlet b = 2\nvar b = 3 // Uncaught SyntaxError: Identifier 'b' has already been declared\nconst a = 1 // Uncaught SyntaxError: Identifier 'a' has already been declared\nconst b = 3 // Uncaught SyntaxError: Identifier 'b' has already been declared\nconst c = 1\nconst c = 2 // Uncaught SyntaxError: Identifier 'c' has already been declared\nvar c = 3 // Uncaught SyntaxError: Identifier 'c' has already been declared\nlet c = 4 // Uncaught SyntaxError: Identifier 'c' has already been declared\n```\n\n上面的例子，我们进行了很多重复声明。结果发现，\n\n1. **var** 命令和 **let** 命令可以进行重复声明，**const** 命令不能进行重复声明。\n2. **var** 命令和 **let** 命令重复声明时，命令必须与之前的相同，否则会报错。\n\n## 总结\n\n1. **var** 没有块级作用域概念，**const** 和 **let** 有块级作用域概念。\n2. **var** 会提升创建和初始化，**const** 和 **let** 只会提升创建。\n3. **const** 不可以重复声明，**let** 和 **var** 可以重复声明。","src/content/blog/JavaScript中的const、let和var的区别.mdx","f9dbca12e123d802","JavaScript中的const、let和var的区别.mdx","vue源码解析之代理模式",{id:69,data:71,body:74,filePath:75,digest:76,legacyId:77,deferredRender:21},{title:72,description:15,pubDate:73,heroImage:15},"Vue源码解析之代理模式",["Date","2019-10-11T08:06:31.000Z"],"不知不觉，Vue从诞生到现在已经走过了四个年头了。在这期间，前端发生了天翻地覆的变化，前端工作越来越复杂，前端应用维护也越来越困难，传统的开发模式已经无法满足现阶段的开发与维护了，这时候各种工具的出现使我们从刀耕火种的*jQuery时代*进化到了以三大框架为基础的*工业化时代*。三大框架抽离了我们对DOM层的直接操作，使前端开发更加专注于对业务的梳理、数据的处理以及组件的复用。\n\n几天前，Vue作者尤雨溪宣布`Vue 3.0 pre-alpha`版本发布，有兴趣的同学可以[点击这里](https://github.com/vuejs/vue-next)查看。由于 3.0 还太新，本人还没有去了解其源码，在这里就不再多说。今天我们还是继续探讨 2.0 的源码，聊聊 2.0 源码中的一些思想和理念。\n\n我们在使用Vue的时候有没有发现，我们在`data`、`props`、`computed`、`methods`中写的属性或者方法，能直接使用**Vue的实例**或者**Vue组件的实例**访问。同学们在使用过程中有没有为此感到好奇呢？那Vue是如何实现的呢？今天我们就来好好讲讲藏在Vue中的设计模式 —— 代理模式。\n\n## 代理模式\n\n**代理模式的定义就是把对目标对象的访问，交给另一个代理对象来操作。**\n\n细心观察，其实在我们日常开发中就有很多代理模式的实现案例。比如我们与后端交互一定会使用到`Ajax`技术，但是原生的`Ajax`写法非常麻烦，我们往往都会使用第三方库来完成`Ajax`请求。在这个过程中，我们并不会直接使用`XMLHttpRequest`的实例进行各种操作，而是通过**代理人**（第三方`Ajax`库抛出的对象）来帮助我们调用`Ajax`请求，完成与后端的交互。这种不直接操作目标对象，而是通过代理对象帮助完成特定操作的方式就是一种典型的代理模式。\n\n## Vue中的代理模式\n\n前面我们已经举了一个代理模式的栗子，那Vue是如何实现对`data`、`props`、`computed`、`methods`中的属性的代理的呢？\n\n这里要讲的是在ES5之后出现的一个重要方法 —— `Object.defineProperty`。了解Vue的同学应该都知道，`Object.defineProperty`在Vue中起着至关重要的作用，Vue的响应式数据设计就是依赖这个方法完成的。然而Vue并不仅仅只是利用它来实现响应式数据，为了方便操作定义在各个对象上的属性，Vue利用这个方法实现了代理模式，使开发者在开发的过程中更加优雅和舒适。\n\n在Vue中有一个特定的方法`proxy`，这个方法就是Vue代理模式的具体实现。\n\n```javascript\n/**\n * @param {object} target 这里往往是Vue的实例或者Vue组件的实例\n * @param {object} sourceKey 这里往往是被代理对象，也就是我们实际要操作的对象\n * @param {string} key 被代理的属性名称，也是我们在Vue的实例或者Vue组件的实例上操作的属性名称\n */\nfunction proxy(target, sourceKey, key) {\n  // 修改属性的get操作\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key]\n  }\n\n  // 修改属性的set操作\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val\n  }\n\n  // 实现代理的重要方法\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n\nproxy(vm, vm._data, key)\n```\n\nVue利用修改对象属性的`get`和`set`方法，实现了对`data`、`props`、`computed`、`methods`对象属性的代理。这样的实现方式，既可以保留我们习惯的编码方式，又可以使代码看上去更加的优雅。在我们的日常开发中，我们也可以学习使用这种方式来完成一些特定的操作。\n\n## 结论\n\n代理模式是一种思想，这种思想其实在我们开发中经常用到，有些时候可能只是我们没有意识到这本身就是一种设计模式。Vue很好的利用了代理模式和`Object.defineProperty`来实现优雅而舒适的编码方式。在日常开发中，我们应该好好利用代理模式来封装我们的代码。同时，合理的利用`Object.defineProperty`可以使我们的代码更加优雅，甚至可以提升我们的应用程序的性能（具体原因可以去查看[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)的描述符设置）。","src/content/blog/Vue源码解析之代理模式.mdx","75e1f8b217e565d4","Vue源码解析之代理模式.mdx","你需要知道的git提交规范",{id:78,data:80,body:83,filePath:84,digest:85,legacyId:86,deferredRender:21},{title:81,description:15,pubDate:82,heroImage:15},"你需要知道的Git提交规范",["Date","2019-12-02T18:38:05.000Z"],"我们应该对Git不太陌生，它是目前最火的分布式版本管理工具。那你知道怎样编写提交信息才能帮助我们更好地管理Git记录吗？今天，我们就来讲讲如何编写提交信息。\n\n## 为什么我们需要规范\n\n**古语有云：“没有规矩，不成方圆”。** 这句话不仅适用于工作生活中的方方面面，同样适用于我们的编程开发。一套标准的规范不仅能帮助我们形成良好的开发习惯，还能减少开发中犯错的几率，甚至可以基于这套规范创造更多的价值（比如：生成`CHANGELOG.md`）。就说Git提交规范，一套良好的提交规范可以使我们在查看提交信息时不那么茫然；尤其在回滚操作时，我们能更清楚了解到我们回滚可能造成的影响。\n\n## Git 提交规范\n\n``` text\n<type>(<scope>): <subject>\n<-- BLANK LINE -->\n<body>\n<-- BLANK LINK -->\n<footer>\n```\n\n`<type>(<scope>):`与`<subject>`之间需要加一个空格。\n\n### 规范类型\n\n#### type\n\n用于说明提交的类型，所有的提交类型如下：\n\n- **feat**: 新增feature\n- **fix**: 修复bug\n- **docs**: 仅仅修改了文档，比如`README.md`、`CHANGELOG.md`等\n- **style**: 仅仅修改了代码风格，不影响代码逻辑与功能\n- **refactor**: 代码重构（即不是新增功能，也不是修改bug的代码变动）\n- **perf**: 优化相关，比如提升了项目的性能、体验\n- **test**: 测试用例（单元测试、e2e测试、集成测试）\n- **chore**: 改变构建流程、增加或者删除依赖库、工具等\n- **revert**: 回滚到上一个版本\n\n#### scope\n\n用于说明提交影响的范围，可以是具体的某个模块。\n\n#### subject\n\n- 对提交的简单描述，不超过50个字符\n- 结尾不加标点符号\n\n#### body\n\n- 对提交的详细描述，建议在72个字以内\n- 表明这个变更的目的、细节以及是否存在副作用或者风险\n\n#### footer\n\n添加链接到具体的issue地址或者文档地址，或者关闭某个issue。\n\n### 提交格式要求\n\n``` text\n# 标题行：50个字符以内，描述主要变更内容\n#\n# 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:\n#\n# * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等\n# * 他如何解决这个问题? 具体描述解决问题的步骤\n# * 是否存在副作用、风险?\n#\n# 尾部：如果需要的话可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。\n```\n\n## 如何统一团队的提交规范\n\n规范很好，但是团队成员是否执行，执行的效果如何仍然是个问题。而为了检查团队成员的执行情况，花大量的时间、人力去监督明显是不合算的。所以，我们需要一套完整的工具去帮助我们团队成员执行这套规范。下面我先列举下我们需要的工具：\n\n- @commitlint/cli\n- @commitlint/config-conventional\n- husky\n- commitizen\n- conventional-changelog\n\n大致上，我们就需要这五个工具配合使用，来达到效果。首先介绍前三个工具 **@commitlint/cli**、**@commitlint/config-conventional**、**husky**。\n\n**@commitlint/cli**、**@commitlint/config-conventional**是用来检查`git commit`的提交是否符合规范的。**husky**是一个向Git仓库中注册钩子函数的工具。可以帮我们在提交信息时自动检查规范。使用很简单，只需要在我们的`package.json`中添加下面的配置即可。\n\n``` json\n// package.json\n\n{\n  ...\n  \"husky\": {\n    \"hooks\": {\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  }\n  ...\n}\n```\n\n这样我们就能保证我们的开发人员能遵守Git提交规范了。怎么样？很简单吧！但是仅仅能检查规范还不够，由于开发人员还未适应这样的代码提交规范，使用过程中往往会花很多时间在上面，那么我们就应该帮助开发人员适应这套规范。好了，**commitizen**就此登场了。**commitizen**是一个帮助遵照提交规范生成Git提交信息的工具。使用也非常简单，只需要在全局安装`npm i commitizen -g`就可以了。提交代码时，我们将`git commit`换成`git cz`，它会一步一步指导我们生成规范的提交。\n\n就此其实也已经差不多了。不过我还想扩展下，也许我们在上线后，想要一份本次项目的更改信息，我们可以添加**conventional-changelog**，这个工具将帮助我们生成一份当前版本的`CHANGELOG`。我们可以在`scripts`中添加任务，帮助我们生成`CHANGELOG`。\n\n``` json\n// package.json\n\n{\n  ...\n  \"scripts\": {\n    \"version\": \"conventional-changelog -p angular -i CHANGELOG.md -s && git add CHANGELOG.md”\n  },\n  ...\n}\n```\n\n这样配置之后，我们就可以在执行`npm run version`时，自动生成`CHANGELOG`了。\n\n## 结论\n\nGit提交规范本身不会对项目开发有任何的影响。但是，如果你是项目维护者，当项目出现问题需要回滚时，看着这一堆堆提交混乱的信息，你不觉得很头疼吗？当你回滚时，你能很放心地说‘这次回滚不会有问题，因为我了解回滚掉的所有改动！’吗？打江山难，守江山更难。维护是一件非常头疼却十分重要的事。如何起好一个开头对项目后期的维护至关重要。讲到这里，Git提交规范也基本已经讲解完了。如果你觉得很棒，赶快推荐给你们的团队吧！\n\n## 参考\n\n- [你可能忽略的Git提交规范](https://learnku.com/articles/25456?order_by=vote_count&)\n- [Git commit message和工作流规范](https://my.oschina.net/qcloudcommunity/blog/870743)","src/content/blog/你需要知道的Git提交规范.mdx","2adfd27ee22355de","你需要知道的Git提交规范.mdx","即时通信技术sse",{id:87,data:89,body:93,filePath:94,digest:95,legacyId:96,deferredRender:21},{title:90,description:91,pubDate:92,heroImage:15},"即时通信技术——SSE","有时候服务端并不能及时更新数据，导致客户端需要通过一些手段来获取真正最新的数据。这类的手段有很多种，例如轮询、长轮询、WebSocket以及我们今天要讲的SSE通信技术。这篇文章主要介绍SSE的使用以及它与其它技术之间的异同。",["Date","2023-11-20T19:14:07.000Z"],"import wxRequest from \"../../assets/images/request.png\";\n\n有这样一种场景，我们提交了一份表单，服务端进行处理。由于这份表单的处理非常复杂，服务端处理需要非常长的时间或者服务端依赖第三方无法给出确切的时间，为了避免影响用户操作，你会使用什么方式呢？\n\n我觉得这里核心思想是将 **提交表单** 和 **查询状态** 拆分，这样就仅仅只是 **查询状态** 的问题了。我想到了以下几种方式：\n\n- 提交表单后，**轮询** 查询状态\n- 提交表单后，马上发起一个 **长轮询** 查询状态\n- 提交表单后，通过 **WebSocket** 查询状态\n- 提交表单后，马上发起一个 **SSE** 查询状态\n\n方法有很多，我在这里就依次介绍它们的优缺点，当然重点还是讲讲我们的新工具 **SSE**。\n\n## 介绍\n\n### 轮询（Polling）\n\n轮询是客户端按照固定时间间隔（如每1秒、每5秒）主动向服务器发送请求，询问是否有新数据。服务器收到请求后，无论是否有新数据，都会立即响应。\n\n- 优点：\n  - **实现简单**：客户端只需定时发送 HTTP 请求，服务器正常处理即可，无需特殊逻辑，开发成本低。\n  - **兼容性好**：基于标准的 HTTP 协议，所有浏览器和服务器都支持，无需考虑兼容性问题。\n  - **资源可控**：客户端可以通过调整轮询间隔（如用户操作时缩短间隔，空闲时延长间隔），灵活控制请求频率，减少不必要的资源消耗。\n- 缺点：\n  - **实时性差**：数据更新的延迟取决于轮询间隔。_例如，间隔 10 秒时，新数据可能最多延迟 10 秒才能被客户端获取。_\n  - **资源浪费严重**：大部分请求是“无效”的（服务器无新数据），但仍会消耗客户端的网络带块、CPU/内存，以及服务器的处理能力和连接资源。尤其在高并发场景下，可能导致服务器压力过大。\n  - **频繁连接**：每次请求都需要建立 HTTP 连接（虽然 HTTP/1.1 有长连接优化，但仍有请求头、握手等开销），增加网络负载。\n- 适用场景：\n  - 实时性要求低（如天气预报、新闻列表等）、用户量小、服务资源有限的场景。\n- 不适用场景：\n  - 实时性要求高（如聊天、实时监控）、高并发场景。\n\n### 长轮询（Long Polling）\n\n场论序是对轮询的改进：客户端发送请求后，服务端不会立即返回响应，而是将请求“挂起”（保持连接），等待有新数据产生或超时后，再返回响应；客户端收到响应后，立即发送下一个请求，重复此过程。\n\n- 优点：\n  - **实时性较好**：服务器一旦有新数据，会立即通过挂起的连接返回，延迟远低于轮询（仅取决于数据产生时间和网络传输耗时）。\n  - **减少无效请求**：相比轮询，长轮询避免了固定间隔的无效请求，只有当数据更新或超时后才会返回，降低了网络和服务器的资源消耗。\n  - **兼容性好**：同样基于 HTTP 协议，大部分浏览器和服务器都支持，无需依赖特殊技术。\n- 缺点：\n  - **服务器资源占用高**：服务器需要保持大量“挂起”的连接（每个客户端一个），这会消耗服务器的内存和文件描述符（尤其在高并发场景下），对服务器的并发处理能力要求较高。\n  - **超时处理复杂**：需要合理设置超时时间（避免连接过久导致客户端断开），同时客户端需处理连接异常中断的情况（如网络波动），开发逻辑比较复杂。\n  - **仍有连接开销**：虽然减少了请求次数，但每次连接仍有 HTTP 头、握手等开销，且连接挂起期间仍占用网络资源。\n- 适用场景：\n  - 实时性要求中等（如社交媒体通知、在线客服）、用户量适中的场景。\n- 不适用场景：\n  - 超大规模并发（如百万级用户同时连接）、服务器资源紧张的场景（可能因挂起连接过多崩溃）。\n\n### WebSocket\n\nWebSocket是一种 **全双工通信协议**（RFC6455 定义），通过一次 HTTP 握手后，建立持久化的 TCP 连接，允许客户端和服务器 **双向实时发送数据**（客户端可主动发，服务器也可主动发），且数据传输格式灵活（文本、二进制等）。\n\n- 优点：\n  - **实时性极强**\n    - 建立连接后，客户端和服务器可随时双向发送数据，无需像轮询/长轮询那样反复建立连接，延迟极低（仅受网络传输和数据处理耗时影响），适合高频实时交互场景（如在线游戏、实时协作工具）。\n  - **低开销**\n    - 仅需一次 HTTP 握手，之后基于 TCP 连接直接传输数据，无需重复发送 HTTP 头信息，减少网络带宽消耗。\n    - 数据帧格式简洁（相比 HTTP 协议），进一步降低传输成本。\n  - **全双工通信**\n    - 客户端和服务器可平等地主动发送数据，无需依赖“客户端请求-服务器响应”的模式，灵活满足双向交互需求（如连天中双方互发消息）。\n  - **支持二进制数据**\n    - 可直接传输二进制数据（如图片、音频片段），无需像 HTTP 那样进行 Base64 等编码转换，节省处理时间和带宽。\n- 缺点：\n  - **实现复杂**\n    - 需要服务器和客户端都支持 WebSocket 协议（需处理握手、数据帧解析、连接保活等逻辑），开发成本高于轮询/长轮询。\n    - 部分老旧浏览器不支持（如 IE10 及以下版本），需要额外做兼容处理（如降级为长轮询）。\n  - **服务器压力**\n    - 长时间保持大量 TCP 连接（每个客户端一个），对服务器的并发处理能力（如文件描述符、内存）要求较高，高并发场景下需特殊优化（如使用异步 IO 框架）。\n  - **网络兼容性问题**\n    - 部分代理服务器、防火墙可能拦截 WebSocket 连接（因协议升级过程涉及非标准 HTTP 方法）。\n    - 连接断开后需手动重连，需实现重连逻辑（如指数退避策略）以保证稳定性。\n- 适用场景\n  - 实时游戏、在线聊天、协作工具、高频交互场景\n- 不适用场景\n  - 仅需单向推送、老旧环境、服务器资源有限的场景\n\n### SSE\n\nSSE是一种 **单向通信协议**，基于 HTTP 协议：客户端通过一次HTTP请求建立持久连接，之后 **只能由服务器向客户端单向发送数据**，客户端无法通过该连接主动向服务器发送数据（若需客户端发送数据，需额外用 HTTP 请求）。数据以“文本事件流”格式传输，客户端通过监听事件处理数据。\n\n- 优点\n  - **实现简单**\n    - 基于标准 HTTP 协议，客户端只需用 `EventSourceAPI` 建立连接并监听事件，服务器只需格式持续输出数据（无需处理复杂的协议帧），开发成本低。\n    - 兼容性较好（除IE全系外，主浏览器均支持），且可通过 polyfill 兼容老旧浏览器。\n  - **轻量级**\n    - 复用 HTTP 长连接，无需协议升级，对代理服务器和防火墙兼容性优于 WebSocket。\n    - 服务器发送的数据格式为文本（或嵌套 JSON），解析简单，适合传输结构化文本数据。\n  - **自动重连**\n    - 客户端 `EventSource` 会自动处理连接断开后的重连（默认重试间隔逐渐增加），无需手动实现重连逻辑，稳定性较高。\n  - **资源消耗较低**\n    - 相比 WebSocket，SSE连接的维护成本更低（基于HTTP长连接，服务器处理逻辑简单），适合服务器向大量客户端单向推送数据的场景（如新闻推送、实时日志）。\n- 缺点\n  - **单向通信限制**\n    - 仅支持服务器向客户端发送数据，若客户端需向服务器反馈（如确认收到消息），必须额外使用HTTP请求，增加了逻辑复杂度（相比WebSocket的双向通信）。\n  - **仅支持文本数据**\n    - 只能传输 UTF-8 编码的文本数据，无法直接传输二进制数据（需先编码为Base64等格式，增加开销），不适合二进制场景（如实时图片传输）。\n  - **浏览器连接限制**\n    - 浏览器对单个域名的SSE并发连接数有限制（通常为6个），若需多连接，需通过多个子域名绕过，增加架构复杂度。\n  - **实时性略逊于 WebSocket**\n    - 虽然延迟较低，但因基于HTTP长连接，数据传输格式和协议 overhead 略高于 WebSocket，极端高频场景下性能稍差。\n- 适用场景\n  - 新闻推送、实时通知、股票行情、日志监控\n- 不适用场景\n  - 需客户端主动发送数据、传输二进制数据的场景\n\n通过介绍，你应该大概了解了各种即时通信技术的区别，下面我重点讲解下 **SSE**。\n\n## SSE数据的基本结构\n\nSSE是通过事件来响应实时数据的。每个事件之间通过空行来分隔。对于每一行来说，冒号（“:”）前面表示的是该行的类型，冒号后面则是对应的值。可能的类型包括：\n\n- 类型为空白，表示该行是注释，会在处理时被忽略。\n- 类型为 data，表示该行包含的是数据。以 data 开头的行可以出现多次。所有这些行都是该事件的数据。\n- 类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。\n- 类型为 id，表示该行用来声明事件的标识符。\n- 类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。\n\n## 如何使用SSE\n\n### 服务端\n\n```javascript\nclass ServerSentEvents {\n  constructor(req, res) {\n    this.request = req;\n    this.response = res;\n    this.count = 0;\n\n    // 必须设置这个headers\n    res.writeHead(200, {\n      \"Content-Type\": \"text/event-stream\",\n      Connection: \"keep-alive\",\n      \"Cache-Control\": \"no-cache\",\n    });\n  }\n\n  /**\n   * 自定义事件--连接\n   */\n  connect() {\n    this.response.write(\"event: connected\\n\");\n    this.response.write(\"data: You are now subscribed\\n\");\n    this.response.write(`id: ${this.count}\\n\\n`);\n    this.count += 1;\n  }\n\n  /**\n   * 通用事件--消息\n   */\n  send(message) {\n    this.response.write(\"event: message\\n\");\n    this.response.write(`data: ${message}\\n`);\n    this.response.write(`id: ${this.count}\\n\\n`);\n    this.count += 1;\n  }\n\n  /**\n   * 关闭连接\n   */\n  close() {\n    this.response.end(\"OK\");\n  }\n}\n\n// router function\nfunction subscribe(req, res) {\n  const sse = new ServerSentEvents(req, res);\n\n  // Send a message on connection\n  sse.connect();\n\n  // Send a subsequent message every five seconds\n  setInterval(() => {\n    sse.send(new Date().toLocaleString());\n  }, 5000);\n\n  // Close the connection when the client disconnects\n  req.on(\"close\", () => sse.close());\n}\n```\n\n### 浏览器端\n\n```javascript\n/**\n * 警告：当不通过HTTP/2使用时，SSE（server-sent events）会受到最大连接数的限制，这在打开多个选项卡时特别麻烦，\n * 因为该限制时针对每个浏览器的，并且被设置为一个非常低的数字（6）。该问题在Chrome和Firefox中被标记为”不会解决“。\n * 此限制是针对每个浏览器+域的，因此这意味着你可以跨所有选项卡打开6个SSE连接到www.example1.com，并打开6个SSE连\n * 接到www.example2.com。\n * 使用HTTP/2时，同一时间内HTTP最大连接数由服务器和客户端之间协商（默认为100）。\n */\nconst subscription = new EventSource(\"/subscribe\");\n\n// Default Events\nsubscription.addEventListener(\"open\", () => {\n  writeMessage(\"Connection opened\");\n});\n\nsubscription.addEventListener(\"error\", (err) => {\n  writeError(err);\n});\n\nsubscription.addEventListener(\"message\", (event) => {\n  writeMessage(event.data);\n});\n\n// Define Custom Events\nsubscription.addEventListener(\"connected\", () => {\n  writeMessage(\"Subscription successful\");\n});\n\ndocument.getElementById(\"close-btn\").addEventListener(\n  \"click\",\n  () => {\n    subscription.close();\n    writeMessage(\"Subscription closed\");\n  },\n  false,\n);\n```\n\n这样SSE整套流程就已经完成了。相对于WebSocket，SSE对服务端非常友好，只需要很小的改动，就可以支持整套流程。\n\n## 小程序如何做兼容\n\n<img src={wxRequest.src} alt=\"wx.request\" width=\"600\" />\n\n我们看到虽然微信不支持完整的SSE，但是通过`enableChunked`属性我们可以实现流式数据接收。如果需要，通过我们合理的封装，完全可以实现绝大部分SSE功能。\n\n## SSE与WebSocket\n\n|                    | SSE  | WebSocket |\n| :----------------: | :--: | :-------: |\n| 是否支持服务端下发 |  是  |    是     |\n|  是否支持相互通信  |  否  |    是     |\n|  是否支持断线重连  |  是  |    否     |\n|  是否支持断点续传  |  是  |    否     |\n|   服务端接入成本   | 简单 |   复杂    |\n| 是否支持自定义事件 |  是  |    否     |\n\n\n## 增强版SSE\n\n浏览器原生的EventSource API在请求时存在诸多限制：\n\n- 仅支持 `GET` 请求，无法使用其他HTTP方法；\n- 不能传递请求体（body），需将所有信息编码到URL中，2️⃣URL长度通常限制在2000字符左右；\n- 无法自定义请求头；\n- 连接中断时，重试策略完全由浏览器控制（静默重试几次后停止），不适用于高可靠性应用。\n\n为此微软自研了一套基于Fetch API的增强型SSE -- [fetch-event-source](https://github.com/Azure/fetch-event-source)。它兼容标准事件流格式，同时解决了原生 API 的问题，提供了更多控制权：\n\n- 支持任意HTTP方法、自定义请求头和请求体，具备Fetch API的全部功能，甚至可替换默认的 `fetch` 实现；\n- 能访问响应对象，便于在解析事件前进行自定义验证（例如处理API网关的错误响应）；\n- 连接中断或出错时，可完全自定义重试策略；\n- 集成浏览器页面可见性 API：页面隐藏时自动关闭连接，重新可见时给予最后一个事件ID重试，减少服务器无效连接压力（可手动关闭此功能）。\n\n简而言之，这个库在保持服务器发送事件兼容性的同时，大幅提升了请求的灵活性、错误处理能力和资源优化能力。\n\n## 总结\n\n这就是SSE的基本功能与实现。SSE支持**自动重连**、**事件ID**和**自定义事件**的功能很大程度上减少了我们额外的开发工作。在我接触到的大部分场景下，它比WebSocket更适合，实现也更简单。如果你遇到这种需要异步处理的场景，可以优先考虑它。当然，如果你希望得到更强大的功能和更多的控制权，可以考虑微软推出的[fetch-event-source](https://github.com/Azure/fetch-event-source)作为企业级的解决方案。","src/content/blog/即时通信技术——SSE.mdx","9fdab71b539f2764","即时通信技术——SSE.mdx","vue源码解析之依赖收集和派发更新",{id:97,data:99,body:102,filePath:103,digest:104,legacyId:105,deferredRender:21},{title:100,description:15,pubDate:101,heroImage:15},"Vue源码解析之依赖收集和派发更新",["Date","2019-09-23T18:43:54.000Z"],"相信大家都知道，如今的前端开发主要是使用最流行的三大框架 Angular、React、Vue。尤其 React 无论在国内还是国外都深受前端开发者的喜爱，市场占有率可以说是相当的高。另外两大框架也是不甘落后，因其各自的特点，牢牢把握住了一部分忠实的粉丝。今天我们要说的是三大框架之中的 Vue 框架。\n\nVue 由于其渐进式的开发方式、完善的脚手架工具以及简单易懂的开发文档，深受一部分国人的喜爱。使用过 Vue 的都知道，在我们修改`data`中某个数据的时候，相关依赖的`watch`、`computed`、`renderer`都会随之更新，那 Vue 是如何做到的呢？今天我们就来讲讲 Vue 在这块的实现方式——响应式数据更新。\n\n关于这个黑科技般的动作，我们在 Vue 的实现方式中有两个专有的名词（**依赖收集**和**派发更新**）。\n\nVue 利用了 JavaScript 的原生方法`Object.defineProperty`实现响应式数据。这个方法可以重写对象属性的`get`和`set`动作，使我们能保证原来的行为不变的同时，添加额外的行为。Vue 就是利用对象属性的`get`来实现**收集依赖**，以及利用对象属性的`set`来实现**派发更新**的。\n\n本文主要讲解的是 Vue 响应式数据的设计思想，对于具体代码及具体的实现方案不会有特别详细的讲解。关于这些细则，你可以浏览网上一些讲源码的文章或者可以自行查阅源码。\n\n## 响应式数据的三个重要类\n\n在说**依赖收集**和**派发更新**之前，我们先说说跟这两个动作强相关的三个类。Vue 内部定义了`Observer`类、`Dep`类、`Watcher`类。\n\n- `Observer`是用来管理响应式对象的。所有的响应式对象都有一个特点，你可以在它的属性中找到`__ob__`属性。\n- `Dep`主要就是做依赖收集和派发更新的。响应式对象的每一个属性都会被对应的创建一个 Dep 实例，用于收集 Watcher 和触发 Watcher 的更新。\n- `Watcher`的作用则是创建一个监听器。当 Watcher 关联的数据发生改变时，Watcher 会进行相应的更新。\n\n## 依赖收集\n\n![响应式数据之getter](../../assets/images/reactive_getter.png)\n\n```javascript\nconst dep = new Dep()\n...\n\nObject.defineProperty(data, key, {\n  get() {\n    dep.depend()\n    ...\n  },\n  ...\n})\n```\n\n从图上我们可知，当视图或者 computed 等 Watcher 读取依赖的响应式属性时，属性对应的 Dep 实例会执行`depend`方法，收集当前的 Watcher，以便属性发生改变时能通知到相应的 Watcher 更新，这个过程就叫做**依赖收集**。\n\n举个栗子，比如上图中的`data`有一个属性`message`，当视图需要展示`message`的值时，`message`的`get`动作就会被触发。这时候执行`dep.depend()`就会将当前的`renderer watcher`添加到 message 对应的 Dep 实例的依赖项中。\n\n## 派发更新\n\n![响应式数据之setter](../../assets/images/reactive_setter.png)\n\n```javascript\nconst dep = new Dep()\n...\n\nObject.defineProperty(data, key, {\n  set() {\n    ...\n    dep.notify()\n  },\n  ...\n})\n```\n\n**派发更新**的动作也很简单，当响应式对象中的某个属性发生变化时，对应这个属性的 Dep 实例就会执行`notify`方法，之前收集的 Watcher 会被通知进入异步队列中执行。这个过程叫做**派发更新**。\n\n举个栗子，比如上图中的`data`有一个属性`message`，当`message`的值发生变化时，`message`的`set`动作就会被触发。这时候，依赖`message`的`renderer watcher`就会执行`update`操作，重新渲染 DOM 元素；`computed watcher`就会将`dirty`置为`true`，并在下一次读取时更新计算属性的值。\n\n## 总结\n\n这就是 Vue 响应式数据的设计思想。具体实现上 Vue 做了很多处理，既保证了功能的完整性，又兼顾了性能。\n\n在整个响应式设计上，最关键的就是三个类（`Observer`类、`Dep`类、`Watcher`类），两个方法（`observe`方法和`defineReactive`方法）。\n\n其中，`observe`方法主要做的就是实例化一个`Observer`，与响应式对象挂钩；`defineReactive`方法主要做的是实例化一个`Dep`类，与响应式对象的属性挂钩；而`Watcher`类主要用于视图、`computed`和`watch`。这样，整个响应式对象的基础框架算是搭建好了。然后利用`defineReactive`方法，实现了依赖收集和派发。而`observe`方法主要用于响应式对象的注册。整体的设计就是这样一种思路，如果想了解 Vue 的实现，可以参考这篇文章读 Vue 的源码，相信会对你有所帮助。","src/content/blog/Vue源码解析之依赖收集和派发更新.mdx","413e855027880fb6","Vue源码解析之依赖收集和派发更新.mdx","探索javascript运行机制",{id:106,data:108,body:111,filePath:112,digest:113,legacyId:114,deferredRender:21},{title:109,description:15,pubDate:110,heroImage:15},"探索JavaScript运行机制",["Date","2019-08-17T17:26:28.000Z"],"在阅读本文前，需要你的JavaScript语言基础比较扎实，并在日常工作中经常会使用到这门语言。\n\n进入正题，我们在执行JavaScript脚本时，经常会用到setTimeout、Promise等各种前端异步技术，那么你有没有考虑过JavaScript到底是怎样运行的呢？同样是异步技术，它们之间又有什么区别呢？在执行过程中，我们怎么确定哪个异步先执行，哪个异步后执行呢？今天，就让我们一起带着这些疑问来探究下前端开发中的异步技术和JavaScript的运行机制。\n\n我们知道，JavaScript的执行是单线程的，所以JavaScript并不能同时处理多个任务，那么这些任务就需要排队按插入顺序执行。那么什么是任务呢？主体代码相当于一个任务，各种异步代码也相当于一个任务。JavaScript实现异步的方式有很多种，但是归根结底可以将它们划分为两大类 —— 宏任务和微任务。有了宏任务和微任务，那就需要一个调度器，适时的执行宏任务和微任务，以及配合UI渲染，这个调度器我们称之为EventLoop。\n\n## 宏任务\n\n宏任务是存放在宏任务队列中的任务。在一轮任务周期中，宏任务队列只推出一个任务执行。\n\n- setTimeout\n- setInterval\n- setImmediate\n- I/O\n- UI Rendering\n\n注意：这里没有将**主体代码**作为宏任务，是因为在这个概念上，网上存在较多的争议。每个人的理解不一样，但这个概念对`我们理解JS是如何运行的`不会产生太大的影响，这里就不做定论了。\n\n## 微任务\n\n微任务是存放在微任务队列中的任务。在一轮任务周期中，微任务队列会依次推出任务执行，直到微任务队列中没有任务为止（即一轮任务周期完成）。\n\n- 原生Promise（部分第三方实现的Promise会被放入宏任务队列中）\n- process.nextTick()\n- Object.observe（已废弃）\n- MutationObserver\n- MessageChannel\n\n## 宏任务与微任务的区别\n\n浏览器在执行脚本的过程中，会把不同的任务放入不同的队列当中去。当执行的时候，浏览器首先会从宏任务队列中推出一个任务并执行。当执行完当前的宏任务之后，浏览器会从微任务队列中逐个运行所有的任务。我把这个称为一个任务周期，循环往复，浏览器会执行很多个这样的任务周期。\n\n通俗点讲，就像你去银行办理业务，因为处理业务的人比较多，你就需要取号排队，这个就是**宏任务队列**。终于轮到你了，你跟柜台说你需要办理存款业务，柜台帮你办理了；你又说，你要办理理财业务，柜台又帮你办理了，就这样，你可以一次性办理完所有你想要办理的业务而不需要重新排队，这就是**微任务队列**。\n\n从上面的例子，我们可以看到宏任务每次都只能执行一个任务，微任务会把当前队列中的所有任务都执行完成后再处理下一个宏任务。\n\n## 举个栗子\n\n说了这么多，我们不如直接来看栗子，加深我们的印象。\n\n```javascript\nconsole.log(1)\n\nsetTimeout(() => {\n    Promise.resolve(7).then(r => console.log(r))\n\n    console.log(2)\n})\n\nPromise.resolve(3).then(r => console.log(r))\n\nPromise.resolve(4).then(r => console.log(r))\n\nsetTimeout(() => {\n    console.log(5)\n\n    Promise.resolve(8).then(r => console.log(r))\n})\n\nconsole.log(6)\n```\n\n上面是一个观察浏览器宏任务和微任务的列子，你们觉得执行结果会是什么呢？\n\n![执行结果](../../assets/images/WX20190818-175457@2x.png)\n\n跟你想的一样吗？下面我来讲解下这段代码的执行过程吧！\n\n1. script标签引入的脚本是主体任务，先执行；\n2. 第一行代码是同步代码，所以直接执行并打印结果 `1`；\n3. 第三行代码遇到了setTimeout，setTimeout是宏任务，所以推入宏任务队列中，等待执行；\n4. 第九行代码遇到了Promise，Promise是微任务，所以推入微任务队列中，等待执行；\n5. 第十一行代码又遇到了Promise，推入微任务队列中，等待执行；\n6. 第十三行代码又遇到了setTimeout，推入宏任务队列中，等待执行；\n7. 第十九行代码是同步代码，直接执行并打印结果`6`。\n\n第一个任务执行结束了，现在宏任务队列中有2个任务，微任务队列中也有2个任务。下面浏览器会执行刚刚推入微任务队列中的所有任务。\n\n1. 第一个微任务是第九行代码创建的，执行并打印结果`3`。\n2. 第二个微任务是第十一行代码创建的，执行并打印结果`4`。\n\n就这样一个任务周期就结束了。我前面说过，现在宏任务中还有2个任务，所以我们继续下一个任务周期。\n\n**执行宏任务**\n\n1. 执行第一个setTimeout中的回调函数。\n2. 遇到Promise，推入微任务队列，等待执行。\n3. 遇到同步代码，直接执行并打印结果`2`。\n\n执行微任务\n\n1. 执行Promise的then方法，直接执行并打印结果`7`。\n\n**执行宏任务**\n\n1. 执行第2个setTimeout中的回调函数。\n2. 遇到同步代码，直接执行并打印结果`5`。\n3. 遇到Promise，推入微任务队列，等待执行。\n\n**执行微任务**\n\n1. 执行Promise的then方法，直接执行并打印结果`8`\n\n好了，执行结束，这就是所有异步任务的执行顺序。讲解之后是不是很清晰！","src/content/blog/探索JavaScript运行机制.mdx","fd1998dfac1a1fbe","探索JavaScript运行机制.mdx","发布属于你的npm包",{id:115,data:117,body:120,filePath:121,digest:122,legacyId:123,deferredRender:21},{title:118,description:15,pubDate:119,heroImage:15},"发布属于你的NPM包",["Date","2019-11-10T04:12:56.000Z"],"有没有尝试过向npm库中发布自己的包呢？今天我们就来讲讲npm的发布流程。\n\n## npm发布流程\n\n1. 开发完成你的代码，并提交到git仓库中。\n2. 执行`npm login`，登录你的npm账号。\n3. 执行`npm version <version tag>`，修改版本号。\n4. 执行`npm publish`，等待自动执行发布操作。\n\n这就是一套非常简单的npm包发布流程。这个流程非常简单，但是这样说可能并不能满足您的需要，下面我们就来详细讲解下一些细节部分。\n\n在这里，我就不讲解第一步了，我想使用过版本管理软件（git）的用户应该都会使用它。\n\n### npm login\n\n![npm login --help](../../assets/images/WX20191111-103947.png)\n\n从上图可知，`login`、`adduser`和`add-user`是同一个指令。`npm login`可以创建或者验证`<username>`在指定注册表命名的用户，然后将凭据保存到 **.npmrc** 文件中。使用指令`npm whoami`可以或者当前登录用户的`<username>`。\n\n当然，如果您之前已经登录过了可以忽略这一步，并不是每次发布都必须执行一次登录操作的。\n\n### npm version\n\n![npm version --help](../../assets/images/WX20191111-005253.png)\n\n通过执行`npm version --help`我们可以看到，我们可以使用`major`、`minor`、`patch`、`premarjor`、`preminor`、`prepatch`、`prerealease [--preid=<prerelease-id>]`、`from-git`和自定义的版本号来定义版本号。\n\n其中，`major`、`minor`、`patch`主要用于**正式版本**使用；`premarjor`、`preminor`、`prepatch`、`prerealease [--preid=<prerelease-id>]`主要用于**预发布版本**使用；`from-git`和自定义版本一般不会使用（说实话，`from-git`我从来没有使用过，也不清楚具体怎么使用，哈哈）。\n\n具体的版本规则我一再上一篇文章中详细讲解过了。如果还不清楚，请查看[语义化版本控制](.../../assets/images/1571711706800/README.md)。今天我们主要来讲讲`prerealease [--preid=<prerelease-id>]`的使用。\n\n一般来说，我们发布正式版本都是使用标准的语义化版本格式（X.Y.Z）。但是很多时候，由于我们需要做大的升级，测试可能无法完全覆盖到所有的问题（尤其是使用环境当中产生的问题）或者有些API可能会有改动，我们会先发布一个预发布版本，通过公测的手段收集用户在使用中遇到的问题，然后加以修改。预发布版本的好处是\n\n1. 我们不会影响已有应用的正常使用。\n2. 我们可以通过公测的手段保证新版本的稳定性，修复各种环境中产生的bug。\n3. 我们可以使用户提前熟悉新版本。\n\n我们可以执行指令`npm version prerelease`来发布新的预发版本。执行完后，我们可以看到版本号变成了`X.Y.Z-N`的形式，这就是最简单的预发布版本的格式。当然我们可以给它添加一个`preid`，执行指令`npm version prerelease --preid=alpha`，这时候我们看到版本号变成`X.Y.Z-alpha.N`的形式了。\n\n### npm publish\n\n![npm publish --help](../../assets/images/WX20191111-112230.png)\n\n下面讲讲我们本文的最重点`npm publish`。`npm publish`会自动执行发布操作，从图上可知，默认`publish`会被打上`latest`标签。如果您想发布预发布版本，可以自定义标签。比如，如果你想发布`next`版本的包，可以执行`npm publish --tag next`。当然如果您失误将预发布包的标签打成了`latest`也是可以挽救的，您可以执行`npm dist-tag add <pkg>@<version> [<tag>]`来修改标签。\n\n## 其他事项\n\n好了，发布的操作就是这么简单。下面我们来讲讲发布过程中可能遇到的问题，或者我觉得可以优化的点。\n\n### 登录失败问题\n\n有些时候，您可能已经输入了正确的账号、密码以及邮箱，但是返回的结果仍然是登录失败。这种情况有可能是因为您的registry地址有问题。在国内，由于访问速度的原因，我们往往会将库源设置为**淘宝镜像**，这时候我们有三种方式解决这类问题。\n\n第一种，我们可以通过指令`npm login --registry=https://registry.npmjs.org`的方式指定我们登录的地址。\n\n第二种，我们可以通过指令`npm config set registry https://registry.npmjs.org`的方式全局切换到npm源地址然后在执行`npm login`。\n\n第三种，我们可以通过指令`npm config delete registry`的方式删除用户配置的`registry`，然后在执行`npm login`。\n\n### 团队开发\n\n也许您发布的是一个类似`express`这样的大型框架。由于这样的项目需要一个完整的团队共同开发，所以您可以通过指令`npm owner  <user> [<@scope>/]<pkg>`来为这个包添加团队成员，保证团队中有多个人有权限发布项目。当然这样的方式并不安全，因为有高级权限的人越多，操作出问题的可能性就越大。所以我在这里非常推荐的方案是将发布权限集中在团队中较核心的一两个成员中，其他成员可以通过提交代码，待核心发布人员`code review`代码之后，发布代码。\n\n### 指定发布地址\n\n如果您经常在公司或者个人的npm库中发布项目，为了防止发布地址错误，您可以在`package.json`中添加以下配置\n\n``` json\n{\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org\"\n  }\n}\n```\n\n这样就不需要为平凡切换地址而烦恼了。\n\n### 指定发布的内容\n\n如果您的开发过程中，有一些测试内容或者个人的文件不想发布到npm库中去，有这几个方法可以帮到您\n\n方法一：在`package.json`中指定发布的文件或者目录。\n\n``` json\n{\n  \"files\": [\n    \"src\",\n    \"README.md\",\n    \"src/**/*.js\"\n  ]\n}\n```\n\n方法二：在根目录下创建`.npmignore`文件，它类似于`.gitignore`文件。其实没有`.npmignore`文件，npm会使用`.gitignore`文件来取代它的功能。需要注意的是，`.npmignore`不会覆盖`files`字段。\n\n#### 无法通过配置排除的文件\n\n- package.json\n- README.md\n- CHANGES/CHANGELOG/HISTORY\n- LICENSE/LICENCE\n- NOTICE\n- main字段中的文件\n\n#### 无法通过配置包含的文件\n\n- .git\n- CVS\n- .svn\n- .DS_Store\n- ._*\n- ...\n\n## 结论\n\n1. 使用`npm login`可以登录npm账号。\n2. 可以通过`npm version prerealease [--preid=<prerelease-id>]`来发布预发布版本。这个在使用者众多的包发布时非常重要，合理的使用可以展现出您在操作上的规范和发布时的谨慎。尤其是`--preid`的使用，可以告诉用户您对当前版本的定义，一般的值为`next`、`beta`。\n3. `npm publish`可以设置标签。即使粗心设置错标签，您也可以通过`npm dist-tag add <pkg>@<version> [<tag>]`修改标签。\n4. 规范的发布流程可以保证您发布的包的健壮性和可维护性，也是使用者信任的保障。","src/content/blog/发布属于你的NPM包.mdx","b6ac10b6021e9bad","发布属于你的NPM包.mdx","语义化版本控制",{id:124,data:126,body:128,filePath:129,digest:130,legacyId:131,deferredRender:21},{title:124,description:15,pubDate:127,heroImage:15},["Date","2019-10-22T02:35:06.000Z"],"我想大家都对版本号这个名词并不陌生。在软件开发高速发展的今天，我们可以看到每个软件都会有版本号。版本号标志着当前软件的更新状态，传达的是当前应用是否是最新状态。版本号本身并不复杂，如何让版本号之间存在关联，如何让用户根据版本号获悉当前应用的更新状态是我们今天要讲的主题。\n\n## 什么是语义化版本\n\n有发布和维护过npm包的同学都清楚，我们在每一次发布前都需要更新一下版本号。版本号一般都有一个标准的格式（X.Y.Z），那么我们在每次发布前应该更新哪一位数字呢？这其中就有一个语义化版本的概念。\n\n语义化版本有一个基本的版本格式：`主版本号.次版本号.修订号`。版本号的递增规则如下：\n\n1. **主版本号\\(major\\)**：当你做了不向下兼容的API时，修改`主版本号`。\n2. **次版本号\\(minor\\)**：当你做了向下兼容的API或者新增了API时，修改`次版本号`。\n3. **修订号\\(patch\\)**：当你做了向下兼容的问题修订时，修改`修订号`。\n\n这是最基本的版本号设置，一般用于正式版本的发布。而在现实生活中，我们为了满足项目在不同阶段的发布，我们会在此基础上做一定的延伸。\n\n我们经常看到一些重大框架正式发布前，都会先出些`alpha`和`beta`版本，这些都是**预发布版本\\(prerelease\\)**。由于版本升级影响较大，所以会做预发布来达到公测的目的。*对于这种版本，个人开发者可以在尝鲜项目中使用，商业项目开发过程中应严禁使用。由于其尚未稳定，很多未知的bug可能会影响到你的业务开发，甚至使你的项目在开发过程中进退两难*。\n\n## 为什么要遵守语义化版本\n\n在软件管理的领域里存在着被称为**依赖地狱**的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中\n\n在讨论为什么要遵守语义化版本前，我们先来说说什么时候我们需要发布新版本。\n\n1. 现有版本存在一个bug需要修复。\n2. 在现有版本的基础上需要添加新功能。\n3. 现有版本某些功能需要做调整。\n4. 现有版本需要做大改动，甚至涉及到对外API的修改，返回结果的变化，以及功能的大幅调整。\n\n通过上面列出来的几种情况，我们可以看到，有些发布只是在现有版本中做一些修补，有些发布会在现有版本基础上开放更多功能，还有些发布会导致新版本与老版本几乎完全不兼容。\n\n这些情况下，如果我们只是通过一个简单的**数字**或者**hash值**作为版本号将会出现一个问题，要不升级到最新版本（*需要针对新版本对当前项目中的代码做一定的调整，项目越大，需要调整的地方可能就越多越复杂*），要不完全不升级（*即使知道当前版本存在某些严重的bug*）。这个问题让我们在项目维护中陷入了两难的境地，为此我们束手无策。\n\n上面的问题确实非常棘手，但是如果我们遵从语义化版本控制，这样的问题就可以迎刃而解了。**语义化版本控制的作用是拆分问题，将问题进行归类，划分级别**。基本的归类方式分为三类问题。根据版本号从右往左看\n\n1. **补丁号**，进行现有功能的兼容性补丁，修复一些现有功能的bug。\n2. **次版本号**，进行向下兼容的修改或者添加新功能。\n3. **主版本号**，进行非向下兼容的更新。与现有版本的功能不兼容，或者返回结果发生了改变。\n\n使用语义化版本控制，我们可以更好地针对某一个版本进行小版本的修改和升级，而不会影响当前项目的运行。具体的**语义化版本规范**可以[查看这里](https://semver.org/lang/zh-CN/#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83semver)\n\n## 结论\n\n语义化版本控制可以使开发者更好地开发和维护软件，同时使用者同样可以在语义化版本控制中收益。在未知开发者具体开发的内容的情况下，使用者可以根据版本号判定是否可以安全升级当前版本。\n\n目前语义化版本控制已经广泛应用于前后端的包开发流程中。学习语义化版本控制既是一种知识思维的拓展，也是包开发中必不可少的一环。\n\n## 引用\n\n- [语义化版本官方文档](https://semver.org/)\n- [让你的版本号变得规则而有意义](https://www.bilibili.com/read/cv1643035/)","src/content/blog/语义化版本控制.mdx","59d30b3b834c0d7e","语义化版本控制.mdx","archive",["Map",134,135,143,144,153,154,161,162,169,170],"手写一个ajax请求",{id:134,data:136,body:139,filePath:140,digest:141,legacyId:142,deferredRender:21},{title:137,description:15,pubDate:138},"手写一个Ajax请求",["Date","2022-12-21T08:37:49.000Z"],"前面我们讲到了XMLHttpRequest的属性、方法和事件。也聊到了很多纯原生写法上需要注意的点，这是我们使用第三方库时常常忽略的。可是，说了再多也不如亲手试试，今天我们就来使用纯原生的方式写一个Ajax请求。\n\n首先说明，由于DOM 2级的扩展，Ajax请求监听方式多了很多方式，我们今天实现的是目前现代浏览器都能支持的方式，不考虑较早版本的兼容问题。所以这里我讲主要使用以下几个属性、方法和事件。\n\n### 属性\n\n- status\n- responseType\n- response\n- responseText\n- responseXML\n- responseURL\n- timeout\n\n### 方法\n\n- open\n- send\n- setRequestHeader\n- getRequestHeader\n- getAllResponseHeader\n- overrideMimeType\n\n### 事件\n\n- onloadstart\n- onload\n- onloadend\n- onerror\n- onabort\n- ontimeout\n\n## 第一步，创建一个XHR实例\n\n编写Ajax的第一步自然是需要创建一个XHR实例。\n\n```js\n// 创建一个xhr实例\nvar xhr = new XMLHttpRequest()\n```\n\n## 第二步，绑定XHR相关的事件\n\n为了尽可能的兼容所有浏览器，最好将事件绑定放在open方法之前。\n\n```js\nxhr.onloadstart = function () {\n  // 当数据开始下载的第一刻，触发该事件\n}\n\nxhr.onprogress = function() {\n  // 当数据开始下载时，反复触发该事件\n  // 由于TCP请求会造成切片分包发送的情况，每个分包下载完成时都会触发该事件\n  // 如果数据量较小，则不会存在切片分包情况，该事件将只会触发一次\n}\n\nxhr.onload = function () {\n  // 如果所有分片数据都接收完成，触发该事件\n}\n\nxhr.onloadend = function () {\n  // 请求完成时（无论成功还是失败），触发该事件\n}\n\nxhr.onerror = function () {\n  // 当请求发生错误时，触发该事件\n}\n\nxhr.onabort = function () {\n  // 当请求被主动取消时，触发该事件\n}\n\nxhr.ontimeout = function () {\n  // 如果xhr实例设置了timeout，且请求时间超过了timeout设置的超时时间，触发该事件\n}\n```\n\n## 第三步，准备请求\n\n调用open方法后，发送请求已经做好了准备，这时候随时可以执行发送操作\n\n```js\n// 包含三个参数：请求的方法、请求的url（可以是相对的，也可以是绝对的）、是否异步\nxhr.open('GET', 'https://w2.test.com/api/test/index', true)\n```\n\n## 第四步，设置额外配置\n\n在open方法执行之后，我们可以对xhr对象设置属性、添加请求头以及强制设置返回的Content-Type\n\n```js\n// 请求超过20秒未响应之后，执行超时操作\nxhr.timeout = 20000\n// 根据该属性可以帮助response属性正确解析响应内容\nxhr.responseType = \"blob\"\n// 可以向跨域请求发送Cookies、额外的请求头或者TLS客户端证书等信息\nxhr.withCredentials = true\n// 设置额外的请求头\nxhr.setRequestHeader('x-token', 'authorize-token')\n// 强制设定MIME，帮助浏览器更好地解析响应数据\nxhr.overrideMimeType('text/plain')\n```\n\n## 第五步，发送请求\n\n在这些操作全部完成之后，可以调用send方法发送请求。\n\n```js\n// 如果是POST请求，send方法的第一个参数为要发送的载荷\n// 如果是GET请求，第一个参数传null（为了兼容所有浏览器）\nxhr.send(null)\n```\n\n## 完整例子\n\n```js\nvar xhr = new XMLHttpRequest()\n\nxhr.onloadstart = function () {\n  // 当数据开始下载的第一刻，触发该事件\n}\n\nxhr.onprogress = function() {\n  // 当数据开始下载时，反复触发该事件\n  // 由于TCP请求会造成切片分包发送的情况，每个分包下载完成时都会触发该事件\n  // 如果数据量较小，则不会存在切片分包情况，该事件将只会触发一次\n}\n\nxhr.onload = function () {\n  // 如果所有分片数据都接收完成，触发该事件\n  // 在这里可以调用getAllResponseHeaders方法来获取请求头字符串\n  var headers = xhr.getAllResponseHeaders()\n  var arr = headers.trim().split(/[\\r\\n]+/);\n  var headerMap = {};\n\n  arr.forEach(function (line) {\n    var parts = line.split(': ');\n    var header = parts.shift();\n    var value = parts.join(': ');\n    headerMap[header] = value;\n  });\n}\n\nxhr.onloadend = function () {\n  // 请求完成时（无论成功还是失败），触发该事件\n}\n\nxhr.onerror = function () {\n  // 当请求发生错误时，触发该事件\n}\n\nxhr.onabort = function () {\n  // 当请求被主动取消时，触发该事件\n}\n\nxhr.ontimeout = function () {\n  // 如果xhr实例设置了timeout，且请求时间超过了timeout设置的超时时间，触发该事件\n}\n\nxhr.open('GET', 'https://w2.test.com/api/test/index', true)\nxhr.timeout = 20000\nxhr.responseType = \"blob\"\nxhr.withCredentials = true\nxhr.setRequestHeader('x-token', 'authorize-token')\nxhr.overrideMimeType('text/plain')\nxhr.send(null)\n```","src/content/archive/手写一个Ajax请求.mdx","68e256a3bb8e8c38","手写一个Ajax请求.mdx","xmlhttprequest的属性和方法",{id:143,data:145,body:149,filePath:150,digest:151,legacyId:152,deferredRender:21},{title:146,description:147,pubDate:148},"XMLHttpRequest的属性和方法","Ajax技术的出现是为了解决发送服务器请求额外数据而不刷新整张页面的问题，从而实现更好的用户体验。把Ajax技术推到历史舞台上的关键技术是XMLHttpRequest对象。最早由微软发明，然后被其他浏览器所借鉴。\n由于XMLHttpRequest对象本身非常难用，所以以往我们看到很多库实现了封装来帮助我们更好地使用它。为了了解更多XMLHttpRequest的细节，今天我们就来了解一下XMLHttpRequest的属性、方法和事件，帮助大家了解Ajax的底层能力。",["Date","2022-12-18T19:55:22.000Z"],"Ajax技术的出现是为了解决发送服务器请求额外数据而不刷新整张页面的问题，从而实现更好的用户体验。把Ajax技术推到历史舞台上的关键技术是XMLHttpRequest对象。最早由微软发明，然后被其他浏览器所借鉴。\n\n在Ajax技术出现之前，这种浏览器与服务器的通信早在1998年就通过不同方式实现了。最初JavaScript对服务器的请求可以通过中介（如Java小程序或Flash影片）来发送。后来XHR对象提供了原生的浏览器通信能力，减少了实现这个目的的工作量。\n\n由于XMLHttpRequest对象本身非常难用，所以以往我们看到很多库实现了封装来帮助我们更好地使用它。为了了解更多XMLHttpRequest的细节，今天我们就来了解一下XMLHttpRequest的属性、方法和事件，帮助大家了解Ajax的底层能力。\n\n```ts\ndeclare var XMLHttpRequest: {\n    prototype: XMLHttpRequest;\n    new(): XMLHttpRequest;\n    readonly DONE: number;\n    readonly HEADERS_RECEIVED: number;\n    readonly LOADING: number;\n    readonly OPENED: number;\n    readonly UNSENT: number;\n}\n```\n\n## 属性\n\n- [readyState](#readystate属性只读)\n- [status](#status属性只读)\n- [statusText](#statustext属性只读)\n- [responseType](#responsetype属性)\n- [response](#response属性只读)\n- [responseText](#responsetext属性只读)\n- [responseXML](#responsexml属性只读)\n- [responseURL](#responseurl属性只读)\n- [timeout](#timeout属性)\n- [upload](#upload属性只读)\n- [withCredentials](#withcredentials属性)\n\n### readyState属性（只读）\n\n该属性表示当前所处状态。\n\n| 值   | 状态             | 说明                                                                                                                   |\n| :--- | :--------------- | :--------------------------------------------------------------------------------------------------------------------- |\n| 0    | UNSENT           | 未初始化状态，XMLHttpRequest已被创建，但尚未调用open方法                                                               |\n| 1    | OPENED           | 发送状态，open方法已被触发，在这个状态中，可以通过`setRequestHeader`方法来设置请求的头部，可以通过`send`方法来发起请求 |\n| 2    | HEADERS_RECEIVED | 发送状态，send方法已被触发，响应头也已经被接收                                                                         |\n| 3    | LOADING          | 正在接收状态，响应体部分正在被接收                                                                                     |\n| 4    | DONE             | 接受完全状态，数据传输已经彻底完成或者失败                                                                             |\n\n\n```js\nvar xhr = new XMLHttpRequest();\nconsole.log('UNSENT', xhr.readyState); // readyState 为 0\n\nxhr.onprogress = function () {\n    console.log('LOADING', xhr.readyState); // readyState 为 3\n};\n\nxhr.onload = function () {\n    console.log('DONE', xhr.readyState); // readyState 为 4\n};\n\nxhr.open('GET', '/api', true);\nconsole.log('OPENED', xhr.readyState); // readyState 为 1\n\n// 在open方法和send方法之间执行setRequestHeader，以保证Header设置有效\nxhr.setRequestHeader('x-token', 'test_token');\n\nxhr.send(null);\n```\n\n### status属性（只读）\n\n返回XMLHttpRequest请求中由服务器返回的数字状态码。\n\n**注意**：\n1. 在请求完成前，状态码始终为0。\n2. 如果XMLHttpRequest出错，浏览器返回的状态码也为0。\n3. 如果请求正常执行，状态码与[标准的HTTP状态码](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)一致。\n\n```js\n/**\n * 输出如下：\n *\n * UNSENT（未发送）0\n * OPENED（已打开）0\n * LOADING（载入中）200\n * DONE（完成）200\n */\nvar xhr = new XMLHttpRequest();\nconsole.log('UNSENT', xhr.status); // status 为 0\n\nxhr.onprogress = function () {\n  console.log('LOADING', xhr.status); // status 为 200\n};\n\nxhr.onload = function () {\n  console.log('DONE', xhr.status); // status 为 200\n};\n\nxhr.open('GET', '/server', true);\nconsole.log('OPENED', xhr.status); // status 为 0\n\nxhr.send(null);\n```\n\n### statusText属性（只读）\n\n返回XMLHttpRequest请求中由服务器返回的字符串状态信息，这则信息中也包含了响应的数字状态码。不同于使用一个数字来指示的状态码，这个属性包含了返回状态对应的文本信息，例如“OK”或者“Not Found”。\n\n**注意**：\n1. 如果请求的状态`readyState`的值为`UNSENT`或者`OPENED`，则这个属性的值将会是一个空字符串。\n2. 如果服务器未明确指定一个状态文本信息，则`statusText`的值将会被默认赋值为\"OK\"。\n\n### responseType属性\n\n该属性是一个枚举字符串值，用于指定响应中包含的数据类型。它允许作者更改响应类型。\n\n可能得值：\n- \"\"：空的responseType字符串与默认类型\"text\"相同。\n- \"arraybuffer\"：response是一个包含二进制数据的[JavaScript ArrayBuffer](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer)。\n- \"blob\"：response是一个包含二进制数据的[Blob](https://developer.mozilla.org/zh-CN/docs/Web/API/Blob)对象。\n- \"document\"：response是一个HTML [Document](https://developer.mozilla.org/zh-CN/docs/Web/API/Document)或XML [XMLDocument](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLDocument)，根据接收到的数据的MIME类型而定。\n- \"json\"：response是通过将接收到的数据内容解析为[JSON](https://developer.mozilla.org/zh-CN/docs/Glossary/JSON)而创建的JavaScript对象。\n- \"text\"：response是DOMString对象的文本。\n\n### response属性（只读）\n\n当请求体响应时，该属性会接收到请求体返回的数据。具体类型取决于responseType的值。\n\n可能的响应类型有`ArrayBuffer`、`Blob`、`Document`、`DOMString`等\n\n### responseText属性（只读）\n\n当请求体响应时，该属性会接收到请求体返回的数据。\n\n### responseXML属性（只读）\n\n当请求体响应时，该属性返回一个包含请求检索的HTML或XML的Document。（根据`Content-Type`为`text/html`或者`application/xml`判断）\n\n**注意**：\n1. 如果请求未成功，尚未发送，或者检索的数据无法解析为XML或者HTML，则为null。\n2. 如果服务器没有明确指出`Content-Type`头，可以使用`overrideMimeType`方法强制`XMLHttpRequest`解析为XML。\n\n### responseURL属性（只读）\n\n当请求体响应时，返回序列化URL。\n\n**注意**：\n1. 如果URL为空，则返回空字符串。\n2. 如果URL有锚点，则位于`URL#`后面的内容会被删除。\n3. 如果URL有重定向，`responseURL`的值会是**经过多次重定向后**的最终URL。\n\n### timeout属性\n\n代表着一个请求在被自动终止前所消耗的毫秒数。默认为0，意味着没有超时。\n\n**注意**：\n1. 超时并不应该用在一个[全局文档环境](https://developer.mozilla.org/zh-CN/docs/Glossary/document_environment)中的**同步**XMLHttpRequest请求中，否则将会抛出一个`InvalidAccessError`类型的错误。\n2. 当超时发生时，timeout事件将被触发。\n\n```js\nvar xhr = new XMLHttpRequest();\n\nxhr.onload = function () {\n  // 请求完成。在此进行处理。\n};\nxhr.ontimeout = function (e) {\n  // XMLHttpRequest 超时。在此做某事。\n};\nxhr.open('GET', '/server', true);\nxhr.timeout = 2000; // 超时时间，单位是毫秒\nxhr.send(null);\n```\n\n### upload属性（只读）\n\n返回一个XMLHttpRequestUpload对象，用来表示上传的进度。这个对象时不透明的，但是作为一个[XMLHttpRequestEventTarget](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestEventTarget),可以通过对其绑定事件来追踪它的进度。\n\n可以被绑定在upload对象上的事件监听器如下：\n\n| 事件        | 相应属性的信息类型               |\n| :---------- | :------------------------------- |\n| onloadstart | 获取开始                         |\n| onprogress  | 数据传输进行中                   |\n| onabort     | 获取操作终止                     |\n| onerror     | 获取失败                         |\n| onload      | 获取成功                         |\n| ontimeout   | 获取操作在用户规定的时间内未完成 |\n| onloadend   | 获取完成（无论成功与否）         |\n\n```ts\ninterface XMLHttpRequestEventTarget extends EventTarget {\n    onabort: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onerror: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onload: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    ontimeout: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n\ninterface XMLHttpRequestUpload extends XMLHttpRequestEventTarget {\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n```\n\n### withCredentials属性\n\n该属性是一个布尔类型，它指示了是否该使用类似Cookies、Authorization Headers（头部授权）或者TLS客户端证书这类资格证书来创建一个跨站点访问控制（cross-siteAccess-Control）请求。\n\n**注意**：\n1. 在同一站点下使用`withCredentials`属性是无效的。\n2. 这个指示会被用做响应中Cookies被忽视的标识。默认是false。\n3. 不同域下的XMLHttpRequest响应，无论其`Access-Control-` Header设置什么值，都无法为它自身站点设置Cookie值（除非**请求之前**将`withCredentials`设置为`true`）。\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://example.com/', true);\nxhr.withCredentials = true; // 在发出请求之前设置为 true\nxhr.send(null);\n```\n\n## 方法\n\n- [open()](#open方法)\n- [send()](#send方法)\n- [getRequestHeader()](#getrequestheader方法)\n- [setRequestHeader()](#setrequestheader方法)\n- [getResponseHeaders()](#getallresponseheaders方法)\n- [overrideMimeType()](#overridemimetype方法)\n- [abort()](#abort方法)\n\n### open方法\n\n该方法接收三个参数：请求类型（GET、POST等）、请求的URL、是否异步。\n\n需要注意的是，URL是相对于代码所在的页面的，当然你也可以使用绝对URL。另外，调用open方法并不会实际发送请求，只是为发送请求做好准备。\n\n**注意**：请求默认情况下只能访问同源URL（域名相同、端口相同、协议相同）。如果请求的URL于发送请求的页面在任何方面有所不同，则会抛出安全错误。\n\n**注意**：由于同步的请求会阻塞JavaScript执行，所以一般情况下，我们不建议使用同步请求的方式。\n\n### send方法\n\n该方法接收一个参数：要发送的数据。如果不需要发送任何数据，则必须传null（因为该参数在某些浏览器中是必需的）。调用send方法后，请求就会发送到服务器。\n\n### getRequestHeader方法\n\n该方法接收一个参数：Header的名称。返回包含指定响应头文本的字符串。\n\n**注意**：\n1. 如果在返回的响应头中有多个一样的名称，那么返回的值就会是用逗号和空格将值分隔的字符串。该方法以UTF编码返回值。\n2. 搜索的报文名是不区分大小写的。\n3. 如果连接未完成（响应中不存在报文项或者被W3C限制），则返回null。\n\n### setRequestHeader方法\n\n设置HTTP请求头部的方法。\n\n**注意**：\n1. 该方法必须在`open`方法和`send`方法之间调用。\n2. 如果多次对同一个请求头赋值，只会生成**一个合并了多个值**的请求头。\n3. 如果没有设置[Accept](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept)属性，那么这个请求头会被默认设置为`*/*`。\n4. 安全起见，有些请求头的值只能由UserAgent设置：[禁止修改的标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_header_name)和[禁止修改的响应标头](https://developer.mozilla.org/zh-CN/docs/Glossary/Forbidden_response_header_name)。\n5. 自定义的header属性进行**跨域请求**时，可能会遇到\"not allowed by Access-Control-Allow-Headers in preflight response\"，你可能需要再你的服务器设置\"Access-Control-Allow-Headers\"。\n\n### getAllResponseHeaders方法\n\n返回所有的响应头，以[CRLF](https://developer.mozilla.org/zh-CN/docs/Glossary/CRLF)分割的字符串。如果没有收到任何响应，则返回`null`。\n\n**注意**：对于[复合请求](https://stackoverflow.com/questions/16958448/what-is-http-multipart-request)，这个方法返回的当前请求的头部，而不是最初的请求头的头部。\n\n```js\nvar request = new XMLHttpRequest();\n\n// 为了兼容所有浏览器，该事件处理函数必须放在open方法执行之前\nrequest.onreadystatechange = function() {\n  if(this.readyState == this.HEADERS_RECEIVED) {\n\n    // Get the raw header string\n    var headers = request.getAllResponseHeaders();\n\n    // Convert the header string into an array\n    // of individual headers\n    var arr = headers.trim().split(/[\\r\\n]+/);\n\n    // Create a map of header names to values\n    var headerMap = {};\n    arr.forEach(function (line) {\n      var parts = line.split(': ');\n      var header = parts.shift();\n      var value = parts.join(': ');\n      headerMap[header] = value;\n    });\n  }\n}\nrequest.open(\"GET\", \"foo.txt\", true);\nrequest.send();\n\n// Headers For Example\n// date: Fri, 08 Dec 2017 21:04:30 GMT\\r\\n\n// content-encoding: gzip\\r\\n\n// x-content-type-options: nosniff\\r\\n\n// server: meinheld/0.6.1\\r\\n\n// x-frame-options: DENY\\r\\n\n// content-type: text/html; charset=utf-8\\r\\n\n// connection: keep-alive\\r\\n\n// strict-transport-security: max-age=63072000\\r\\n\n// vary: Cookie, Accept-Encoding\\r\\n\n// content-length: 6502\\r\\n\n// x-xss-protection: 1; mode=block\\r\\n\n```\n\n### overrideMimeType方法\n\n该方法是指一个MIME类型用户替代服务器指定的类型，使服务端响应信息中传输的数据按照指定MIME类型处理。\n\n**注意**：\n1. 此方法必须在**send方法之前**调用方为有效。\n2. 如果服务器没有指定一个`Content-Type`头，MIME类型默认设置为`text/xml`。如果接受的数据不是有效的XML，将会出现“格式不正确”的错误。你能够通过调用`overrideMimeType`方法指定各种类型来避免这种情况。\n\n```js\n// Interpret the received data as plain text\n\nreq = new XMLHttpRequest();\nreq.overrideMimeType(\"text/plain\");\nreq.addEventListener(\"load\", callback, false);\nreq.open(\"get\", url);\nreq.send();\n```\n\n### abort方法\n\n如果请求已被发出，该方法可以终止请求。当一个请求被终止，它的readyState将被置为`XMLHttpRequest.UNSENT`（0），并且请求的`status`置为0。\n\n**注意**：如果请求已经达到服务器，服务器相关Controller方法并不会停止执行，只会造成执行结果无法返回，并且服务器会有报错提示。\n\n```js\nvar xhr = new XMLHttpRequest(),\n    method = \"GET\",\n    url = \"https://developer.mozilla.org/\";\nxhr.open(method, url, true);\n\nxhr.send();\n\nif (OH_NOES_WE_NEED_TO_CANCEL_RIGHT_NOW_OR_ELSE) {\n  xhr.abort();\n}\n```\n\n## 事件\n\n**事件响应顺序**：loadstart -> progress -> (error/abort/load) -> loadend\n\n```ts\ninterface XMLHttpRequestEventTargetEventMap {\n    \"abort\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"error\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"load\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"loadend\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"loadstart\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"progress\": ProgressEvent<XMLHttpRequestEventTarget>;\n    \"timeout\": ProgressEvent<XMLHttpRequestEventTarget>;\n}\n\ninterface XMLHttpRequestEventTarget extends EventTarget {\n    onabort: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onerror: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onload: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadend: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onloadstart: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    onprogress: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    ontimeout: ((this: XMLHttpRequest, ev: ProgressEvent) => any) | null;\n    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;\n    addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;\n    removeEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, options?: boolean | EventListenerOptions): void;\n    removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;\n}\n```\n\nXMLHttpRequest支持**DOM 0级事件处理机制**和**DOM 2级事件处理机制**。\n\n### DOM 0级事件\n\n- onloadstart\n- onload\n- onloadend\n- onprogress\n- onerror\n- onabort\n- ontimeout\n\n### DOM 2级事件\n\n- loadstart: 在接收到响应的第一个字节时触发\n- load: 在成功接收完成响应时触发\n- loadend: 在通信完成时，且在`error`、`abort`或者`load`**之后**触发\n- progress: 在接收响应期间**反复触发**\n- error: 在请求出错时触发\n- abort: 在调用`abort`方法终止连接时触发\n- timeout: 如果设置了`timeout`大于0ms，在响应超时时触发\n\n**注意**：为保证兼容性，所有事件都应在`open`方法执行之前添加好。\n\n## 跨源资源共享\n\n通过XHR进行Ajax通信的一个**主要限制**是**跨源安全策略**。这个安全限制是为了防止某些恶意行为。而跨源资源共享（CORS）定义了浏览器与服务器之间如何实现跨源通信。\n\n跨源资源共享的原理是通过HTTP头部信息，允许浏览器和服务器相互了解，以确实请求或响应应该成功还是失败。最基本的头部信息是`origin`字段。该字段包含发送请求的页面源（协议、域名和端口），以便服务器确定是否为其提供响应。\n\n为了安全起见，跨域XHR对象施加了一些额外限制：\n1. 不能使用`setRequestHeader`方法设置自定义头部。\n2. 不能发送和接收`Cookie`。\n3. `getAllResponseHeaders`方法始终返回空字符串。\n\nCORS通过一种叫**预检请求**的服务器验证机制。以下情况会触发预检机制：\n1. 自定义头部\n2. 除GET和POST之外的方法\n3. 不同请求体内容类型\n\n预检请求使用`OPTIONS`方法，并包含以下头部：\n- Origin：与简单请求相同。\n- Access-Control-Request-Method：请求希望使用的方法。\n- Access-Control-Request-Headers：（可选）要使用的自定义头部（逗号分隔的列表）。\n\n这个请求发送后，服务器可以确定是否允许这种类型的请求。在响应中，服务器会返回如下头部信息：\n- Access-Control-Allow-Origin：与简单请求相同。\n- Access-Control-Allow-Methods： 允许的方法（逗号分隔的列表）。\n- Access-Control-Allow-Headers：服务器允许的头部（逗号分隔的列表）。\n- Access-Control-Max-Age：缓存预检请求的秒数。\n\n上面说到了CORS请求默认情况下会存在一些限制，可以通过将`withCredentials`属性设置为`true`来表明请求会发送凭据（Cookie、HTTP认证和客户端SSL证书）。如果服务器允许带凭据的请求，那么可以在响应中包含如下HTTP头部：\n- Access-Control-Allow-Credentials: true\n\n如果发送了凭据请求而服务器返回的响应中没有这个头部，则浏览器不会把响应交给JavaScript（responseText为空，status是0，onerror被触发）。\n\n## 早期的跨域方案\n\n在没有CORS之前，开发者需要利用DOM特性发送跨域请求。\n\n- 图片探测\n- JSONP\n\n## 注意事项\n\n1. 对于HTTP请求状态的判断，请使用status而不是statusText，因为后者已经被证明在跨浏览器的情况下不可靠。\n2. 无论是什么响应内容类型，responseText属性始终都会保存响应体，而responseXML属性不一定。\n3. response属性会根据responseType来自动序列化数据。目前来看，兼容性不成问题，所以**推荐使用**。\n4. 为了保证跨浏览器兼容，`onreadystatechange`事件处理程序应该在`open`方法之前赋值。\n5. 为了保证请求头部被发送，`setRequestHeader`方法必须在`open`**方法之后**、`send`**方法之前**被调用。\n6. POST请求相比GET请求要占用更多的资源。从性能方面说，发送相同数量的数据，GET请求比POST请求要快两倍。\n7. `Content-Type`如果是`application/x-www-formurlencoded`，使用`URLSearchParams`来创建数据；如果是`multipart/form-data`，使用`FormData`来创建数据。\n\n## 参考\n\n- [【MDN】XMLHttpRequest](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest)\n- JavaScript高级程序设计","src/content/archive/XMLHttpRequest的属性和方法.mdx","9179507c3803b089","XMLHttpRequest的属性和方法.mdx","如何提一个好问题",{id:153,data:155,body:157,filePath:158,digest:159,legacyId:160,deferredRender:21},{title:153,description:15,pubDate:156,heroImage:15},["Date","2023-09-02T14:08:09.000Z"],"## 什么是好问题\n  \n1. 角度（话术）  发现问题、推进某件事情\n2. 业绩：成果（产出）、能力\n3. 问题：个人问题，团队问题\n4. 计划：创造某类环境\n5. 价值\n\n> 好的问题对于回答者来说，是一份厚礼\n\n## 提问前的准备\n\t\t\n1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n2. 尝试在Google或者百度等搜索引擎上搜索答案。\n3. 尝试阅读手册查找答案。\n4. 尝试阅读文档的常见问题（FAQ）查找答案。\n5. 尝试自己检查或者试验来找到答案。\n6. 向你身边的强者朋友打听来找到答案。\n7. 如果你是程序员，请尝试阅读源码来查找答案。\n\n> 好问题是是激励，是厚礼。  \n\n好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。不愿思考、或者发问前不做他们该做的事的人，是时间杀手。他们只是一味的索取，从不付出。无知没有关系，装白痴就是不行。机敏、有想法、善于观察、乐于主动参与解决问题。\n\n## 如何提问？\n\n1. 向专家求助之前，先阅读下常见问题文件（FAQ） ，思考下问题。\n2. 慎选提问的论坛\n\t- 在与主题不符的论坛上贴出你的问题。\n\t- 在探讨进阶技术问题的论坛上张贴非常初级的问题；反之亦然。\n\t- 在太多的不同新闻组上重复转帖同样的问题。\n\t- 向既非熟人也没有义务解决你问题的人发送私人邮件。\n3. 仔细、清楚地描述你的问题或 Bug 的症状。\n4. 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。\n5. 描述在提问前你是怎样去研究和理解这个问题的。\n6. 描述在提问前为确定问题而采取的诊断步骤。\n7. 描述最近做过什么可能相关的硬件或软件变更。\n8. 尽可能的提供一个可以重现这个问题的可控环境的方法。\n\n## 如何查找问题的解决方案？\n\n1. 尝试在你准备提问的论坛的旧文章中搜索答案。\n2. 尝试上网搜索以找到答案。\n3. 尝试阅读手册以找到答案。\n4. 尝试阅读常见问题文件（FAQ）以找到答案。\n5. 尝试自己检查或试验以找到答案。\n6. 向你身边的强者朋友打听以找到答案。\n7. 如果你是程序开发者，请尝试阅读源代码以找到答案。","src/content/archive/如何提一个好问题.mdx","8f74455a297fb7ea","如何提一个好问题.mdx","前端如何实现模糊搜索",{id:161,data:163,body:165,filePath:166,digest:167,legacyId:168,deferredRender:21},{title:161,description:15,pubDate:164},["Date","2019-11-20T15:17:07.000Z"],"模糊搜索大家在日常开发中应该经常接触。一般来说，模糊搜索多由后端完成。但是如果数据量只有几十条或者几百条，用后端进行模糊搜索明显会增加http请求的压力。这时候，前端模糊搜索就派上用场了。前端模糊搜索主要针对数据量相对较少，数据变动相对较小的结果。后端一次性返回所有数据，前端根据已有数据进行模糊搜索，并将最理想的结果返回给用户。\n\n前端模糊搜索的核心算法是**最短编辑距离算法**。什么是最短编辑距离？简单来说，最短编辑距离就是从字符串A变成字符串B需要进行几步操作。这其中涉及到了字符的`增`、`删`、`改`三种操作。下面我们来具体介绍下算法原理和实现。\n\n## 算法简介\n\n最短编辑距离算法，又叫Levenshitein距离算法。是由俄罗斯数学家`Vladimir Levenshtein`在1965年提出的。是指字符串A转换成字符串B所需的最少操作。其中包括的操作有：\n\n- 删除一个字符\n- 插入一个字符\n- 修改一个字符\n\n一般来说，两个字符串的编辑距离越短，则这两个字符越相似。如果两个字符串相等，则它们的编辑距离为0。不难看出，两个字符串的编辑距离肯定不会超过字符串的最大长度。\n\n## 创建动态规划方程\n\n最短编辑距离算法通过将两个字符串拆分成字符，然后进行逐一比较并获得相应的值，最终得到最短编辑距离，这里我们使用矩阵表示。下面我们来对矩阵进行分析，首先我们定义`[V0, H0]`为0，对应的行和列依次递增。生成的默认矩阵如下：\n\n|    |    | H0 | H1 | H2 | H3 | H4 | H5 | H6 | H7 |\n|----|----|----|----|----|----|----|----|----|----|\n|    |    | 0  | 质 | 量 | 保 | 证 | 金 | 总 | 额 |\n| V0 | 0  | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |\n| V1 | 固 | 1  |    |    |    |    |    |    |    |\n| V2 | 定 | 2  |    |    |    |    |    |    |    |\n| V3 | 租 | 3  |    |    |    |    |    |    |    |\n| V4 | 金 | 4  |    |    |    |    |    |    |    |\n| V5 | 总 | 5  |    |    |    |    |    |    |    |\n| V6 | 额 | 6  |    |    |    |    |    |    |    |\n\n下面我们来为空白处填充最短编辑距离（这里我们是要把**固定租金总额**转换成**质量保证金总额**）。首先，我们计算 **[V<sub>1</sub>, H<sub>1</sub>]** 的值，**V<sub>1</sub>** 对应的字符是 *固*，**V<sub>1</sub>** 对应的字符是 *质*，显然 **V<sub>1</sub> !== H<sub>1</sub>**，所以他们的变换需要做修改（`flag`为1）。这时候，我们通过`增`、`删`、`改`的操作，计算得到 **[V<sub>1</sub>, H<sub>0</sub>] + 1**、**[V<sub>0</sub>, H<sub>1</sub>] + 1**、**[V<sub>0</sub>, H<sub>0</sub>] + flag** 中的最小值就是当前字符的最短编辑距离，并填入 **[V<sub>1</sub>, H<sub>1</sub>]** 空白处。以此类推，计算出最终的 **[V<sub>n</sub>, H<sub>m</sub>]** 就是最短编辑距离。计算公式为 **min([V<sub>x</sub>, H<sub>y - 1</sub>] + 1, [V<sub>x - 1</sub>, H<sub>y</sub>] + 1, [V<sub>x - 1</sub>, H<sub>y - 1</sub>] + flag)**。\n\n1. `flag`的值与`Vx`和`Hy`的比较结果有关。如果`Vx === Hy`，`flag`为 **0**，否则`flag`为 **1**。\n2. `Vn`和`Hm`中的`n`和`m`指最后一个字符的坐标值。\n3. `Vx`和`Hy`中的`x`和`y`指当前正在计算的字符的坐标值。\n\n|    |    | H0 | H1 | H2 | H3 | H4 | H5 | H6 | H7 |\n|----|----|----|----|----|----|----|----|----|----|\n|    |    | 0  | 质 | 量 | 保 | 证 | 金 | 总 | 额 |\n| V0 | 0  | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |\n| V1 | 固 | 1  | 1  | 2  | 3  | 4  | 5  | 6  | 7  |\n| V2 | 定 | 2  | 2  | 2  | 3  | 4  | 5  | 6  | 7  |\n| V3 | 租 | 3  | 3  | 3  | 3  | 4  | 5  | 6  | 7  |\n| V4 | 金 | 4  | 4  | 4  | 4  | 4  | 4  | 5  | 6  |\n| V5 | 总 | 5  | 5  | 5  | 5  | 5  | 5  | 4  | 5  |\n| V6 | 额 | 6  | 6  | 6  | 6  | 6  | 6  | 5  | 4  |\n\n最终计算所得，上面的两个字符串的 **最短编辑距离为4**。\n\n从上面的分析，我们不难推导出动态规划方程：\n\n$$\n[Vn, Hm] = \\begin{cases}\n  0 &\\text x=0,y=0 \\\\\n  x &\\text x>0,y=0 \\\\\n  y &\\text x=0,y>0 \\\\\n  min([V\\text{\\scriptstyle x-1}, H\\text{\\scriptstyle y}] + 1, [V\\text{\\scriptstyle x}, H\\text{\\scriptstyle y-1}] + 1, [V\\text{\\scriptstyle x-1}, H\\text{\\scriptstyle y-1}] + flag) &\\text x>0,y>0 \\\\\n\\end{cases}\n\n\\star\n\nflag = \\begin{cases}\n  0 &\\text V\\text{\\scriptstyle x} = H\\text{\\scriptstyle y} \\\\\n  1 &\\text V\\text{\\scriptstyle x} \\ne H\\text{\\scriptstyle y} \\\\\n\\end{cases}\n$$\n\n## 代码实现与优化\n\n理解了理论知识，代码实现上其实非常简单。无非就是字符的比较，以及对字符的`增`、`删`、`改`操作，得到的矩阵最末尾的数字就是最短编辑距离。具体算法如下：\n\n``` javascript\n/**\n * 编辑距离算法(LD algorithm)\n * @param {string} source 输入的内容\n * @param {string} target 匹配的目标\n * @return {number}\n */\nfunction levensheinDistance (source, target) {\n  const sourceLength = source.length\n  const targetLength = target.length\n  const space = new Array(targetLength)\n\n  // 过滤目标或者比较值为空字符串的情况\n  if (sourceLength === 0) {\n    return targetLength\n  } else if (targetLength === 0) {\n    return sourceLength\n  } else {\n    for (let i = 0; i < sourceLength; i++) {\n      const sourceChar = source[i]\n      let temp = i\n\n      for (let j = 0; j < targetLength; j++) {\n        const targetChar = target[j]\n        // 获取前一个数值\n        const prevDistance = j === 0 ? i + 1 : space[j - 1]\n        // 获取上一个数值\n        const topDistance = space[j] === undefined ? j + 1 : space[j]\n        // 判断是否需要修改\n        const flag = sourceChar === targetChar ? 0 : 1\n        // 获取增，删，改和不变得到的最小值\n        const min = Math.min(prevDistance + 1, topDistance + 1, temp + flag)\n        // 保存左上角的数据，计算最小值时需要用到\n        temp = topDistance\n        space[j] = min\n      }\n    }\n\n    // 获取数组的最后一位，即编辑距离\n    return space[targetLength - 1]\n  }\n}\n```\n\n以上就是算法实现的全部内容。算法本身很简单，这里对空间复杂度做了优化，使用一维数组来表示矩阵。\n\n- `m`是指上面矩阵`Hm`中的`m`，这里代表的是`target.length`。\n- `n`是指上面矩阵`Vn`中的`n`，这里代表的是`source.length`。\n\n首先，我们创建了一个`m`长度的数组（`space`）。\n\n**内循环：**\n\n- `temp`保存的是 **[V<sub>x-1</sub>, H<sub>y-1</sub>]**。\n- `prevDistance`保存的是 **[V<sub>x-1</sub>, H<sub>y</sub>]**。\n- `topDistance`保存的是 **[V<sub>x</sub>, H<sub>y-1</sub>]**。\n\n1. 通过判断`sourceChar`与`targetChar`是否相同，得出结论`flag`的值。\n2. 计算到当前字符为止的最小编辑距离是多少。\n3. 将`topDistance`赋值给`temp`，因为在下一个循环中这个值将作为 **[V<sub>x-1</sub>, H<sub>y-1</sub>]** 出现。\n4. 更新 **[V<sub>x</sub>, H<sub>y</sub>]** 的值。\n5. 循环往复，直到两层遍历都完成为止。\n\n从这里我们可以看到，`space`是一个非常特殊的一维数组。它首先会保存 **V<sub>x-1</sub>** 层的最短编辑距离，在内循环不断执行过程中，**V<sub>x-1</sub>** 层的最短编辑距离会被 **V<sub>x</sub>** 层的最短编辑距离逐步替换。如此往复，当循环结束时，`space[target.length - 1]`即是 **[V<sub>x</sub>, H<sub>y</sub>]**。\n\n## 在模糊搜索中的应用\n\n讲到这里，我们已经实现了模糊搜索的核心部分。我们只需要获得 **相似度**【*distance / Math.max(A.length, B.length)*】，然后进行 **过滤**，**排序** 操作，即可实现比较完美的模糊搜索功能。\n\n由于相似度只跟最大字符长度和编辑距离有关，这样还是会存在期望的内容无法尽早的出现在前几位。**那搜索的结果是否还能更精确些呢？** 答案当然是肯定的。我认为因子越多，得到的模糊匹配的结果就越趋于期望结果。所以在模糊搜索中，我添加了`最大连续匹配长度`、`匹配个数`、`首个匹配字母位置`等因子，最后通过复杂的计算和权重的配比得到期望的结果。\n\n![中文匹配](../../assets/images/WX20191121-020426.png)\n\n![代码匹配](../../assets/images/WX20191121-020346.png)\n\n在代码实现上，需要在 **最短编辑距离算法** 中混入一些关键节点的计算，获得想要的因子。\n\n无论如何变化，模糊搜索的核心仍然是基于 **最短编辑距离算法** 完成的。您也可以根据您的想法，添加更多的因子，订制一套自己的模糊搜索。\n\n## 结论\n\n动手编写一个模糊搜索确实不算太难。只要掌握 **最短编辑距离算法** 的思想，围绕这个算法添加一些自己想要的因子，然后通过权重配置和复杂的计算公式得到相似度，最后过滤、排序、输出结果即可。无论如何，**最短编辑距离算法**才是模糊搜索的核心。\n\n## 题外话\n\n<a href=\"https://github.com/lihaizhong/CodeLabs/tree/main/packages/you-need-suggest\" target=\"_blank\">这里是我实现的模糊搜索方法</a>，您可以作为学习和参考。","src/content/archive/前端如何实现模糊搜索.mdx","3bf239ae5d9049ca","前端如何实现模糊搜索.mdx","新一代网络交互能力fetchapi",{id:169,data:171,body:174,filePath:175,digest:176,legacyId:177,deferredRender:21},{title:172,description:15,pubDate:173},"新一代网络交互能力——FetchAPI",["Date","2022-12-22T03:56:23.000Z"],"我们都知道原生了XMLHttpRequest是一个非常难用的API，不仅需要通过属性去判断请求当前所处的状态，还要按照一定的顺序规则去书写，保证写法能在所有浏览器都兼容，这大大提高了我们的心智负担。为了更好地使用XMLHttpRequest，有很多优秀的开源库也应运而生。开源库虽好，但毕竟会增大我们的静态资源包的大小。\n\n今天我要介绍的就是浏览器原生支持的新一代网络交互能力——FetchAPI。FetchAPI采用了全新的架构设计，支持的环境也更加丰富（除了主页面工作线程外，还包括了模块和工作线程，如WebWorker、ServiceWorker等场景）。同时，FetchAPI采用较现代的Promise接口方案，在使用上也更加方便。\n\n## 涉及的知识点\n\n- [FetchAPI](https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API)\n- [Headers](https://developer.mozilla.org/zh-CN/docs/Web/API/Headers)\n- [Request](https://developer.mozilla.org/zh-CN/docs/Web/API/Request)\n- [Response](https://developer.mozilla.org/zh-CN/docs/Web/API/Response)\n\n## FetchAPI与XMLHttpRequest的区别\n\nFetchAPI与XMLHttpRequest都是用于异步请求的工具。既然已经有了XMLHttpRequest，为什么还要出来一个原生的FetchAPI呢？今天我们就来讲讲他们之间的区别。\n\n|                          | FetchAPI | XMLHttpRequest |\n| :----------------------- | :------- | :------------- |\n| 使用难易度                     | 简单     | 复杂           |\n| 支持同步                 | 否       | 是             |\n| 支持异步                 | 是       | 是             |\n| 支持主页面线程中使用     | 是       | 是             |\n| 支持模块和工作线程中使用 | 是       | 否             |\n| 支持Promise              | 是       | 否             |\n| 支持事件监听             | 否       | 是             |\n| 支持跨域                 | 是       | 是             |\n| 支持取消请求             | 是       | 是             |\n| 支持超时                 | 否       | 是             |\n| 支持进度                 | 否       | 是             |\n\n**注意**：`超时功能`和`进度读取功能`虽然不是原生提供，但可以通过Fetch现有API实现。\n\n相比较而言，虽然在`超时`和`进度读取`这两项不常用的能力上，FetchAPI需要稍微费点神之外，FetchAPI的优点还是非常明显的，尤其在使用上尤为突出。FetchAPI采用Promise的方案，使得其操作方式更加现代，写法更加简洁，另外，FetchAPI除了能在主页面线程上能使用外，还能在类似WebWorker、ServiceWorker等环境中使用。\n\n## FetchAPI的使用\n\n## FetchAPI的核心\n\n## 如何实现超时功能和进度功能","src/content/archive/新一代网络交互能力——FetchAPI.mdx","697bef412364ca98","新一代网络交互能力——FetchAPI.mdx","interview",["Map",180,181,190,191,200,201,210,211,220,221,230,231,239,240,248,249,257,258,266,267,275,276,284,285,294,295,304,305,313,314,322,323,331,332,340,341,349,350,358,359,368,369,377,378,386,387,395,396,404,405,413,414,422,423,431,432,440,441,449,450,458,459,467,468,476,477,485,486,494,495,503,504,512,513,521,522],"vue-的响应式原理是什么请详细说明",{id:180,data:182,body:186,filePath:187,digest:188,legacyId:189,deferredRender:21},{title:183,category:184,pubDate:185,heroImage:15},"Vue 的响应式原理是什么？请详细说明","前端框架",["Date","2025-07-13T18:09:15.000Z"],"Vue 的响应式原理是指 Vue 在数据发生变化后，会自动更新视图。核心是通过数据劫持 + 依赖收集实现的。在 Vue 2 和 Vue 3 中，实现方式存在一定差异。\n\n## Vue 2 响应式\n\n- **数据劫持**：通过 `Object.defineProperty` 方法劫持对象属性的 `getter` 和 `setter`，当数据被访问时，会触发 `getter` 方法；当数据被修改时，会触发 `setter` 方法。\n- **依赖收集**：在 `getter` 方法中收集依赖（即使用该数据的组件或视图），将依赖存储在 `Dep` （依赖管理器）中。\n- **视图更新**：当数据发生变化时，`setter` 方法会被触发，`Dep` 会通知所有收集到的依赖进行更新，从而触发视图更新。\n\n不过 Vue 2 的响应式原理存在一些缺陷：无法监听对象属性的添加/删除，无法监听数组通过索引修改的元素或修改数组的长度，需要通过 `Vue.set` 或 `this.$set` 方法手动触发响应式。\n\n## Vue 3 响应式\n\n- **数据劫持**：通过 `Proxy` 代理整个数据对象（而非像 Vue 2 那样劫持单个属性），`Proxy` 可以拦截对象属性的读取、删除和修改等多种操作，解决了 Vue 2 的局限性。\n- **依赖收集**：在 `Proxy` 的 `get` 等拦截器中收集依赖，依赖仍由 `Dep` 管理，但 Vue 3 的 `effect` 函数实现了更灵活的依赖追踪。\n- **视图更新**：当数据变化时，`Proxy` 的 `set` 等拦截器被触发，`Dep` 通知依赖执行更新函数，完成视图更新。\n\nVue 3 的响应式原理不仅支持对象和数组的所有操作，还能监听 `Set` 和 `Map` 等数据结构，响应式能力更加全面。\n\n## 核心流程总结\n\n1. **初始化**：组件初始化时，Vue 会对 `data` 中的数据进行响应式处理。\n2. **依赖收集**：当模板渲染或计算属性使用数据时，触发 `getter` 或拦截器，将当前依赖加入到 `Dep` 。\n3. **数据更新**：数据被修改时，触发 `setter` 或拦截器，`Dep` 通知依赖执行更新函数，完成视图更新。\n\n这种机制让开发者无需手动操作 DOM，只需关注数据变化，极大提升了开发效率。","src/content/interview/Vue 的响应式原理是什么？请详细说明.mdx","f5a80fc5bcd43b38","Vue 的响应式原理是什么？请详细说明.mdx","什么是-generator-函数它的工作原理是什么在实际开发中有哪些应用场景",{id:190,data:192,body:196,filePath:197,digest:198,legacyId:199,deferredRender:21},{title:193,category:194,pubDate:195,heroImage:15},"什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景","JavaScript 深入理解",["Date","2025-07-13T07:46:33.000Z"],"Generator 函数是 ES6 中引入的一种特殊函数，通过 `function*` 语法定义，内部使用 `yield` 关键字暂停函数执行，配合 `next()` 方法恢复执行，能实现函数的分步执行和状态保存。\n\n## 工作原理\n\nGenerator 函数执行后不会立即运行函数体，而是返回一个迭代器对象（Iterator）。调用迭代器的 `next()` 方法时，函数开始执行，直到遇到 `yield` 关键字暂停，`yield` 后面的表达式值作为 `next()` 返回对象的 `value` 属性；再次调用 `next()`，函数从暂停处继续执行，直到下一个 `yield` 或函数结束，若函数结束则返回对象的 `done` 属性为 true。\n\n## 应用场景\n\n### 异步操作控制\n\n可将异步操作拆分为多个步骤，通过 `yield` 依次执行，使异步代码逻辑更清晰，累死 `async/await` 的早期替代方案。\n\n```js\nfunction* asyncTask() {\n  const result1 = yield fetch('url1');\n  const result2 = yield fetch('url2');\n  return result2;\n}\n```\n\n### 迭代器生成\n\n利用 Generator 函数的迭代特性，可便捷地创建自定义迭代器，用于遍历复杂数据结构。\n\n```js\nfunction* iterateData(data) {\n  for (let item of data) {\n    yield item;\n  }\n}\nconst iterator = iterateData([1, 2, 3]);\nconsole.log(iterator.next().value); // 1\n```\n\n### 状态机\n\n由于 Generator 函数能保存执行状态，适合实现具有多种状态切换的逻辑，如有限状态机。","src/content/interview/什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景.mdx","f65fc368636a1bcd","什么是 Generator 函数？它的工作原理是什么？在实际开发中有哪些应用场景.mdx","什么是-eslint它的作用是什么如何在项目中配置-eslint",{id:200,data:202,body:206,filePath:207,digest:208,legacyId:209,deferredRender:21},{title:203,category:204,pubDate:205,heroImage:15},"什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint","工程化与工具",["Date","2025-07-14T18:38:35.000Z"],"ESLint是一个开源的 JavaScript 代码检查工具，它通过预设的规则或自定义规则分析代码，识别并报告不符合规则的语法、风格或潜在错误，帮助开发者写出更规范、更健壮的代码。\n\n## 核心作用\n\n- **统一代码风格**：确保团队成员遵循一致的编码规范（如缩进、命名规则、引号类型等），减少因风格差异导致的协作成本。\n- **提前发现错误**：检测语法错误（如未声明的变量、函数参数不匹配）、逻辑隐患（如死循环、未使用的变量），在代码运行前规避问题。\n- **提升代码质量**：约束不良编程习惯（如全局变量滥用、回调地狱），促进写出可维护、高性能的代码。\n- **集成自动化流程**：可与 Git Hooks（如提交代码前）、CI/CD流程结合，阻止不符合规范的代码提交或部署。\n\n## 项目中配置 ESLint 的步骤（以 Vue/React 项目为例）\n\n### 1. 安装依赖\n\n首先在项目中安装 ESLint 及相关插件（根据项目类型选择）：\n\n```bash\n# 基础安装\nnpm install eslint -C\n\n# React 项目需额外安装\nnpm install eslint-plugin-react eslint-plugin-react-hooks -D\n\n# Vue 项目需额外安装（配合 Vue 3）\nnpm install eslint-plugin-vue @vue/eslint-config-prettier -D\n\n# TypeScript 项目需额外安装\nnpm install @typescript-eslint/parser @typescript-eslint/eslint-plugin -D\n```\n\n### 2. 初始化配置文件\n\n执行以下命令生成配置文件（`.eslintrc.js` 或 `.eslintrc.json`），根据提示选择项目类型、模块系统、框架等：\n\n```bash\nnpx eslint --init\n```\n\n配置文件核心内容包括：\n\n- `parser`：指定解析器（如 `@typescript-eslint/parser` 用于 TS）。\n- `extends`：继承预设规则集（如 `eslint:recommended`、 `plugin:react/recommended`）。\n- `plugins`：引入插件（如 `react`、`vue`）。\n- `rules`：自定义规则（值为 `off` 禁用、`error` 报错、`warn` 警告）\n\n示例（Vue项目的 `.eslintrc.js`）：\n\n```js\nmodule.exports = {\n  env: {\n    browser: true,\n    es2021: true,\n  },\n  extends: [\n    \"eslint:recommended\",\n    \"plugin:vue/vue3-essential\", // Vue 3核心规则\n    \"prettier\" // 与Prettier兼容（需配合eslint-config-prettier）\n  ],\n  parserOptions: {\n    ecmaVersion: \"latest\",\n    sourceType: \"module\",\n  },\n  plugins: [\"vue\"],\n  rules: {\n    \"no-console\": \"warn\", // 警告使用console\n    \"vue/multi-word-component-names\": \"off\", // 关闭Vue组件名必须多单词的规则\n    \"indent\": [\"error\", 2], // 强制2空格缩进\n  },\n};\n```\n\n### 3. 添加忽略文件（可选）\n\n创建 `.eslintignore` 文件，指定无需检查的文件/目录（如 `node_modules`、打包后的 `dist` 文件夹）\n\n```\nnode_modules/\ndist/\n*.min.js\n```\n\n### 4. 配置脚本命令\n\n在 `package.json` 中添加脚本，方便手动执行检查或修复：\n\n```json\n{\n  \"scripts\": {\n    \"lint\": \"eslint .\", // 检查所有文件\n    \"lint:fix\": \"eslint . --fix\" // 自动修复可修复的错误\n  }\n}\n```\n\n### 5. 集成开发工具\n\n在 VS Code 中安装 `ESLint` 插件，开启自动修复（`settings.json`）\n\n```json\n{\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.eslint\": true // 保存时自动修复 ESLint 问题\n  }\n}\n```\n\n### 6. 结合 Git Hooks\n\n通过 `husky` 在代码提交前自动执行 ESLint 检查，阻止不规范代码提交：\n\n```bash\n# 安装 husky\nnpm install husky -D\n# 初始化 husky\nnpx husky install\n# 添加 pre-commit 钩子\nnpx husky add .husky/pre-commit \"npx lint-staged\"\n```\n\n再配置 `lint-staged`（仅检查暂存区文件）\n\n```json\n// package.json\n{\n  \"lint-staged\": {\n    \"*.{js,jsx,vue,ts,tsx}\": \"eslint --fix\"\n  }\n}\n```\n\n通过以上配置，ESLint可在开发、提交、部署全流程中发挥作用，从源头保障代码质量和团队协作效率。实际使用中，可根据项目需求灵活调整规则，平衡规范严格性与开发效率。","src/content/interview/什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint.mdx","04db1e031a00acae","什么是 ESLint？它的作用是什么？如何在项目中配置 ESLint.mdx","什么是-javascript-的原型链请举例说明原型链的工作机制",{id:210,data:212,body:216,filePath:217,digest:218,legacyId:219,deferredRender:21},{title:213,category:214,pubDate:215,heroImage:15},"什么是 JavaScript 的原型链？请举例说明原型链的工作机制","基础概念",["Date","2025-07-10T18:00:53.000Z"],"在 JavaScript 中，所有对象都有一个原型（prototype），原型本身也是一个对象，而这个原型对象也有自己的原型，这样就形成了一条链式结构，**这就是原型链**。原型链的存在使得对象可以继承它的原型及其原型的原型上的属性和方法。\n\n## 原型链的工作机制\n\n原型链的工作机制主要体现在属性和方法的查找过程中：当访问一个对象的属性或方法时，JavaScript 会优先在 **其自身查找**，如果找到则直接使用；如果未找到，则会去 **该对象的原型中查找**；如果还是未找到，则会继续**向上查找**，直到找到或到达原型链的顶端（即 null）；如果仍然未找到，则返回 `undefined`。\n\n![prototype](../../assets/images/prototype.png)\n\n例如，我们创建一个构造函数 `Person`，并给其原型添加一个方法 `sayHello`：\n\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.sayHello = function sayHello() {\n  console.log(\"hello, my name is \" + this.name);\n};\n```\n\n然后通过这个构造函数创建一个实例对象 `person1`：\n\n```js\nconst person1 = new Person(\"Alice\");\n```\n\n当我们调用引擎 `person1.sayHello()` 时，JavaScript 引擎现在自身查找 `sayHello` 方法，没找到后，就去 `person1` 的原型上（即 `Person.prototype`）查找，在这里找到该方法，于是调用成功。\n\n再比如，`person1` 的原型 `Person.prototype` 的原型是 `Object.prototype`，`Object.prototype` 上有 `toString` 等方法。当我们调用 `person1.toString()` 时，在 `person1` 自身和 `person1.prototype` 上都没有找到 `toString` 方法，最终在 `Object.prototype` 上找到了该方法，于是调用成功。","src/content/interview/什么是 JavaScript 的原型链？请举例说明原型链的工作机制.mdx","3c00725fce22a021","什么是 JavaScript 的原型链？请举例说明原型链的工作机制.mdx","什么是-xss-和-csrf-攻击如何防范",{id:220,data:222,body:226,filePath:227,digest:228,legacyId:229,deferredRender:21},{title:223,category:224,pubDate:225,heroImage:15},"什么是 XSS 和 CSRF 攻击？如何防范","浏览器相关",["Date","2025-07-15T15:02:10.000Z"],"网络安全是前端开发的重要环节，XSS 和 CSRF 是两种常见的攻击方式，它们利用浏览器特性和用户信任进行恶意操作，需针对性防范。\n\n## 一、XSS 攻击（Cross-Site Scripting，跨站脚本攻击）\n\n### 定义\n\nXSS 攻击是指攻击者在网页中注入恶意 JavaScript 代码，当用户访问该页面时，恶意代码在用户浏览器中执行，从而窃取用户信息（如 Cookie、账号密码）、篡改页面内容或发起其他攻击。\n\n### 攻击原理\n\n1. 攻击者将恶意脚本（如 `<script>stealCookie()</script>`）注入到网页中 _（通常通过表单提交、URL参数等方式）_。\n2. 网页未对用户输入进行过滤，直接将恶意脚本渲染到页面中。\n3. 其他用户访问该页面时，恶意脚本被浏览器执行，导致信息泄漏或其他危害。\n\n### 常见场景\n\n- 评论区、论坛等用户可输入内容的区域，若未过滤 `<script>` 标签，可能被注入恶意代码。\n- URL 参数直接渲染到页面中（如 `http://example.com/?name=<script>...</script>`）,若未处理则触发 XSS 攻击。\n\n### 防范措施\n\n1. **输入过滤与输出编码**：\n\n- 对用户输入的内容进行严格过滤，移除或转义 `<script>`、`<img onerror>` 等危险标签和属性。\n- 输出到 HTML 时，将特殊字符（如 `<`、`>`、 `&`）转义为 HTML 实体（如 `&lt;`、`&gt;`、`&amp;`），避免浏览器解析为脚本。\n- 示例（JavaScript 转义）：`const safeHtml = text.replace(/</g, '&lt;').replace(/>/g, '&gt;')`。\n\n2. **使用 CSP（Content Security Policy，内容安全策略）**：\n\n- 通过 HTTP 响应头 `Content-Security-Policy` 限制资源加载来源，禁止执行内联脚本（`inline-script`）和未授权域名的脚本。\n- 示例：`Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com`（仅允许加载自身域名和 `trusted.com` 的脚本）。\n\n3. **设置 Cookie 的 HttpOnly 属性**：\n\n- 为 Cookie 添加 `HttpOnly` 属性，使其无法通过 JavaScript 的 `document.cookie` 访问，即使发生 XSS，攻击者也无法窃取 Cookie。\n- 示例（HTTP 响应头）：`Set-Cookie: sessionId=xxx; HttpOnly; Secure`。\n\n4. **避免使用 `eval()、`innerHTML` 等危险 API**：\n\n- `eval()` 会执行字符串作为代码，易被注入攻击；`innerHTML` 会直接解析 HTML，可能执行恶意脚本。\n- 有限使用 `textContent`（仅渲染文本）或安全的模版引擎（如 Vue、React 的模版系统，自动转义 HTML）。\n\n## 二、CSRF 攻击（Cross-Site Request Forgery，跨站请求伪造）\n\n### 定义\n\nCSRF 攻击时指攻击者诱导已登录用户在不知情的情况下，向被攻击网站发送恶意请求，利用用户的身份信息（如 Cookie）执行未授权操作（如转账、修改密码）。\n\n### 攻击原理\n\n1. 用户已登录目标网站 A（如银行网站），浏览器保存了网站A的登录 Coookie。\n2. 攻击者诱导用户访问恶意网站 B，网站 B中隐藏向网站 A发送请求的代码（如表单自动提交、图片请求）。\n3. 由于浏览器会自动携带网站 A 的 Cookie，网站 A 误认为是用户主动发起的请求，从而执行恶意操作（如转账给攻击者）。\n\n### 常见场景\n\n- 银行转账操作：恶意网站通过表单提交，利用用户的登录状态发起转账请求。\n- 账号设置修改：诱导用户访问恶意页面，自动发送修改邮箱或密码的请求。\n\n### 防范措施\n\n1. **验证请求来源（Referer/Origin）**：\n\n- 服务器检查请求头中的 `Referer` 或 `Origin` 字段，验证请求是否来自可信域名（如网站自身域名）。\n- 示例：仅允许 `Referer` 为 `https://example.com` 的请求执行敏感操作。\n\n2. **使用 CSRF Token（令牌）**：\n\n- 服务器为每个用户生成一个随机的 CSRF Token，存储在 Session 或 Cookie 中，并要求敏感请求（如表单提交）必须携带该 Token。\n- 攻击网站无法获取 Token，因此即使发送请求，服务器验证 Token 失败也会拒绝执行。\n- 示例：\n  - 前端表单中添加 `<input type=\"hidden\" name=\"csrfToken\" value=\"xxx\">`。\n  - 服务器接收请求时，对比请求中的 Token 与 Session 中的 Token 是否一致。\n\n3. **使用 SameSite Cookie 属性**：\n\n- 为 Cookie 设置 `SameSite=Strict` 或 `SameSite=Lax`，限制 Cookie 仅在同源请求中携带，阻止跨站请求携带 Cookie。\n- `SameSite=Strict`：完全禁止跨站请求携带 Cookie；`SameSite=Lax`：允许 GET 请求跨站携带 Cookie（如链接跳转），但禁止 POST 等请求。\n- 示例：`Set-Cookie: sessionId=xxx; SameSite=Strict`。\n\n4. **要求敏感操作二次验证**：\n\n- 对于转账、修改密码等高危操作，要求用户输入验证码、密码或进行其他身份验证，即使发生 CSRF，攻击者也无法完成操作。\n\n## XSS 与 CSRF 的核心区别\n\n| 维度     | XSS 攻击                           | CSRF 攻击                            |\n| -------- | ---------------------------------- | ------------------------------------ |\n| 攻击目标 | 利用用户对网站的信任，窃取用户信息 | 利用网站对用户的信息，执行未授权操作 |\n| 攻击方式 | 注入恶意脚本，在用户浏览器执行     | 诱导用户发送跨站请求，利用用户身份   |\n| 防御重点 | 过滤输入、限制脚本执行             | 验证请求来源、使用 Token             |\n\n通过上述措施，可有效降低 XSS 和 CSRF 攻击的风险，保障用户数据安全和网站正常运行。实际开发中，需结合业务场景选择合适的防御方案，多层次防护效果更佳。","src/content/interview/什么是 XSS 和 CSRF 攻击？如何防范.mdx","7b66443674a14342","什么是 XSS 和 CSRF 攻击？如何防范.mdx","什么是前端工程化它包含哪些方面的内容",{id:230,data:232,body:235,filePath:236,digest:237,legacyId:238,deferredRender:21},{title:233,category:204,pubDate:234,heroImage:15},"什么是前端工程化？它包含哪些方面的内容",["Date","2025-07-14T08:39:23.000Z"],"前端工程化是指将前端开发流程规范化、标准化，通过工具和技术手段解决开发效率、代码质量、协作流程等问题，使前端开发“碎片化”、“手工化”向“系统化”、“自动化”转变的过程。其核心目标是提高开发效率、保证代码质量、降低维护成本。让团队能更高效地开发和交付大型前端项目。\n\n## 前端工程化包含以下几个方面\n\n### 项目初始化和脚手架\n\n通过脚手架工具（如 vite、taro cli等）快速生成标准化的项目结构，包括预设的目录布局、配置文件、依赖管理等。避免重复搭建项目的繁琐工作，确保团队项目结构一致。\n\n### 模块化和组件化\n\n- **模块化**：将代码按功能拆分为独立模块（如 JS模块、CSS模块等），通过模块系统（如 ES Module、CommonJS）实现依赖管理和代码复用，避免全局变量污染，提高代码可维护性。\n- **组件话**：将 UI 界面拆分为独立可复用的组件（如 React组件、Vue组件），每个组件包含自身的结构、样式和逻辑，实现“一次开发，多处使用”，简化复杂界面的开发和维护。\n\n### 构建工具与自动化\n\n- **代码转换**：通过 Babel 将 ES6+ 语法转换为浏览器兼容的 ES5 语法；通过 PostCSS 处理 CSS（如自动添加浏览器前缀、转换CSS变量）。\n- **资源优化**：对 JS、CSS 等资源进行压缩（如 Terser 对 JS 进行压缩，CSSNano 对 CSS 进行压缩）、合并、Tree-Sharking（剔除未使用的代码），减少资源体积。\n- **自动化构建**：使用 Webpack、Vite、Rollup等构建工具，通过配置实现“一键构建”，自动完成代码转换、资源优化、打包输出等流程，代替手动操作。\n\n### 代码质量与规范\n\n- **代码规范**：通过 ESLint、StyleLint等工具强制遵循团队编码规范（如缩进、命名、语法错误等），避免代码风格混乱。\n- **代码审查**：结合 Git Hooks（如 husky）在代码提交前自动执行 lint 检查、单元测试，确保不符合规范的代码无法提交，减少代码缺陷。\n- **测试自动化**：通过 Jest、Mocha 等框架编写单元测试、集成测试，通过 Cypress、Playwright 等进行 E2E 测试，自动化验证代码功能，提前发现问题。\n\n### 版本控制与协作流程\n\n基于 Git 进行版本管理，制定分支策略（如 Git Flow、Github Flow），规范代码提交（如通过 commitlint 强制提交信息格式），确保团队协作有序，便于版本回溯和问题定位。\n\n### 部署与 CI/CD\n\n- **自动化部署**：通过 CI/CD 工具（如 Jenkins、GitHub Actions、GitLab CI）实现代码提交后自动构建、测试、部署到开发/测试/生产环境，避免手动部署的错误和时间成本。\n- **环境管理**：通过配置文件区分开发、测试、生产环境的变量（如 API地址），避免硬编码，实现环境隔离。\n\n### 监控与日志\n\n- **前端监控**：通过 Sentry、Fundebug 等工具监控线上代码错误、性能指标（如首屏页面加载时间、接口响应时间），及时发现和修复问题。\n- **日志收集**：收集用户行为日志、错误日志，为产品优化和问题排查提供数据支持。\n\n前端工程化不是单一工具或技术，而是一套涵盖 `开发 -> 构建 -> 测试 -> 部署 -> 监控` 全流程的解决方案，其核心是通过标准化和自动化提升团队效率和项目质量，尤其在大型前端项目和多人协作场景中不可或缺。","src/content/interview/什么是前端工程化？它包含哪些方面的内容.mdx","f8fb8ef5ccc8fb8f","什么是前端工程化？它包含哪些方面的内容.mdx","什么是回流和重绘如何减少回流和重绘",{id:239,data:241,body:244,filePath:245,digest:246,legacyId:247,deferredRender:21},{title:242,category:224,pubDate:243,heroImage:15},"什么是回流和重绘？如何减少回流和重绘",["Date","2025-07-15T04:33:52.000Z"],"## 回流（Reflow）\n\n回流也称为重排，是指浏览器为了重新计算元素的几何属性（如位置、尺寸、宽高、边距等），并重新构建渲染树的过程。当元素的几何属性发生变化时，浏览器需要重新遍历渲染树，计算每个受影响元素的新位置和大小，这个过程会消耗大量的计算资源。\n\n引发回流的常见操作包括：\n\n- 改变元素的宽高、边距、内边距等几何属性，如 `width: 200px;`\n- 改变元素的定位方式，如从 `static` 改为 `absolute` 或 `fixed`\n- 增加或删除 DOM 元素，导致渲染树结构发生变化\n- 浏览器窗口大小改变（`resize`事件）\n- 滚动页面，某些元素的位置需要重新计算\n- 读取或修改会触发浏览器即时布局的属性，如 `offsetWidth`、`scrollTop`、`getComputedStyle()` 等\n\n## 重绘（Repaint）\n\n重绘是指当元素的外观属性（如颜色、背景色、阴影等）发生变化，但几何属性未改变时，浏览器重新绘制元素外观的过程。此时元素的位置和大小没有变化，渲染树的结构也未改变，只是元素的视觉表现需要更新。\n\n引发重绘的常见操作包括：\n\n- 改变元素的颜色，如 `color: red;`\n- 改变元素的背景色，如 `background-color: #fff;`\n- 改变元素的阴影效果，如 `box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);`\n- 改变元素的透明度，如 `opacity: 0.5;`（在某些浏览器中，透明度变化可能触发回流）\n\n## 回流和重绘的关系及性能影响\n\n- 回流必然会导致重绘，因为元素的几何属性改变后，其外观也一定会发生变化，需要重新绘制。\n- 重绘不一定会引发回流，当仅元素的外观属性改变而几何属性不变时，只需要重绘即可。\n- 两者都会消耗浏览器性能，尤其是回流，由于涉及到大量的几何计算和渲染树重构，其性能消耗远大于重绘。在频繁操作下，可能会导致页面卡顿、响应变慢，影响用户体验。\n\n## 减少回流和重绘的方法\n\n### 1.集中修改样式\n\n避免频繁地单个修改元素的样式属性，而是通过一次性修改 `class` 或 `style` 属性来批量更新样式。例如：\n\n```js\n// 不好的做法：多次修改可能引发多次回流\nelement.style.width = '100px';\nelement.style.height = '100px';\nelement.style.margin = '10px';\n\n// 好的做法：一次修改，减少回流次数\nelement.className = 'new-style'; // 通过 class 批量应用样式\n// 或者\nelement.style.cssText = 'width: 100px; height: 100px; margin: 10px;';\n```\n\n### 2. 使用文档片段（DocumentFragment）\n\n当需要添加多个 DOM 元素时，先将元素添加到文档片段中，再将文档片段一次性添加到 DOM 树中，文档片段时存在于内存中的 DOM 节点容器。不会触发页面渲染，因此能减少回流次数。\n\n```js\nconst fragment = document.createDocumentFragment();\n\nfor (let i = 0; i < 10; i++) {\n  const div = document.createElement('div');\n  \n  div.textContext = `Item ${i}`;\n  fragment.appendChild(div);\n}\n\ndocument.body.appendChild(fragment);\n```\n\n### 3. 隐藏元素后操作\n\n先将元素设置为 `display: none;`，使其脱离渲染树，此时对元素进行的所有修改都不会引发回流和重绘，修改完成后再恢复显示。\n\n```js\nelement.style.display = 'none';\n// 进行一系列样式或 DOM 操作\nelement.style.width = '200px';\nelement.appendChild(newChild);\nelement.style.display = 'block'; // 仅触发一次回流\n```\n\n### 4. 使用绝对定位或固定定位\n\n将元素设置为 `position: absolute` 或 `fixed`，使元素脱离文档流，此时元素的变化不会影响其他元素的几何属性，从而减少回流的范围。适用于需要频繁修改位置或大小的元素，如动画元素。\n\n### 5. 避免触发即时布局\n\n浏览器为了优化性能，会将多次回流操作合并成一次执行。但如果在修改样式的过程中，读取了会触发即时布局的属性（如 `offsetWidth`、`scrollheight`、`getComputedStyle()`等），浏览器会强制立即执行之前的回流操作，以保证读取到正确的属性值。因此，应避免在修改样式的过程中频繁读取这些属性。\n\n```js\n// 不好的做法：触发多次即时回流\nfor (let i = 0; i < 10; i++) {\n  element.style.width = `${element.offsetWidth + 10}px`;\n}\n\n// 好的做法：先读取属性，再批量修改\nlet width = element.offsetWidth;\n\nfor (let i = 0; i < 10; i++) {\n  width += 10;\n}\n\nelement.style.width = `${width}px`; // 仅触发一次回流\n```\n\n### 6. 利用 CSS 硬件加速\n\n使用 `transform`、`opacity`、`filter` 等CSS属性时，浏览器会将元素放入独立的复合图层中，这些属性的变化只会触发合成操作，而不会引发回流或重绘，从而提升性能。\n\n```css\n.animate {\n  /* 仅触发合成，无回流和重绘 */\n  transform: translate(100px, 0);\n}\n```\n\n但需要注意的是，**不要过度**使用复合图层，因为每个复合图层都需要 **占用一定的内存资源**。\n\n### 7. 优化动画性能\n\n- 对于动画元素，尽量使用 `transform` 和 `opacity` 来实现动画效果，避免使用会触发回流的属性（如 `top`、`left`、`width`等）。\n- 可以将动画元素设置为 `will-change: transform;`，提示浏览器该元素可能会发生变换，提前进行优化准备，但同样不宜过度使用。\n\n通过采用上述措施，可以有效减少回流和重绘的次数及范围，提高页面的渲染性能，使页面更加流畅。","src/content/interview/什么是回流和重绘？如何减少回流和重绘.mdx","e99de769a134e3a7","什么是回流和重绘？如何减少回流和重绘.mdx","什么是异步编程javascript-中实现异步编程的方式有哪些请对比它们的优缺点",{id:248,data:250,body:253,filePath:254,digest:255,legacyId:256,deferredRender:21},{title:251,category:194,pubDate:252,heroImage:15},"什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点",["Date","2025-07-12T05:17:23.000Z"],"异步编程是指在程序执行过程中，当遇到耗时操作（如网络请求、文件读写、定时器等）时，不会阻塞后续代码的执行，而是继续执行其他任务，待耗时操作执行完成后再用特定方式通知并处理结果的编程方式。**其核心意义在于提高程序的执行效率，避免因等待耗时操作而造成的资源浪费。**\n\n## JavaScript 中实现异步编程的方式及其优缺点对比\n\n### 1. 回调函数（Callback）\n\n```js\nsetTimeout(() => {\n  console.log(\"异步操作完成！\");\n}, 1000);\n```\n\n- 原理：将一个函数作为参数传递给另一个函数，当异步操作完成后，调用该函数来处理结果。\n- 优点：实现简单，易于理解和使用。是最基础的异步编程方式。\n- 缺点：多层嵌套时，会形成“回调地狱”，代码可读性差，维护困难；无法使用 `try/catch` 捕获异常，错误处理不方便。\n\n### 2. Promise\n\n```js\nnew Promise((resolve) => {\n  setTimeout(() => {\n    resolve(\"异步操作完成！\");\n  }, 1000);\n})\n  .then((result) => {\n    console.log(result);\n  })\n  .catch((error) => {\n    console.error(error);\n  });\n```\n\n- 原理：通过构造函数创建一个对象，代表异步操作的最终完成成或失败，并提供 `then`、 `catch` 等方法处理结果或错误，支持链式调用。\n- 优点：解决了“回调地狱”的问题，代码结构清晰；支持错误捕获和链式操作，便于流程控制。\n- 缺点：无法中途取消；如果不设置 `catch` ，错误可能会被静默忽略；链式调用过长时，代码可读性仍有进一步提升空间。\n\n### 3. Generator 函数\n\n```js\nfunction* asyncGenerator() {\n  yield new Promise((resolve) => setTimeout(() => resolve(1), 1000));\n\n  yield new Promise((resolve) => setTimeout(() => resolve(2), 1000));\n}\n\nconst generator = asyncGenerator();\n\ngenerator\n  .next()\n  .value.then((result) => {\n    console.log(result); // 1\n\n    return generator.next().value;\n  })\n  .then((result) => {\n    console.log(result); // 2\n  });\n```\n\n- 原理：通过 `function*` 定义，使用 `yield` 关键字暂停函数执行，`next()` 方法恢复执行，可以配合 `yield` 处理异步任务，实现分步执行。\n- 优点：可以控制异步操作的执行顺序，手动暂停和恢复；能在异步过程中返回中间结果。\n- 缺点：使用方式相对复杂，需要手动调用 `next()`；流程管理不够直观，可读性不如 `async/await`。\n\n### 4. async/await\n\n```js\nasync function asyncFunction() {\n  try {\n    const result = await new Promise((resolve) =>\n      setTimeout(() => resolve(\"异步操作完成！\"), 1000),\n    );\n    console.log(result);\n  } catch (error) {\n    console.error(error);\n  }\n}\n```\n\n- 原理：基于 `Promise` 的语法糖，`async` 关键字声明异步函数，`await` 关键字用于等待 `Promise` 对象的结果，使异步代码看起来像同步代码。\n- 优点：代码结构清晰，可读性强，接近同步代码的写法；支持 `try/catch` 捕获错误，错误处理方便；能直观地控制异步处理顺序。\n- 缺点：`await` 只能在异步函数中使用；对于多个并行的异步操作，必须使用 `Promise.all()` 等方法来处理，否则可能导致性能问题。\n\n### 5. EventEmitter\n\n```js\nconst EventEmitter = require(\"events\");\nconst emitter = new EventEmitter();\n\nemitter.on(\"done\", (result) => {\n  console.log(result);\n});\n\nsetTimeout(() => {\n  emitter.emit(\"done\", \"异步操作完成！\");\n}, 1000);\n```\n\n- 原理：通过发布-订阅模式，异步操作完成后触发特定事件，通过监听该事件处理结果。\n- 优点：适合多对多的异步通信场景，一个事件可以被多个监听器处理。\n- 缺点：事件名称容易冲突，流程追踪困难，不易调试；多个事件存在复杂关系时，管理难度大。","src/content/interview/什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点.mdx","9daf0bfae8932a5d","什么是异步编程？JavaScript 中实现异步编程的方式有哪些？请对比它们的优缺点.mdx","什么是跨域产生跨域的原因是什么如何解决跨域问题",{id:257,data:259,body:262,filePath:263,digest:264,legacyId:265,deferredRender:21},{title:260,category:224,pubDate:261,heroImage:15},"什么是跨域？产生跨域的原因是什么？如何解决跨域问题",["Date","2025-07-15T13:58:43.000Z"],"## 什么是跨域？\n\n跨域是指浏览器从一个域名的网页去请求另一个域名的资源时，由于浏览器的 **同源策略** 限制而产生的限制。这里的“域”由 **协议**、**域名**、**端口** 三部分组成，只要三者中有任何一个不同，就会被视为 **跨域**。\n\n- `http://www.example.com` 与 `https://www.example.com`（协议不同） -> 跨域\n- `http://www.example.com` 与 `http://api.example.com` （域名不同） -> 跨域\n- `http://www.example.com:8080` 与 `http://www.example.com` （端口不同） -> 跨域\n\n## 产生跨域的原因：同源策略\n\n**同源策略**是浏览器的一种安全机制，目的是防止不同域名的网页之间进行恶意数据交互，保护用户信息安全。其核心限制包括：\n\n- 禁止跨域读取 Cookie、LocalStorage、SessionStorage 等本地存储。\n- 禁止跨域操作 DOM （如 iframe 嵌套的跨域页面）。\n- 禁止跨域发现 AJAX/Fetch 请求（即本文重点解决的跨域问题）。\n\n正式由于同源策略的存在，当前端页面与后端接口的域名、协议或端口不一致时，就会出现跨域请求被拦截的问题。\n\n## 跨域问题的解决方法\n\n根据场景不同，跨域问题有多种解决方案，以下是常用方法：\n\n### 1. 服务端设置 CORS （Cross-Origin Resource Sharing，跨域资源共享）\n\n这是最推荐的解决方案，通过服务器在响应头中设置允许跨域的规则，明确告知浏览器允许哪些域名的请求。\n\n#### 原理\n\n浏览器在发送跨域请求时，会先发送一个“预检请求”（OPTIONS方法），询问服务器是否允许跨域。服务器通过响应头 `Access-Control-Allow-*` 告知允许的范围，浏览器根据响应决定是否继续发送实际请求。\n\n#### 常用响应头设置\n\n- `Access-Control-Allow-Origin: http://www.client.com` -> 允许指定域名跨域（* 表示允许所有域名，不推荐生产环境使用）。\n- `Access-Control-Allow-Methods: GET, POST, PUT, DELETE` -> 允许的 HTTP 方法。\n- `Access-Control-Allow-Headers: Content-Type, Authorization` -> 允许的请求头。\n- `Access-Control-Allow-Credentials: true` -> 允许跨域请求携带 Cookie（此时 `Access-Control-Allow-Origin` 不能为 `*`，需指定具体域名）。\n\n**适用场景**：前后端分离项目，后端接口可自主配置（如 Java、Node.js等后端服务）。\n\n### 2. 代理服务器（前端代理）\n\n通过前端工程化工具（如 Webpack、Vite）配置代理，将跨域请求转发为同源请求，避开浏览器的同源策略限制。\n\n#### 原理\n\n开发环境中，前端启动的本地服务器（如 `http://localhost:3000`）与后端接口（如 `http://api.server.com`）跨域时，可配置代理规则：当前端请求 `/api/data` 时，代理服务器自动转发到 `http://api.server.com/api/data`。由于代理服务器与前端页面同源（均为 `localhost:3000`），因此不会触发跨域限制。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  devServer: {\n    proxy: {\n      '/api': {\n        target: 'http://api.server.com', // 目标接口域名\n        changeOrigin: true, // 允许跨域\n        pathRewrite: {\n          '^/api': ''\n        } // 去除请求路径中的 /api 前缀（可选）\n      }\n    }\n  }\n}\n```\n\n**适用场景**：开发环境下的跨域调试，无需修改后端代码。\n\n### 3. JSONP（JSON with Padding）\n\n这是一种古老的跨域方案，利用 `<script>` 标签不受同源策略限制的特性实现跨域请求。\n\n#### 原理\n\n- 前端定义一个回调函数（如 `handleData`），用于接收后端返回的数据。\n- 前端动态创建 `<script>` 标签，`src` 指向后端接口，并在 URL 中携带回调函数名（如 `http://api.server.com/data?callback=handleData`）。\n- 后端接收到请求后，将数据包裹在回调函数中返回（如 `handleData({ name: 'xxx' })`）。\n- 前端 `<script>` 标签加载后，自动执行回调函数，获取数据。\n\n```js\n// 前端\nfunction handleData(data) {\n  console.log('跨域', data);\n}\n\nconst script = document.createElement('script');\n\nscript.src = 'http://api.server.com/data?callback=handleData';\ndocument.body.appendChild(script);\n\n// 后端\napp.get('/data', (req, res) => {\n  const data = { name: '跨域数据' };\n  const callback = req.query.callback;\n  \n  res.send(`${callback}(${JSON.stringify(data)})`); // 返回回调函数包裹的数据\n});\n```\n\n#### 局限性\n\n- 仅支持 GET 请求，不支持 POST、PUT 等方法。\n- 安全性低，可能遭受 XSS 攻击（需后端严格过滤数据）。\n\n**适用场景**：老旧系统兼容，或无法使用 CORS 的场景。\n\n### 4. iframe + 跨域通信 API\n\n当需要在两个跨域的 iframe 页面之间通信时，可使用 `postMessage` API。\n\n#### 原理\n\n- 发送方通过 `window.postMessage(data, targetOrigin)` 向目标窗口发送数据，`targetOrigin` 指定允许接收的域名（`*` 表示允许所有）。\n- 接收方通过监听 `message` 事件（`window.addEventListener('message', (e) => { ... })`）接收数据，并验证发送方的域名是否可信（e.origin）。\n\n```js\n// 父页面（http://parent.com）向子 iframe（http://child.com）发送数据\nconst iframe = document.getElementById('childIframe');\n\niframe.contentWindow.postMessage({ type: 'hello' }, 'http://child.com');\n\n// 子 iframe 页面接收数据\nwindow.addEventListener('message', (e) => {\n  // 验证发送方域名\n  if (e.origin === 'http://parent.com') {\n    console.log('接收数据：', e.data);\n  }\n});\n```\n\n**适用场景**：iframe 嵌套跨域页面的通信（如第三方登录、嵌入第三方组件）。\n\n### 5. 其他方法\n\n- **Nginx 反向代理**：通过 Nginx 服务器配置跨域转发，将客户端请求代理到后端接口，本质与前端代理类似，但适用于生产环境。\n- **WebSocket**：WebSocket 协议本身不限制跨域，可通过 `ws://` 或 `wss://` 协议实现跨域实时通信（如聊天应用）。\n\n## 总结\n\n- **首选方案**：服务器端配置 CORS（简单、安全、支持所有 HTTP 方法）。\n- **开发环境**：使用 Webpack/Vite 代理（无需后端配合，方便调试）。\n- **特殊场景**：JSONP（仅 GET 请求）、postMessage（iframe 通信）、Nginx代理（生产环境部署）。\n\n选择方案时需结合项目实际（如前后端控制权、请求类型、安全性要求），有限使用标准且安全的 CORS 方案。","src/content/interview/什么是跨域？产生跨域的原因是什么？如何解决跨域问题.mdx","82ccb2150441a08c","什么是跨域？产生跨域的原因是什么？如何解决跨域问题.mdx","介绍-webpack-的工作原理以及如何通过-webpack-进行代码分割和懒加载",{id:266,data:268,body:271,filePath:272,digest:273,legacyId:274,deferredRender:21},{title:269,category:204,pubDate:270,heroImage:15},"介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载",["Date","2025-07-14T14:33:05.000Z"],"## Webpack 工作原理\n\nWebpack 是一个现代 JavaScript 应用的静态模块打包工具，其核心思想是“一切皆模块”，通过递归解析项目中所有模块的依赖关系，最终将这些模块打包成一个或多个静态资源（bundle）。\n\n### 工作流程主要包括\n\n1. **入口（Entry）**：Webpack 以 `entry` 配置指定的文件为起点，递归解析其依赖的所有模块（如 JS、CSS、图片等）。\n2. **模块解析（Module Resolution）**：根据 `resolve` 配置解析模块路径，找到对应的文件（如处理 `import './utils'`时，自动查找 `utils.js`、`utils/index.js`等）。\n3. **模块转换（Module Transformation）**：通过 `module.rules` 配置的 Loader 对不同类型的模块进行转换（如用 `babel-loader` 将 ES6+ 转换为 ES5，用 `css-loader` 处理 CSS 模块，用 `url-loader` 处理图片）。\n4. **依赖图谱构建（Dependency Graph）**：在解析和转换过程中，Webpack会构建一个包含所有模块及依赖关系的依赖图谱。\n5. **代码优化与chunk生成**：根据 `optimization` 配置进行优化（如 Tree-Shaking 剔除未使用代码、代码压缩），并将依赖图谱中的模块按规则拆分为多个 `chunk`(代码块)。\n6. **输出（Output）**：最后通过 `output` 配置将 `chunk` 输出到指定目录（如 `dist` 文件夹），生成可在浏览器运行的静态资源。\n\n## 代码分割（Code Splitting）\n\n代码分割时将代码拆分为多个独立的 `chunk`，实现按需加载或并行加载，减少单个 bundle 体积，提升加载速度。Webpack实现代码分割的方式有：\n\n### 1. 多入口分割\n\n通过 `entry` 配置多个入口，每个入口生成一个独立 bundle。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  entry: {\n    home: './src/home.js',\n    about: './src/about.js'\n  },\n  output: {\n    filename: '[name].bundle.js', // 输出home.bundle.js, about.bundle.js\n    path: path.resolve(__dirname, 'dist')\n  }\n};\n```\n\n### 2. 公共代码分割\n\n通过 `splitChunks` 提取多入口或模块间的公共依赖（如 React、Vue 等库），避免重复打包。\n\n```js\n// webpack.config.js\nmodule.exports = {\n  optimization: {\n    splitChunks: {\n      chunks: 'all', // 对所有类型的 chunk（入口chunk、异步chunk）生效\n      cacheGroups: {\n        // 提取第三方库\n        vendor: {\n          test: /[\\\\/]node_modules[\\\\/]/,\n          name: 'vendors',\n          chunks: 'all'\n        },\n        // 提取公共模块\n        common: {\n          minChunks: 2, // 模块至少被引用两次才提取\n          name: 'common',\n          chunks: 'all'\n        }\n      }\n    }\n  }\n};\n```\n\n### 3. 动态导入分割\n\n通过 ES6 的 `import()` 语法动态导入模块，Webpack 会自动将其拆分为独立 chunk，实现按需加载（配合懒加载使用）。\n\n## 懒加载（Lazy Loading）\n\nWebpack 的懒加载依赖动态导入（`import()`），通过将非首屏必要的模块拆分为独立chunk，在用户需要时（如点击按钮、路由切换）再加载，减少首屏加载时间。\n\n### 1. 路由懒加载（以 React Router 为例）\n\n- `React.lazy` 接收一个返回 `import()` 的函数，`import()` 返回 Promise，加载成功后返回组件。\n- `<Suspense>` 用于在懒加载组件加载完成前显示占用内容（如加载动画）。\n\n```js\n// 不使用懒加载（一次性加载所有路由组件）\nimport Home from './pages/Home';\nimport About from './pages/About';\n\n// 使用懒加载（Webpack自动拆分Home、About为独立chunk）\nconst Home = React.lazy(() => import('./pages/Home'));\nconst About = React.lazy(() => import('./pages/About'));\n\n// 路由配置\n<Route path=\"/home\" element={<Suspense fallback={<Loading />}>}></Route>\n```\n\n### 2. 组件/功能懒加载（按需触发）\n\n```js\n// 点击按钮时加载弹窗组件\nconst handleClick = () => {\n  const { Modal } = await import('./components/Modal'); // 动态导入\n  \n  Modal.show('这是懒加载的弹窗');\n};\n```\n\n## 总结\n\nWebpack 通过解析依赖图谱将模块打包为 bundle，代码分割通过多个入口、公共代码提取、动态导入实现 chunk 拆分，懒加载则基于动态导入实现模块按需加载。两者结合可显著优化大型项目的加载性能，是前端工程化中提升用户体验的关键手段。","src/content/interview/介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载.mdx","1b71e10dc01c6a20","介绍 Webpack 的工作原理，以及如何通过 Webpack 进行代码分割和懒加载.mdx","介绍你使用过的前端测试工具和测试框架以及它们的使用场景",{id:275,data:277,body:280,filePath:281,digest:282,legacyId:283,deferredRender:21},{title:278,category:204,pubDate:279,heroImage:15},"介绍你使用过的前端测试工具和测试框架，以及它们的使用场景",["Date","2025-07-15T02:34:44.000Z"],"前端测试是保证代码质量的重要手段，不同的测试工具和框架适用于不同的测试场景，以下是我常用的工具及场景：\n\n## 1. 单元测试工具\n\n- **Jest**：\n  - 是一个由 Facebook 开发的全功能测试框架，内置断言库、测试运行器、mocking 工具和代码覆盖率报告功能，零配置即可使用。\n  - **适用场景**：React、Vue等框架的组件单元测试，JavaScript函数、工具类的逻辑测试。_例如：测试一个计算金额的工具函数是否正确处理各种边界情况，或者测试一个 React 组件在不同 props 下的渲染结果。_\n  - **优势**：API 简洁，支持快照测试（通过对比组件渲染的快照判断是否发生意外变化），运行速度快，对异步代码测试支持友好。\n- **Mocha + Chai**：\n  - Mocha 是一个灵活的测试运行器，需要配合断言库（如 Chai）使用，本身不提供断言功能，扩展性强。\n  - **使用场景**：复杂页面逻辑的单元测试，需要自定义测试流程或使用特定断言封国（如 Chai 的 `expect/should/assert`）的场景。_比如，测试一个包含多个步骤的表单验证逻辑，可通过 Mocha 的钩子函数（`before/after`）设置测试前置条件和清理工作。_\n  - **优势**：灵活性高，支持多种测试风格，生态丰富，可与 Sinon （用于 mocking 和 stubbing）等工具配合使用。\n\n## 2. 组件测试工具\n\n- **React Testing Library**：\n  - 基于 DOM 测试库，专注于从用户使用角度测试 React 组件，强调测试组件的行为而非实现细节。\n  - **适用场景**：React 组件的交互测试，如点击按钮后是否显示正确内容、表单输入是否触发验证等。_例如，测试一个登录按钮，点击后是否跳转到首页或显示错误提示。_\n  - **优势**：鼓励编写更健壮的测试（不依赖组件内部实现），当组件重构时测试仍能通过，与 React 生态继承良好。\n- **Vue Test Utils**：\n  - 是 Vue 官方的组件测试工具库，提供了一系列 API 用于挂载组件、模拟用户交互、访问组件内部状态等。\n  - **适用场景**：Vue组件的单元测试和集成测试，_比如，测试一个弹窗组件在不同状态下的显示/隐藏逻辑，或者测试组件的生命周期钩子是否正确执行。_\n  - **优势**：专为 Vue 设计，能深度访问组件实例，支持 Vue 的特性（如 v-model、指令）测试。\n\n## 3. 端到端（E2E）测试工具\n\n- **Cypress**：\n  - 是一个现代化的 E2E 测试工具，基于浏览器运行，提供实时重载、时间旅行（可会看测试执行过程）、自动等待等功能，无需配置即可录制测试视频。\n  - **适用场景**：模拟真实用户操作的全流程测试，_如电商网站的“加入购物车 -> 结算 -> 支付”完整流程，验证页面在真实浏览器环境中的交互是否正常_。\n  - **优势**：操作简单、调试方便，无需处理异步等待问题（内置智能等待），对单页应用（SPA）支持良好。\n- **Playwright**：\n  - 由 Microsoft 开发，支持多浏览器（Chrome、Firefox、Safari等）测试，可跨平台运行，提供强大的自动化 API。\n  - **适用场景**：需要在不同浏览器中验证兼容性的 E2E 测试，_例如测试一个响应式网站在不同浏览器和设备尺寸下的布局是否正确，或者测试涉及文件上传、下载的复杂交互流程。_\n  - **优势**：浏览器兼容性好，支持无头模式（无界面运行，提升 CI 环境测试速度），API设计直观。\n\n## 4. 其他测试工具\n\n- **Enzyme**：\n  - 常与 Jest 配合使用，是 React 的组件测试工具，提供了更灵活的组件查询和操作方式，可深入组件内部获取状态和属性。\n  - **适用场景**：需要详细测试 React 组件内部状态变化的单元测试，_例如，测试一个表单组件的输入值是否正确更新组件 state。_\n- **Karma**：\n  - 是一个测试运行器，可在多种真实浏览器或Headless浏览器中执行测试，常与 Jasmine、Mocha 等框架配合使用。\n  - **适用场景**：需要在不同浏览器环境中验证代码兼容性的测试，_例如，确保一个工具函数在 IE 11和现代浏览器中表现一致。_\n  \n## 总结\n\n- 单元测试优先选择 **Jest**（简单场景）或 **Mocha + Chai**（复杂场景），搭配框架专属工具（如 React Testing Library、Vue Test Utils）测试组件。\n- E2E 测试根据需求选择 **Cypress**（单浏览器快速测试）或 **Playwright**（多浏览器兼容性测试）。\n- 实际项目中，通常会结合多种工具构建测试体系：单元测试覆盖核心逻辑，组件测试保证 UI 正确性，E2E 测试验证关键业务流程，全方位提升代码质量。","src/content/interview/介绍你使用过的前端测试工具和测试框架，以及它们的使用场景.mdx","e23242314a8ea1bd","介绍你使用过的前端测试工具和测试框架，以及它们的使用场景.mdx","分享一个你参与过的最具挑战性的前端项目你在其中扮演的角色解决的问题以及从中获得的经验",{id:284,data:286,body:290,filePath:291,digest:292,legacyId:293,deferredRender:21},{title:287,category:288,pubDate:289,heroImage:15},"分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验","实战与架构",["Date","2025-07-15T17:52:53.000Z"],"## 项目背景\n\n某大型电商平台的 **实时库存管理系统**，需支持 10万 + SKU 的实时库存展示、多仓调拨和库存预警，用户端包括 PC 管理后台和移动端 APP，日均 PV 50万 +。\n\n## 我的角色\n\n前端技术负责人，负责架构设计、核心功能开发和性能优化，带领 5 个团队。\n\n## 挑战与解决方案\n\n### 1. 实时性与性能矛盾\n\n- 问题：库存数据每 3 秒更新一次，传统轮询导致频繁请求，页面卡顿。\n- 解决：采用 **Web Socket + 增量更新**：\n  - 后端仅推送变化的库存数据（而非全量），减少数据传输量。\n  - 前端用 `requestAnimationFrame` 批量更新 DOM，避免频繁回流。\n\n### 2. 复杂表格交互\n\n- 问题：10万+ 行数据的表格需支持排序、筛选、冻结列，传统表格组件性能崩溃。\n- 解决：实现 **虚拟滚动表格**：\n  - 仅渲染可视区域内的行（约 50 行），滚动时动态计算渲染范围。\n  - 基于 IndexDB 缓存筛选后的全局数据，避免重复请求。\n\n### 3. 多端适配与一致性\n\n- 问题：PC 端（复杂表单）和移动端（简化操作）需共享业务逻辑，但 UI 差异大。\n- 解决：采用 **逻辑与 UI 分离** 架构：\n  - 核心逻辑（如库存计算、校验规则）封装为独立 SDK，多端共享。\n  - UI 层使用不同组件库（PC 用 AntDesign，移动端用 Vant），通过适配层统一接口。\n\n## 经验总结\n\n- **技术选型需权衡**：实时场景优先考虑 WebSocket 而非轮询，但需做好断线重连和降级方案。\n- **性能优化要量化**：通过 Lighthouse 和 Performance API 建立性能基准，针对性优化（如首屏加载从 3s 降到 1.2s）。\n- **团队协作靠规范**：制定组件设计规范和 API 文档标准，减少沟通成本（如统一用 Swagger 管理接口文档）。\n- **故障预案不可少**：针对 WebSocket 连接失败、数据同步异常等场景，设计降级方案（如自动切换为轮询）。","src/content/interview/分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验.mdx","a988ee7109a0df4b","分享一个你参与过的最具挑战性的前端项目，你在其中扮演的角色、解决的问题以及从中获得的经验.mdx","前端性能优化的重要性是什么从哪些方面可以进行前端性能优化",{id:294,data:296,body:300,filePath:301,digest:302,legacyId:303,deferredRender:21},{title:297,category:298,pubDate:299,heroImage:15},"前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化","性能优化",["Date","2025-07-14T04:03:28.000Z"],"## 性能优化的重要性\n\n- **提升用户体验**：页面加载速度快、交互流畅，能减少用户等待时间，降低跳出率，提升用户满意度和留存率。\n- **增强业务转化**：对于电商、支付等场景，性能优化可直接影响用户决策。（例如加载速度每提升1秒，转化率可能显著提升）\n- **改善搜索引擎排名**：Google等搜索引擎将页面加载速度作为排名因素之一，性能好的网站更容易获得更高曝光。\n- **降低服务器成本**：通过缓存、资源压缩等优化，可减少服务器请求量和带宽消耗，降低运维成本。\n\n## 前端性能优化的主要方向\n\n1. **资源加载优化**\n  - **压缩与合并**：对JS、CSS、图片等资源进行压缩（如JS/CSS用Terser、CSSNano，图片用 WebP 格式），合并小文件减少 HTTP 请求。\n  - **懒加载与预加载**：非首屏图片、组件采用懒加载（按需加载）；提前加载可能用到的关键资源（如预加载字体、下一页数据）。\n  - **CDN 加速**：将静态资源部署到 CDN，利用其分布式节点让用户从最近节点获取资源，降低延迟。\n  - **合理设置缓存**：通过 HTTP 缓存（强缓存、协商缓存）减少重复资源请求，提升二次加载速度。\n2. **代码优化**\n  - **减少 DOM 操作**：避免频繁操作 DOM（如批量修改用文档片段 DocumentFragment），减少回流/重绘。\n  - **优化 JavaScript 执行**：避免长任务阻塞主线程（用 Web Worker 处理复杂计算），减少不必要的全局变量和闭包导致的内存泄漏。\n  - **CSS 优化**：避免复杂选择器（如嵌套过深），减少 `@import`（会阻塞渲染），使用 CSS Sprite 合并小图标。\n3. **首屏加载优化**\n  - **关键资源优先加载**：通过 `<link rel=\"preload\">` 指定关键 CSS/JS 优先加载，延迟加载非关键资源。\n  - **代码分割**：用 Webpack 等工具拆分代码，首屏只加载必要代码（如路由懒加载），其余按需加载。\n  - **服务端渲染（SSR）/静态站点生成（SSG）**：对于首屏内容复杂的页面，通过 SSR/SSG 在服务端生成 HTML，减少客户端渲染时间。\n4. **网络优化**\n  - **使用 HTTP 2/3**：利用多路复用、头部压缩等特性提升传输效率，减少连接建立开销。\n  - **减少请求体积**：移除代码中未使用的部分（Tree Sharking），接口返回数据采用压缩格式（如 gzip、br）。\n5. **其他优化**\n  - **优化第三方脚本**：延迟加载非必要的第三方脚本（如广告、统计工具），避免其阻塞页面渲染。\n  - **监控与分析**：通过 Lighthouse、Web Vitals 等工具监控性能指标，针对性优化瓶颈问题。\n  \n性能优化需结合具体场景，遵循“先量化后优化”原则，优先解决对用户体验影响最大的问题（如首屏加载时间、交互响应速度）。","src/content/interview/前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化.mdx","06d30597b5fd33f4","前端性能优化的重要性是什么？从哪些方面可以进行前端性能优化.mdx","在-vue-中如何实现组件之间的通信请列举多种方式并说明其适用场景",{id:304,data:306,body:309,filePath:310,digest:311,legacyId:312,deferredRender:21},{title:307,category:184,pubDate:308,heroImage:15},"在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景",["Date","2025-07-13T20:00:53.000Z"],"Vue 中组件通信方式多样，需根据组件关系（父子、兄弟、跨级等）选择合适的方式。\n\n## 组件通信方式\n\n### props/emit（父子组件通信）\n\n- **用法**：父组件通过 `props` 向子组件传递数据；子组件通过 `$emit` 触发事件，父组件监听事件获取子组件数据。\n- **适用场景**：最基础的父子组件通信，适用于数据流向清晰的简单场景。\n\n```vue\n<!-- 父组件 -->\n<Child :msg=\"parentMsg\" @childEvent=\"handleEvent\" />\n\n<!-- 子组件 -->\n<script>\nexport default {\n  props: ['msg'],\n  methods: {\n    sendData() {\n      this.$emit('childEvent', '子组件数据')\n    }\n  }\n}\n</script>\n```\n\n### \\$parent/$children（父子组件通信）\n\n- **用法**：子组件通过 `this.$parent` 访问父组件实例；父组件通过 `this.$children` 访问子组件实例（返回子组件数组）。\n- **适用场景**：临时性、简单的父子组件交互，但不推荐频繁使用，会增加组件耦合度。\n\n### $refs（父子组件通信）\n\n- **用法**：父组件给子组件添加 `ref` 属性（如 `<Child ref=\"childRef\" />`），通过 `this.$refs.childRef` 直接访问子组件实例（包括数据和方法）。\n- **适用场景**：需要主动调用子组件方法或获取子组件数据的场景（如表单重置），需在组件挂载后使用。\n\n### EventBus（兄弟/跨级组件通信）\n\n- **用法**：创建一个全局事件总线（如`const bus = new Vue()`），组件通过 `bus.$emit` 触发事件传递数据。\n- **适用场景**：中小型项目中无直接关系的组件通信，大型项目易导致事件混乱，需谨慎使用。\n\n```js\n// main.js\nVue.prototype.$bus = new Vue();\n// 组件 A（发送数据）\nthis.$bus.$emit('eventName', data);\n// 组件 B（接收数据）\nthis.$bus.$on('eventName', (data) => { ... });\n```\n\n### Vuex/Pinia（全局状态管理器）\n\n- **用法**：通过集中式存储管理应用的所有组件状态，组件通过 `dispatch/commit` 修改状态，通过 `mapState` 等获取状态。\n- **适用场景**：大型项目中多组件共享数据（如用户信息、购物车等），或跨多级组件通信，能清晰追踪状态变化。\n\n### Provide/Inject（跨级组件通信）\n\n- **用法**：祖先组件通过 `provide` 提供数据，后代组件通过 `inject` 注入数据，无视组件层级。\n- **适用场景**：深层嵌套组件通信（如组件库开发），但数据是非响应式的（需配合`ref/reactive`实现响应式）。\n\n```vue\n<!-- 祖先组件 -->\n<script>\nexport default {\n  provide() {\n    return { key: '共享数据' }\n  }\n}\n</script>\n\n<!-- 后代组件 -->\n<script>\nexport default {\n  inject: ['key'],\n  mounted() {\n    console.log(this.key);\n  }\n}\n</script>\n```\n\n### 路由参数（跳转组件通信）\n\n- **用法**：通过路由跳转时在 URL 中携带参数（`params` 或 `query`），目标组件通过 `$route.params/$route.query` 获取。\n- **适用场景**：页面级组件通过路由跳转传递数据。\n\n## 选择通信方式的核心原则\n\n优先使用 `props/emit`（父子）、`Vuex/Pinia`（全局），避免过度使用 `$parent/EventBus` 导致代码维护困难。","src/content/interview/在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景.mdx","cd617850203af26e","在 Vue 中，如何实现组件之间的通信？请列举多种方式并说明其适用场景.mdx","在前端项目中如何进行状态管理请对比不同状态管理方案的优缺点",{id:313,data:315,body:318,filePath:319,digest:320,legacyId:321,deferredRender:21},{title:316,category:288,pubDate:317,heroImage:15},"在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点",["Date","2025-07-15T17:03:45.000Z"],"前端状态管理的核心是 **统一管理应用状态**，解决组件数据共享问题。不同场景需选择不同方案，常见方案对比如下：\n\n| 方案         | 适用场景                         | 优点                                                   | 缺点                                    |\n| ------------ | -------------------------------- | ------------------------------------------------------ | --------------------------------------- |\n| 组件自身状态 | 单个组件内部状态（如表单输入值） | 简单直接，无需额外依赖                                 | 无法跨组件共享                          |\n| Props/Events | 父子组件通信                     | 原生支持，无学习成本                                   | 深层嵌套组件传递繁琐（“props 钻取”）    |\n| Context API  | 中大型应用的跨层级共享（如主题） | 原生支持，避免 props 钻取                              | 频繁更新会导致性能问题（无优化机制）    |\n| Redux        | 大型应用，复杂状态逻辑（如电商） | 严格的单向数据流，可预测性强，支持中间件（如异步处理） | 样板代码多，学习成本高                  |\n| Vuex/Pinia   | Vue 生态的中大型应用             | 继承 Vue 响应式系统，API 简洁，支持模块化              | 仅适用于 Vue，Pinia 对旧版 Vue 兼容性差 |\n| MobX         | 复杂状态且需灵活更新的应用       | 响应式自动追踪依赖，代码简洁                           | 灵活性高导致状态变更难以追踪            |\n| Zustand      | 中小型应用，React生态            | API 极简，无 Provider 包裹，支持中间件                 | 生态不如 Redux 完善                     |\n\n## 选择建议\n\n- 小型项目或简单状态：优先使用 `Props/Events` 或 `Context API`，减少依赖。\n- 中大型 React 项目：复杂状态用 `Redux`（配合 Redux Toolkit 减少样板代码），简单跨组件状态用 `Zustand`。\n- Vue 项目：首选 `Pinia`（Vuex的继任者，更简洁的 API 和更好的 TypeScript支持）。\n- 状态频繁更新逻辑复杂：MobX（自动响应式可简化代码），但需规范状态变更流程。","src/content/interview/在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点.mdx","ce8102b94a1f888c","在前端项目中，如何进行状态管理？请对比不同状态管理方案的优缺点.mdx","如何优化-javascript-的执行性能",{id:322,data:324,body:327,filePath:328,digest:329,legacyId:330,deferredRender:21},{title:325,category:298,pubDate:326,heroImage:15},"如何优化 JavaScript 的执行性能",["Date","2025-07-14T07:54:10.000Z"],"JavaScript 的执行性能直接影响页面的响应速度和用户体验，尤其是长任务阻塞主线程会导致页面卡顿。优化方向主要集中在减少执行时间、避免主线程阻塞、提升代码效率等方面。\n\n## 1. 减少主线程阻塞\n\n- **拆分长任务**：将执行时间超过 50ms 的长任务拆分为多个短任务，利用 `requestIdleCallback` 或 `setTimeout` 在浏览器空闲时执行，避免长时间占用主线程。\n\n例如：用 `requestIdleCallback` 处理非紧急计算：\n\n```js\nrequestIdleCallback((deadline) => {\n  while (deadline.timeRemaining() > 0 && hasMoreWork()) {\n    doWork(); // 每次处理一小部分任务\n  }\n});\n```\n\n- **使用 Web Worker**：将复杂计算、数据处理等耗时操作移至 Web Worker 中执行，避免阻塞主线程（Web Worker 无法操作 DOM，需通过消息传递数据）。\n\n例如：创建 Worker 处理计算：\n\n```js\n// 主线程\nconst worker = new Worker('worker.js');\n\nworker.postMessage(data); // 发送数据\nworker.onmessage = （event) => {\n  console.log('处理结果', event.data);\n}\n\n// worker.js\nself.onmessage = (event) => {\n  const result = heavyCalculation(event.data); // 耗时计算\n  \n  self.postMessage(result); // 发送结果\n}\n```\n\n## 2. 优化代码执行效率\n\n- **减少不必要的计算**：避免重复计算（如将计算结果缓存）、简化复杂逻辑（如用哈希表 `Map/Object` 替代嵌套循环查找，将 O(n<sup>2</sup>) 复杂度优化为 O(n)）。\n\n例如，缓存 DOM 查询结果：\n\n```js\n// 优化前：每次都查询 DOM\nfor (let i = 0; i < 100; i++) {\n  document.getElementById('list').appendChild(item);\n}\n\n// 优化后：缓存 DOM 节点\nconst list = document.getElementById('list');\n\nfor (let i = 0; i < 100; i++) {\n  list.appendChild(item);\n}\n```\n\n- **避免全局变量**：全局变量会挂载在 `widow` 上，查找链长且容易引发命名冲突，尽量使用局部变量（访问速度更快）。\n- **优化循环与条件判断**：减少循环嵌套，将高频执行的条件判断放在循环外，使用 `break/continue` 提前退出无效循环。\n\n## 3. 优化 DOM 操作\n\n- **批量操作 DOM**：频繁修改 DOM 会触发多次回流/重绘，可先将 DOM 从文档流中移除（如 `display: none`），批量修改后再插入，或使用 `DocumentFragment` 临时存储节点。\n\n例如，用 `DocumentFragment` 批量添加节点：\n\n```js\nconst fragment = document.createDocumentFragment();\n\nfor (let i = 0; i < 100; i++) {\n  const li = document.createElement('li');\n  \n  fragment.appendChild(li); // 先添加到文档片段\n}\n\ndocument.getElementById('list').appendChild(fragment);\n```\n\n- **避免强制同步布局**：读取 DOM 样式（如 `offsetHeight`）后立即修改样式，会触发浏览器强制同步布局（先计算布局再修改，增加开销），应批量读取后再批量修改。\n\n例如，优化布局操作顺序：\n\n```js\n// 优化前：强制同步布局\nelements.forEach((element) => {\n  element.style.width = '100px'; // 修改样式\n  \n  const height = element.offsetHeight; // 立即读取，触发强制布局\n});\n\n// 优化后，先读再改\nconst heights = elements.map(element => element.offsetHeight); // 批量读取\n\nelements.forEach((element, i) => {\n  element.style.width = '100px';\n  element.style.height = heights[i] + 'px'; // 使用缓存值\n});\n```\n\n## 4. 减少内存泄漏\n\n- **及时清理引用**：避免意外保留 DOM 节点引用（如将 DOM 节点存在数组中未清空）、定时器/事件监听器未移除（如 `setInterval` 未用`clearInterval`清除）。\n\n例如，组件卸载时移除事件监听：\n\n```js\n// React 组件中\nuseEffect(() => {\n  const handleScroll = () => { ... };\n  \n  window.addEventListener('scroll', handleScroll);\n  \n  return () => {\n    window.removeEventListener('scroll', handleScroll); // 卸载时清理\n  };\n}, []);\n```\n\n- **避免闭包导致的内存驻留**：合理使用闭包，避免长期持有大对象引用（如在循环中创建闭包存储大量数据）。\n\n## 5. 其他优化\n\n- **使用高效 API**：优先使用原生 API（如 `Array.prototype.map/filter` 比手动循环更高效）、避免使用 `eval`（执行慢且不安全）。\n- **代码压缩与 Tree Sharking**：通过 Webpack、Tarser 等工具压缩代码（移除空格、重命名变量），Tree Sharking 剔除未使用的代码，减少 JS 文件体积，加快解析和执行速度。\n\n通过以上方法，可显著提升 JavaScript 的执行性能，减少页面卡顿，提升用户交互体验，尤其在大型应用和复杂交互场景中效果显著。","src/content/interview/如何优化 JavaScript 的执行性能.mdx","4b58ff48ebd6b3cc","如何优化 JavaScript 的执行性能.mdx","如何保证前端项目的代码质量请从编码规范代码审查测试等方面进行说明",{id:331,data:333,body:336,filePath:337,digest:338,legacyId:339,deferredRender:21},{title:334,category:288,pubDate:335,heroImage:15},"如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明",["Date","2025-07-15T17:36:37.000Z"],"保证代码质量需建立 **全流程质量管控体系**，覆盖编码、提交、审查、测试和部署环节。\n\n## 1. 编码规范\n\n- **指定统一规范**：基于 ESLint、StyleLint配置团队规则（如 Airbnb规范），强制代码风格一致（如缩进、命名、注释）。\n- **自动化校验**：通过 `husky` 在代码提交前触发 `lint-staged`，仅检查暂存区代码，不符合规范则阻止提交。\n\n```json\n// package.json\n{\n  \"lint-staged\": {\n    \"*.{js,vue}\": [\"eslint --fix\", \"prettier --write\"]\n  }\n}\n```\n\n- **编辑器配置统一**：通过 `editorconfig` 文件统一缩进、换行符等编辑器行为，避免环境差异。\n\n## 2. 代码审查（Code Review）\n\n- **建立 PR 流程**：通过 GitLab/GitHub 的 Pull Request 机制，要求代码必须经过至少 1 名团队成员审查才能合并。\n- **审查重点**：逻辑正确性、性能隐患、安全性（如 XSS 风险）、代码复用性。\n- **工具辅助**：使用 SonarQube 检测代码重复率、复杂度，通过自动化工具提前发现潜在问题。\n\n## 3. 测试体系\n\n- **单元测试**：覆盖核心工具函数、组件逻辑（如用 Jest 测试 `format.js` 的日期格式化功能），目标覆盖率 >= 80%。\n- **组件测试**：通过 React Testing Library/Vue Test Utils 测试组件渲染和交互（如按钮点击是否触发回调）。\n- **E2E测试**：用 Cypress/Playwright 模拟用户全流程操作（如 登录 -> 下单），确保关键业务链路可用。\n- **性能测试**：通过 Lighthouse 定期检测页面性能指标（如 FCP、LCP），设置阔值告警。\n\n## 持续集成（CI）\n\n- 配置 CI 流水线（如 GitHub Actions），每次提交自动执行；\n  - 代码 Lint -> 单元测试 -> 构建 -> E2E测试 -> 性能检测。\n- 任何环节失败则阻断部署，确保问题不流入生产环境。","src/content/interview/如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明.mdx","ed9f63ff14a19965","如何保证前端项目的代码质量？请从编码规范、代码审查、测试等方面进行说明.mdx","浏览器的本地存储方式有哪些它们的区别和适用场景是什么",{id:340,data:342,body:345,filePath:346,digest:347,legacyId:348,deferredRender:21},{title:343,category:224,pubDate:344,heroImage:15},"浏览器的本地存储方式有哪些？它们的区别和适用场景是什么",["Date","2025-07-15T09:16:56.000Z"],"浏览器的本地存储是指将数据存储在用户本地设备上的技术，无需每次从服务器获取，可提升页面加载速度和离线和使用场景上有显著差异。\n\n## Cookie\n\n### 特性\n\n- 容量下，通常限制在 **4KB左右**。\n- 由服务器或客户端设置，每次 HTTP 请求都会自动携带在请求头中（包括跨域请求，需符合 CORS 策略）。\n- 有过期时间（`expires` 或 `max-age`），过期后自动删除；若未设置，则为会话级（关闭浏览器后失效）。\n- 可设置 `domain` 和 `path` 属性，限制 Cookie 的作用范围（如仅在特定域名或路径下生效）。\n- 支持 `HttpOnly` 属性（设置后无法通过 JavaScript 访问，可防止 XSS 攻击）和 `Secure` 属性（仅在 HTTPS 协议下传输）。\n\n### 适用场景\n\n- 存储用户身份标识（如 Session ID），实现会话管理（登录状态保持）。\n- 存储用户偏好设置（如语言、主题），但受限于容量，仅适合少量数据。\n- 用于追踪用户行为（如广告投放），但需注意隐私合规（如 GDPR）。\n\n## localStorage\n\n### 特性\n\n- 容量较大，通常为 **5MB ~ 10MB**（不同浏览器略有差异）。\n- 仅由客户端通过 JavaScript 操作（`localStorage.setItem()/getItem()`），不会随 HTTP 请求发送到服务器。\n- 持久化存储，除非手动删除（通过代码或浏览器设置），否则数据永久保留（关闭浏览器、重启设备后仍存在）。\n- 作用域限制在同一域名（协议、域名、端口均相同），不同域名无法共享数据。\n- 存储的数据为字符串类型，复杂数据（如对象）需通过 `JSON.stringify()` 序列化后存储。\n\n### 适用场景\n\n- 存储大量用户本地数据，_如离线缓存的商品列表、表单草稿（未提交的内容）_。\n- 保存用户长期偏好设置 _（如默认排序方式、是否开启夜间模式）_。\n- 作为前端状态管理的辅助存储（如缓存不常变化的全局数据）。\n\n## sessionStorage\n\n### 特性\n\n- 容量与 `localStorage` 相近（**5MB ~ 10MB**）。\n- 仅在当前会话（标签页或窗口）有效，关闭标签页/窗口后数据立即清除；同一页面的刷新不会删除数据，但不同标签页间无法共享（即使是同一域名）。\n- 仅由客户端 JavaScript 操作，不随 HTTP 请求发送。\n- 作用域限制在同一域名或同一会话，与 `localStorage` 相同。\n\n注意：当在一个标签页下，打开同一域名的新标签，会将 `sessionStorage` 的数据复制到新标签页中，但是当前标签页的 `sessionStorage` 数据发生改变时，不会同步到新标签页。\n\n### 适用场景\n\n- 存储临时会话数据，_如单页应用（SPA）中的路由参数、临时表单数据（仅在当前页有效）。_\n- 防止用户重复提交表单（存储提交状态，页面刷新后仍可读取）。\n- 存储敏感的临时数据（_如用户输入的验证码_），避免持久化带来的隐私风险。\n\n## IndexDB\n\n### 特性\n\n- 大容量存储，理论上无上限（受限于用户设备存储空间）。\n- 基于 NoSQL 的数据库，支持复杂数据结构（对象、二进制数据等），可通过索引高效查询。\n- 异步操作（不会阻塞主线程），适合处理大量数据。\n- 持久化存储，作用域为同一域名，数据不会随会话结束而删除。\n- 支持事物操作，保证数据的完整性。\n\n### 适用场景\n\n- 存储大量结构化数据，如离弦应用的本地数据库（_如离线地图数据、文档编辑历史_）。\n- 缓存需要频繁查询的数据（_如用户的历史订单记录_），减少服务器请求。\n- 实现复杂的前端数据交互（_如本地搜索、数据过滤_），提升操作响应速度。\n\n## 四种存储方式的核心区别\n\n| 特性             | Cookie                | localStorage        | sessionStorage       | IndexDB                    |\n| ---------------- | --------------------- | ------------------- | -------------------- | -------------------------- |\n| **容量**         | 约 4KB                | 5MB ~ 10MB          | 5MB ~ 10MB           | 理论上无上限               |\n| **有效期**       | 可设置过期时间        | 永久（手动删除）    | 会话级（关闭标签页） | 永久（手动删除）           |\n| **网络请求携带** | 是（自动）            | 否                  | 否                   | 否                         |\n| **操作方式**     | 客户端/服务器均可设置 | 仅客户端 JavaScript | 仅客户端 JavaScript  | 仅客户端 JavaScript        |\n| **数据类型**     | 字符串                | 字符串（需序列化）  | 字符串（需序列化）   | 复杂数据（对象、二进制等） |\n| **作用域**       | 同域名（可跨路径）    | 同域名              | 同域名 + 同会话      | 同域名                     |\n\n## 选择建议\n\n- 需与服务器交互的少量数据（如身份验证）-> Cookie。\n- 长期存储的非敏感数据（如用户偏好）-> localStorage。\n- 临时会话数据（如表单临时内容）-> sessionStorage。\n- 大量结构化数据（如离线缓存）-> IndexDB。\n\n实际开发中，需根据数据量、有效期、是否跨会话等需求综合选择，同时注意隐私安全（如避免存储敏感信息在 `localStorage` 中，防止 XSS 攻击）和浏览器兼容性（IndexDB 在老旧浏览器中支持有限）。","src/content/interview/浏览器的本地存储方式有哪些？它们的区别和适用场景是什么.mdx","56e4cbbe5210259d","浏览器的本地存储方式有哪些？它们的区别和适用场景是什么.mdx","如何减少-http-请求有哪些具体的方法",{id:349,data:351,body:354,filePath:355,digest:356,legacyId:357,deferredRender:21},{title:352,category:298,pubDate:353,heroImage:15},"如何减少 HTTP 请求？有哪些具体的方法",["Date","2025-07-14T04:32:39.000Z"],"减少 HTTP 请求是前端性能优化的核心手段之一，因为每个 HTTP 请求都存在建立连接、传输数据等开销，请求数量越多，页面加载速度越慢。\n\n## 具体实施方法\n\n### 资源合并\n\n- **JS/CSS 合并**：将多个小型 JS 文件合并为一个（如用 Webpack 的 `splitChunks` 合并公共库），多个 CSS 文件合并为一个，减少请求次数。\n- **图片合并（CSS Sprite）**：将多个小图标（如按钮、图标）合并成一张雪碧图，通过 CSS 的 `background-position` 定位显示不同图标，将多次图片请求缩减为一次。\n\n### 资源压缩与格式优化\n\n- **使用高效图片格式**：采用 WebP、AVIF 等现代图片格式，在相同画质下体积比 JPEG/PNG 小 **30% 以上**，减少单张图片的请求体积。\n- **字体图标替代图片**：用 Font Awesome 等字体图标库替代小图标图片，一个字体文件可包含多个图标，且支持缩放不失真，减少图片请求。\n\n### 懒加载与按需加载\n\n- **图片懒加载**：初始至加载可视区域内的图片，当用户滚动到相应区域时再加载其他图片（通过 **data-src** 存储真实地址，滚动时替换为 _src_）。\n- **路由懒加载**：在 SPA（单页应用）中，通过 Webpack 的 `import()` 语法实现路由组件按需加载，仅当用户访问对应路由时才加载该组件的 JS/CSS，避免首屏加载所有资源。\n\n### 利用缓存减少重复请求\n\n- **通过 HTTP 缓存**：强缓存如 `Cache-Control: max-age=31536000`，协商缓存如 `ETag/Last-Modified`。让浏览器缓存静态资源，用户二次访问时直接从本地读取，无需重新向服务器请求。\n\n### 使用 CDN 与资源复用\n\n- **CDN 的边缘节点会缓存静态资源**，用户请求时优先从 CDN 获取，减少对源服务器的请求；同时，CDN 的资源复用机制（如同一域名下的资源共享连接）可降低连接建立开销。\n\n### 内联小型资源\n\n- **将小型 JS/CSS 代码通过 `<script>/<style>` 标签内联到 HTML 中**，避免额外的 HTTP 请求（适用于体积极小的资源，过大内联惠增加 HTML 体积）。\n\n通过上述方法，可显著减少页面的 HTTP 请求总量，降低网络传输成本，提升页面加载速度。实际优化中需结合资源大小、使用频率等因素灵活选择，避免过度合并导致单次请求体积过大。","src/content/interview/如何减少 HTTP 请求？有哪些具体的方法.mdx","32b7ad3a2f3d648e","如何减少 HTTP 请求？有哪些具体的方法.mdx","如何实现元素的水平居中垂直居中以及水平垂直居中",{id:358,data:360,body:364,filePath:365,digest:366,legacyId:367,deferredRender:21},{title:361,category:362,pubDate:363,heroImage:15},"如何实现元素的水平居中、垂直居中以及水平垂直居中","CSS 进阶",["Date","2025-07-13T08:41:35.000Z"],"## 水平居中\n\n- **行内元素/文本**\n  - 给父元素设置 `text-align: center`，适用于 `<span>`、`<a>`、文本等行内元素。\n- **块级元素（定宽）**\n  - 给元素设置 `margin: 0 auto`，需指定 `width`（否则元素默认占满父容器宽度，居中无效果）。\n- **块级元素（不定宽）**\n  - **Flexbox**：父元素设置 `display: flex; justify-content: center;`，子元素宽度可自适应。\n  - **Grid**：父元素设置 `display: grid; justify-content: center;`。\n- **Position**：父元素设置 `position: relative;`，子元素设置 `position: absolute; left: 50%; transform: translateX(-50%);`，无需知道子元素宽度。\n\n## 垂直居中\n\n- **行内元素/文本(单行)**\n  - 给父元素设置 `line-height` 等于父元素高度，适用于单行文本或行内元素。\n- **行内元素/文本(多行)**\n  - 父元素设置 `display: table-cell; vertical-align: middle;`，同时指定父元素高度。\n- **块级元素**\n  - **Flexbox**：父元素设置 `display: flex; aligin-items: center;`，兼容性较好且灵活。\n  - **Grid**：父元素设置 `display: grid; align-items: center;`。\n  - **Position**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 50%; left: 50%; transform: translateY(-50%)`，无需知道子元素高度。\n  - **已知父元素高度且子元素高度固定**：子元素设置 `margin-top: (父高 - 子高) / 2`。\n\n## 水平垂直居中\n\n- **Flexbox**：父元素设置 `display: flex; justify-content: center; align-items: center;`，最简单常用，支持不定宽高元素。\n- **Grid**：父元素设置 `display: grid; place-items: center;`（`place-items` 是 `align-items` 和 `justify-items` 的简写）。\n- **Position + transform**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%)`，适用于不定高元素。\n- **Position + margin**：父元素设置 `position: relative;`，子元素设置 `position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto;`，需指定子元素宽高。\n- **table-cell**：父元素设置 `display: table-cell; vertical-align: middle; text-align: center;`，子元素设置 `display: inline-block;`（将会计元素转为行内块，配合父元素文本居中）。","src/content/interview/如何实现元素的水平居中、垂直居中以及水平垂直居中.mdx","5fababaa89c6eeb7","如何实现元素的水平居中、垂直居中以及水平垂直居中.mdx","简述-css-的盒模型包括标准盒模型和怪异盒模型的区别以及如何通过-css-进行切换",{id:368,data:370,body:373,filePath:374,digest:375,legacyId:376,deferredRender:21},{title:371,category:214,pubDate:372,heroImage:15},"简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换",["Date","2025-07-10T17:42:32.000Z"],"CSS 盒模型是 CSS 布局的基础，它规定了元素在页面中占据空间的计算方式，每个元素都可以看作一个盒子，由 **内容（content）**、**边框（border）**、**内边距（padding）**、**外边距（margin）** 四部分组成。\n\n## 标准盒模型与怪异盒模型的区别\n\n标准盒模型和怪异盒模型（也称为 IE 盒模型）的核心区别在于**元素总宽度和总高度的计算方式**：\n\n### **标准盒模型**\n\n- 元素总宽度 = 内容区宽度（width） + 左右内边距（padding-left + padding-right） + 左右边框宽度（border-left + border-right）\n- 元素总高度 = 内容区高度（height） + 上下内边距（padding-top + padding-bottom) + 上下边框宽度（border-top + border-bottom）\n\n也就是说，**标准盒模型中设置的 width 和 height 仅指代内容区的尺寸。**\n\n### **怪异盒模型**\n\n- 元素总宽度 = 设置的 width 值（width 包含内容区宽度 + 左右内边距 + 左右边框宽度）\n- 元素总高度 = 设置的 height 值（height 包含内容区高度 + 上下内边距 + 上下边框宽度）\n\n## CSS 切换盒模型\n\n通过 CSS 的 `box-sizing` 属性可以切换这两种盒模型：\n\n- 当 `box-sizing` 属性的值为 `content-box` 时，采用标准盒模型（默认值）。\n- 当 `box-sizing` 属性的值为 `border-box` 时，采用怪异盒模型。\n\n例如，若一个元素设置 CSS 属性为 `width: 200px; padding: 10px; border: 5px solid #000;`，在标准盒模型下，其总宽度为 `230px`，在怪异盒模型下，其总宽度为 `200px`。","src/content/interview/简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换.mdx","7332be30a36dd761","简述 CSS 的盒模型，包括标准盒模型和怪异盒模型的区别，以及如何通过 CSS 进行切换.mdx","解释-react-中的虚拟-dom它的工作原理及优势",{id:377,data:379,body:382,filePath:383,digest:384,legacyId:385,deferredRender:21},{title:380,category:184,pubDate:381,heroImage:15},"解释 React 中的虚拟 DOM，它的工作原理及优势",["Date","2025-07-13T17:36:22.000Z"],"虚拟 DOM（Virtual DOM）是 React 中对真实 DOM 的一种轻量级内存抽象表示，本质上是一个 JavaScript 对象，它包含了真实 DOM 的结构和属性信息（如标签名、属性、子元素等）。\n\n## 工作原理\n\n1. **初始化渲染**：当组件首次渲染时，React 会根据 JSX 代码生成对应的虚拟 DOM 树。\n2. **生成真实 DOM**：React 将虚拟 DOM 树转换为真实 DOM，并插入到页面中。\n3. **状态更新**：当组件状态（state）或属性（props）发生变化时，React 会重新生成一个新的虚拟 DOM 树。\n4. **Diff 算法对比**：通过 Diff 算法（差异对比算法）对比新旧两棵虚拟 DOM 树，找出两者之间的差异（如节点新增、删除、属性变化等）。\n5. **更新真实 DOM**：React 只将找出的差异部分转换为真实 DOM 操作，批量更新到页面中，而非重新渲染整个 DOM 树。\n\n## 优势\n\n- **提升性能**：真实 DOM 操作代价是昂贵的（会触发重排、重绘），虚拟 DOM 通过 Diff 算法精准找出差异，减少了不必要的 DOM 操作，尤其在复杂页面频繁更新时，性能提升明显。\n- **跨平台能力**：虚拟 DOM 是平台无关的抽象层，React 可基于虚拟 DOM 将组件渲染到不同平台（如Web端的真实DOM、移动端的原生组件等），实现一次编译多端运行。\n- **简化开发流程**：开发者无需手动操作 DOM，只需关注组件状态变化，React 会自动处理 DOM 更新，降低了开发复杂度和出错概率。\n- **支持批量更新**：React 会将多个状态更新合并为一次虚拟 DOM 对比和真实 DOM 更新，减少了页面重绘次数，进一步优化性能。","src/content/interview/解释 React 中的虚拟 DOM，它的工作原理及优势.mdx","0abdb3d2fcdfb682","解释 React 中的虚拟 DOM，它的工作原理及优势.mdx","解释事件冒泡和事件捕获的概念以及如何阻止事件冒泡和事件捕获",{id:386,data:388,body:391,filePath:392,digest:393,legacyId:394,deferredRender:21},{title:389,category:214,pubDate:390,heroImage:15},"解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获",["Date","2025-07-10T18:28:26.000Z"],"- **事件冒泡**：事件冒泡是指当一个元素触发某个事件后，该事件会从触发事件的元素开始，按照 DOM 树的顺序向上冒泡，依次触发其父元素、祖父元素等祖先元素上的相同事件，直到传递到 document 对象。_例如，在一个嵌套元素中，点击子元素，若父元素和父祖元素也绑定了相同的点击事件，那么这些事件会按照 `子 -> 父 -> 祖父` 的顺序依次触发。_\n- **事件捕获**：事件捕获与事件冒泡相反，它是事件从最顶层的祖先元素开始向下传播，依次触发各级子元素上的相同事件，直到到达触发事件的目标元素。_比如上述嵌套结构，点击子元素时，事件会按照 `祖父 -> 父 -> 子` 的顺序传播并触发相应的事件。_\n\n在 JavaScript 中，可以通过以下方法阻止事件冒泡和事件捕获：\n\n- **阻止事件冒泡**：可以使用 `event.stopPropagation()` 方法来阻止事件冒泡。该方法会阻止事件继续向上传播，但不会影响该元素上其他事件处理程序的执行。\n- **阻止事件捕获**：同样可以使用 `event.stopPropagation()` 方法。在事件捕获阶段调用该方法，能阻止事件继续向下传播到目标元素及其子元素。\n\n需要注意的是，`event.stopImmediatePropagation()` 方法不仅能阻止事件的冒泡和捕获，还能阻止该元素上后续的事件处理程序执行，**使用时需根据实际需求选择。**","src/content/interview/解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获.mdx","f45711bf69eacbb5","解释事件冒泡和事件捕获的概念，以及如何阻止事件冒泡和事件捕获.mdx","解释-promise-的三种状态及其转换关系如何使用-promise-处理异步操作",{id:395,data:397,body:400,filePath:401,digest:402,legacyId:403,deferredRender:21},{title:398,category:194,pubDate:399,heroImage:15},"解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作",["Date","2025-07-13T06:13:29.000Z"],"Promise 有三种状态，分别是 **pending（等待态）**、**fulfilled（成功态）**、**rejected（失败态）**。\n\n- **pending（等待态）**：这是 Promise 的初始状态，当 Promise 对象被创建时，处于该状态，表示异步操作正在进行中，尚未有结果。\n- **fulfilled（成功态）**：当异步操作成功完成时，Promise 会从 pending 状态转换为 fulfilled 状态，此时会携带异步操作的成功结果。\n- **rejected（失败态）**：当异步操作失败时，Promise 会从 pending 状态转换为 rejected 状态，此时会携带异步操作的错误信息。\n\n三种状态的转换关系是**不可逆**的：\n\n- 从 pending 状态可以转换为 fulfilled 状态，一旦转换为 fulfilled 状态，就不能再变回 pending 状态，也不能转换为 rejected 状态。\n- 从 pending 状态可以转换为 rejected 状态，一旦转换为 rejected 状态，同样不能再变回 pending 状态，也不能转换为 fulfilled 状态。\n\n## 使用 Promise 处理异步操作\n\n### 创建 Promise 对象\n\n通过 `new Promise((resolve) => {...})` 创建，在 executor 函数中执行异步操作。当异步操作成功时，调用 `resolve(value)`将状态从 pending 转换为 fulfilled，并将成功结果 value 传递出去；当异步操作失败时，调用 `reject(error)` 将状态从 pending 转换为 rejected，并将错误信息 error 传递出去。\n\n```js\nconst promise = new Promise((resolve, reject) => {\n  // 模拟异步操作，如网络请求\n  setTimeout(() => {\n    const success = Math.random() > 0.5;\n    \n    if (success) {\n      resolve('操作成功，这是结果');\n    } else {\n      reject('操作失败，这是错误信息');\n    }\n  }, 1000);\n});\n```\n\n### 处理结果\n\n使用 `then()` 方法处理 fulfilled 状态的结果，`catch()` 方法处理 rejected 状态的错误，也可以在 `then()` 方法的第二个参数中处理错误。\n\n```js\npromise.then((result) => {\n  console.log('成功处理结果：', result);\n  \n  // 可以返回新的 Promise 进行链式操作\n  return result + '，已处理';\n}).then((processedResult) => {\n  console.log('进一步处理结果：', processedResult);\n}).catch((error) => {\n  console.error('捕获到错误：', error.message);\n});\n```\n\n### 多个异步操作处理\n\n可以使用 `Promise.all()`、`Promise.race()` 等方法处理多个 Promise。`Promise.all()` 等待所有 Promise 都变为 fulfilled 状态后，返回一个包含所有结果的数组；如果有一个 Promise 变为 rejected 状态，则立即返回该错误。`Promise.race()` 只要有一个 Promise 状态发生改变（无论是 fulfilled 还是 rejected），就返回该结果。\n\n```js\nconst promise1 = new Promise(resolve => setTimeout(() => resolve(1), 1000));\nconst promise2 = new Promise(resolve => setTimeout(() => resolve(2), 2000));\n\nPromise.all([promise1, promise2])\n  .then(results => console.log('所有操作完成：', results)) // [1, 2]\n  .catch(error => console.error('错误：', error));\n\nPromise.race([promise1, promise2])\n  .then(result => console.log('最快完成的操作结果：', result)) // 1\n  .catch(error => console.error('错误：', error));\n```","src/content/interview/解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作.mdx","77da42125a832c58","解释 Promise 的三种状态及其转换关系，如何使用 Promise 处理异步操作.mdx","详细解释-css-中的层叠上下文以及如何控制元素的层叠顺序",{id:404,data:406,body:409,filePath:410,digest:411,legacyId:412,deferredRender:21},{title:407,category:362,pubDate:408,heroImage:15},"详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序",["Date","2025-07-13T09:10:51.000Z"],"层叠上下文（Stacking Context）是 CSS 中一个三维概念，指元素在 Z 轴（垂直于屏幕的轴线）上的渲染层级关系。拥有层叠上下文的元素会像一个“容器”，其内部元素的层叠顺序仅在该容器内生效，不会影响外部元素的层叠关系。\n\n## 层叠上下文的创建方式（常见）\n\n- 根元素（`<html>`）默认创建根层叠上下文。\n- 元素设置 `position: absolute` 或 `relative` 且 `z-index` 值不为 `auto`。\n- 元素设置 `position: fixed` 或 `sticky`。\n- 元素设置 `display: flex` 或 `inline-flex`，且子元素 `z-index` 值不为 `auto`（此时子元素会创建层叠上下文）。\n- 元素设置 `opacity` 值小于 1。\n- 元素设置 `transform` 值不为 `none`。\n- 元素设置 `mix-blend-mode` 值不为 `normal` 等。\n\n## 层叠顺序（同一层叠上下文中元素的 Z 轴排列规则，从后到前）\n\n- **层叠上下文的背景和边框**：位于最底层。\n- **负`z-index`值的子元素**：值越小越靠后。\n- **非定位元素（`position: static`）**：按文档流顺序排列。\n- **`z-index: auto` 或 `z-index: 0`的定位元素**。\n- **正 `z-index` 值的子元素**：值越大越靠前。\n\n## 控制元素层叠顺序的方法\n\n- **利用 `z-index` 属性**：在同一层叠上下文中，通过设置 `z-index` 的正负值调整顺序（仅对定位元素或弹性盒子子元素生效）。注意：**`z-index` 仅在当前层叠上下文中有效，不同层叠上下文的元素比较时，父级层叠上下文的层级决定了子元素的整体层级。**\n- **调整层叠上下文的创建**：通过设置 `opacity`、`transform` 等属性让元素创建新的层叠上下文，使内部元素的层级顺序独立于外部。\n- **遵循文档流和定位规则**：非定位元素默认按文档流顺序层叠，后出现的元素会覆盖先出现的元素；定位元素会覆盖非定位元素（除非被更高级的层叠元素遮挡）。","src/content/interview/详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序.mdx","5f01afcfb82ed615","详细解释 CSS 中的层叠上下文，以及如何控制元素的层叠顺序.mdx","详细阐述-javascript-中的闭包闭包的用途及可能带来的问题",{id:413,data:415,body:418,filePath:419,digest:420,legacyId:421,deferredRender:21},{title:416,category:194,pubDate:417,heroImage:15},"详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题",["Date","2025-07-12T03:22:01.000Z"],"闭包是指在 JavaScript 中，一个函数内部嵌套了另一个函数，内部函数引用了外部函数的变量或参数，并且内部函数在外部函数执行完成后仍能够访问这些变量或参数，这样就形成了闭包。\n\n## 闭包的形成条件\n\n- 存在函数嵌套，即一个函数内部定义了另一个函数。\n- 内部函数引用了外部函数的变量或参数。\n- 内部函数被外部函数返回，或在外部函数外被引用。\n\n## 工作原理\n\n当外部函数执行时，会创建一个**执行上下文**，其中包含**函数的参数**、**局部变量**等信息。通常情况下，外部函数执行完成后，其执行上下文会被销毁，内部变量会被回收。但如果存在闭包，内部函数会**保留对外部函数变量对象的引用**，使外部函数的**执行上下文不会被销毁**，从而使内部函数在后续仍能访问这些变量。\n\n## 闭包的用途\n\n- **实现数据私有化**：通过闭包可以将变量封装在外部函数中，只允许内部函数提供的接口访问或修改，避免变量被外部随意访问或修改。例如：\n\n```js\nfunction createCounter() {\n  let count = 0;\n  \n  return {\n    increment: function () {\n      count++;\n    },\n    decrement: function () {\n      count--;\n    },\n    getCount: function () {\n      return count;\n    }\n  }\n}\n\nconst counter = createCounter();\n\ncounter.increment();\ncounter.decrement();\nconsole.log('getCount: ', counter.getCount());\n```\n\n- **保存变量状态**：在循环或异步操作中，闭包可以保存每次迭代的变量值，避免因变量共享导致的问题，比如：\n\n```js\nfor (let i = 0; i < 3; i++) {\n  (function (index) {\n    setTimeout(() => {\n      console.log(index);\n    }, 1000);\n  })(i);\n}\n```\n\n- **模块化开发**：利用闭包可以创建独立的模块，将模块内的函数和变量隐藏起来，只暴露必要的接口，实现代码的封装和隔离。\n\n## 可能带来的问题\n\n- **内存泄漏**：由于闭包会保留对外部函数变量对象的引用，导致这些变量无法被垃圾回收机制回收，长期累积可能会占用过多内存，影响页面性能。\n- **变量共享问题**：如果多个闭包引用同一个外部变量，可能出现变量值被意外修改的情况，需要谨慎处理。\n- **调试困难**：闭包使得变量的作用域链变得复杂，增加代码调试的难度。","src/content/interview/详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题.mdx","9fde409091a7224a","详细阐述 JavaScript 中的闭包，闭包的用途及可能带来的问题.mdx","请介绍-css-中的-bfc它的触发条件和应用场景",{id:422,data:424,body:427,filePath:428,digest:429,legacyId:430,deferredRender:21},{title:425,category:362,pubDate:426,heroImage:15},"请介绍 CSS 中的 BFC，它的触发条件和应用场景",["Date","2025-07-13T08:00:40.000Z"],"BFC（Block Formatting Context, 块级格式化上下文）是 CSS 中一种特殊的渲染环境，它就像一个容器的“容器”，容器内部的元素布局不会影响到外部元素，外部元素的布局也不会干扰容器内部。\n\n## 触发条件\n\n- 根元素（`<html>`）\n- 浮动元素（`float` 值为 `left` 或 `right`，且不为 `none`）\n- 绝对定位元素（`position` 值为 `absolute` 或 `fixed`）\n- 行内块元素（`display: inline-block`）\n- 表格单元格（`display: table-cell`，默认属性）\n- 表格标题（`display: table-caption`，默认属性）\n- overflow 值不为 `visible` 的块元素（如 `overflow: hidden`、`auto`、`scroll`）\n- 弹性元素（`display: flex`、`inline-flex` 的直接子元素）\n- 网格元素（`display: grid` 或 `inline-grid` 的直接子元素）等\n\n## 应用场景\n\n### 解决 margin 重叠问题\n\n当两个相邻的块级元素都设置了 margin 时，可能会出现 margin 重叠（取较大值），将她们放入不同的 BFC 容器中可避免重叠。\n\n### 清除浮动\n\n父元素内部子元素浮动时，父元素可能会因没有内容支撑而高度坍塌，给父元素触发 BFC 后，父元素会包裹住浮动的子元素，从而清除浮动影响。\n\n### 阻止元素被浮动元素覆盖\n\n当一个元素浮动时，可能会覆盖旁边的非浮动元素，给非浮动元素触发 BFC，可使它不被覆盖，保持与浮动元素并列的布局。","src/content/interview/请介绍 CSS 中的 BFC，它的触发条件和应用场景.mdx","2e75c336680a54f5","请介绍 CSS 中的 BFC，它的触发条件和应用场景.mdx","请对比-reactvue-和-angular-三大框架的特点和适用场景",{id:431,data:433,body:436,filePath:437,digest:438,legacyId:439,deferredRender:21},{title:434,category:184,pubDate:435,heroImage:15},"请对比 React、Vue 和 Angular 三大框架的特点和适用场景",["Date","2025-07-13T16:54:28.000Z"],"## React\n\n### 特点\n\n- **采用 JSX 语法，** 将 HTML 与 JavaScript 逻辑结合，代码结构清晰。\n- **基于组件化开发，强调单向数据流**，状态管理需结合 Redux 等工具。\n- **灵活性高，生态丰富，** 可用于Web端，移动端等多平台。\n- **学习曲线中等，需理解虚拟 DOM、生命周期（hooks时代为副作用管理）等概念。**\n\n### 适用场景\n\n大型复杂应用（如电商平台、管理系统等）、需要跨平台开发的项目，适合团队协作能力强、追求灵活性的团队。\n\n## Vue\n\n### 特点\n\n- **采用 HTML 模版语法**，更贴近传统前端开发习惯，易于上手。\n- **双向数据绑定**（Vue 2 基于 `Object.defineProperty`，Vue 3 基于 `Proxy`），简化表单处理等场景。\n- **渐进式框架**，可按需引入路由、状态管理（Vuex/Pinia）等功能，灵活性与易用性平衡。\n- **官方文档完整，社区活跃，生态体系健全（Vue Router、Vuex、Pinia等）。**\n\n### 适用场景\n\n中小型项目快速开发，初创公司产品快速迭代，对开发效率要求高的场景，也可胜任大型项目（如阿里、百度部分业务）。\n\n## Angular\n\n### 特点\n\n- **由 Google 开发，是一套完整的 MVC 框架。** 包括模板、依赖注入、路由等全套解决方案。\n- **基于 TypeScript 开发，** 强类型检查提升代码健壮性，但学习成本高。\n- **强调规范化，** 有严格的代码组织方式和开发流程，适合大型团队协作。\n- **内置功能丰富，**（如表单验证、HTTP客户端），但体积较大，初期加载速度可能受影响。\n\n### 适用场景\n\n企业级大型应用（如银行金融、政务系统等），需要严格规范和强类型支持的项目，适合有后端开发经验、注重工程化的团队。\n\n## 核心差异总结\n\n- **开发范式**：React偏函数式，Vue偏声明式，Angular偏面向对象。\n- **灵活性**：React > Vue > Angular。\n- **学习成本**：Angular > React > Vue。\n- **生态成熟度**：三者均有成熟生态体系。React 生态最广，Angular 最全面，Vue 最轻量化。","src/content/interview/请对比 React、Vue 和 Angular 三大框架的特点和适用场景.mdx","1b98da083341e06c","请对比 React、Vue 和 Angular 三大框架的特点和适用场景.mdx","解释浏览器的缓存机制包括强缓存和协商缓存以及如何设置缓存策略",{id:440,data:442,body:445,filePath:446,digest:447,legacyId:448,deferredRender:21},{title:443,category:298,pubDate:444,heroImage:15},"解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略",["Date","2025-07-14T05:11:58.000Z"],"浏览器缓存是指浏览器将已请求过的资源存储在本地，当再次请求相同资源时，直接从本地获取以减少网络请求，提升加速度。缓存机制主要分为**强缓存**和**协商缓存**，两者配合工作。\n\n## 强缓存\n\n强缓存是指浏览器直接根据本地缓存判断资源是否过期，若未过期则直接使用本地缓存，不向服务器发送请求。\n\n- **判断依据**：基于 HTTP 响应头中的 `Expires` 或 `Cache-Control` 字段。\n  - `Expires`（HTTP/1.0）: 是一个绝对相同（如 `Expires: Wed, 21 Oct 2026 07:28:00 GMT`），表示资源过期时间。若当前时间早于 `Expires`，则使用缓存。\n    - 缺点：依赖本地时间，若本地时间被修改，可能导致缓存失效或过期资源被使用。\n  - `Cache-Control`（HTTP/1.1，优先级高于 `Expires`）：通过相对时间控制缓存，常用值：\n    - `max-age=3600`：资源有效期为 3600 秒（1 小时），从请求成功时间开始计算。\n    - `public`：允许浏览器和中间代理（如 CDN）缓存该资源。\n    - `private`：仅允许浏览器缓存（默认值），中间代理不可缓存。\n    - `no-cache`：不使用强缓存，需进入协商缓存。\n    - `no-store`：完全不缓存资源，每次都需请求服务器。\n\n## 协商缓存\n\n当强缓存失效（资源过期）时，浏览器会想服务器发送请求，由服务器判断资源是否更新：若未更新，返回 304 状态码，浏览器使用本地缓存；若已更新，返回 200 状态码和新资源。\n\n- **判断依据**：基于请求头和响应头的 `Last-Modified/If-Modified-Since` 或 `ETag/If-None-Match` 字段。\n  - `Last-Modified/If-Modified-Since`：\n    - 服务器响应时通过 `Last-Modified` 返回资源最后修改（如 `Last-Modified: Wed, 21 Oct 2026 07:28:00 GMT`）。\n    - 浏览器再次请求时，通过 `If-Modified-Since` 携带该时间，服务器对比：若资源未修改，返回 304 状态码；若已修改，返回新资源和 200 状态码。\n      - 缺点：无法识别资源的细微修改（如内容不变但修改时间更新），精度为秒级。\n  - `ETag/If-None-Match`（优先级高于 `Last-Modified`）：\n    - 服务器响应时通过 `ETag` 返回资源的唯一标识（如 `ETag: \"5f8d02a1-1234\"`，由资源内容哈希生成）。\n    - 浏览器再次请求时，通过 `If-None-Match` 携带该标识，服务器对比：若标识一致（资源未变），返回 304 状态码；若已修改，返回新资源和 200 状态码。\n      - 优点：能更精准判断是否修改，适用于动态内容。\n  \n## 缓存策略设置\n\n- **静态资源（如 JS、CSS、图片）**：\n  - 采用 “强缓存为主，协商缓存为辅”。\n  - 设置较长的 `Cache-Control: max-age=31536000`（1年），同时对资源进行哈希命名（如 app.8f2d7.js）。当资源更新时，哈希值变化，浏览器会视为新资源并重新请求，避免缓存失效问题。\n- **动态资源（如 API 接口数据）**：\n  - 不使用强缓存（设置 `Cache-Control: no-cache`），依赖协商缓存。\n  - 服务器通过 `ETag` 或 `Last-Modified` 判断数据是否更新，减少重复数据传输。\n- **特殊资源（如 HTML）**：\n  - 通常设置 `Cache-Control: no-cache`（或短时间 `max-age`），确保用户每次访问都能获取最新页面结构，再通过协商缓存判断是否需要更新。\n\n## 缓存流程总结\n\n1. **浏览器请求资源时，先检查强缓存**：若未过期，直接使用本地缓存（状态码 200 OK (form cache)）。\n2. **若强缓存过期，进入协商缓存**：向服务器发送请求，服务器判断资源是否更新。\n3. **若资源未更新，返回 304，浏览器使用本地缓存**：若已更新，返回 200 和新资源，浏览器更新本地缓存。\n\n合理的缓存策略可大幅减少服务器压力，提升页面加载速度，是前端性能优化的核心手段之一。","src/content/interview/解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略.mdx","503e146659a7f060","解释浏览器的缓存机制，包括强缓存和协商缓存，以及如何设置缓存策略.mdx","详细解释浏览器的渲染过程包括-dom-树cssom-树的构建以及页面布局和绘制",{id:449,data:451,body:454,filePath:455,digest:456,legacyId:457,deferredRender:21},{title:452,category:224,pubDate:453,heroImage:15},"详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制",["Date","2025-07-15T03:10:09.000Z"],"浏览器的渲染过程是将 HTML、CSS、JavaScript 等资源转换为可视化页面的过程，主要分为以下几个核心步骤：\n\n## 1. 解析 HTML 构建 DOM 树\n\n- **解析 HTML**：浏览器接收 HTML 字节数据后，先将其转换为字符（基于编码如 UTF-8），再通过词法分析将字符转换为标签（如 `<div>`、`<p>`），最后通过语法分析构建节点间的父子关系。\n- **生成 DOM 树**：DOM（文档对象模型）是HTML的树形表示，每个标签对应一个节点，文本和属性也会作为节点的一部分。DOM 树描述了页面的结构，但不包含样式信息。\\*例如，`<html><body><p>Hello</p></body></html>`会生成以`<html>`为根节点，`<body>`为子节点，`<p>`为孙节点的 DOM 树。\n\n## 2. 解析 CSS 构建 CSSOM 树\n\n- **解析 CSS**：浏览器同时会解析 CSS 资源（包括`<style>`标签内的样式、`<link>`引入的外部 CSS），过程类似 HTML 解析：先转换为字符，再解析为 CSS 规则（如，选择器、属性键值对）。\n- **生成 CSSOM 树**：CSSOM（CSS 对象模型）是 CSS 规则的树形表示，每个节点对应 DOM 树中的节点，包含该节点的样式信息。CSSOM 树具有层级结构，子节点会继承父节点的样式（如`<body>` 的样式会被其下所有元素继承，除非被覆盖）。_例如，`body { color: black; } p { font-size: 16px; }` 会生成对应 `body` 和`p` 节点的 CSSOM 树，`p` 节点同时继承 `body` 的 `color` 属性。_\n\n## 3. 构建渲染树（Render Tree）\n\n渲染树是 DOM 树与 CSSOM 树的结合，仅包含需要显示的节点及其样式信息，不包含隐藏节点（如 `display: none` 的元素）。\n\n- 过程：遍历 DOM 树，为每个课间节点匹配 CSSOM 树中对应的样式规则，将节点和样式组合成渲染树节点。\n- 特点：渲染树中的节点（成为“渲染对象”）按其在页面中的显示顺序排列，为后续布局和绘制做准备。\n\n## 4. 布局（Layout/Reflow）\n\n布局阶段（也称“回流”）是根据渲染树计算每个节点的几何信息（如位置、尺寸、宽高）的过程。\n\n- 浏览器从渲染树的根节点开始，递归计算每个节点的坐标和大小，确定其在页面中的精确位置。\n- 布局结果会生成一个“盒模型”，描述每个元素的边距、边框、内边距、内容区域的几何信息。\n- 布局是一个流式过程，父节点的布局会影响子节点（如父元素宽度变化会导致子元素宽度重新计算）。\n\n## 5. 绘制（Painting）\n\n绘制阶段是根据渲染树和布局信息，将节点的样式（如颜色、背景、阴影）会知道屏幕上的过程。\n\n- 浏览器会渲染树的顺序，调用图形 API（如Skia、Direct2D）绘制每个节点的可视部分（如填充背景颜色、绘制文本、绘制边框）。\n- 绘制可以拆分为多个层（_例如，页面中的固定导航栏、滚动区域可作为独立层_），层之间独立绘制，提升效率。\n\n## 6. 合成（Compositing）\n\n合成阶段将页面的所有绘制层合并为一个图层，并显示在屏幕上。\n\n- 对于有重叠的层（如悬浮的弹窗覆盖在背景层上），浏览器会按层的 Z 轴顺序（层叠上下文）进行合成，确保正确的显示顺序。\n- 现代浏览器会利用 GPU 加速合成的过程，尤其是涉及动画、transform等操作时，可避免重绘整个页面，提升性能。\n\n## 总结浏览器渲染过程\n\n1. 解析 HTML -> 生成 DOM 树\n2. 解析 CSS -> 生成 CSSOM 树\n3. 结合 DOM 与 CSSOM -> 生成渲染树\n4. 根据渲染树 -> 计算布局（几何信息）\n5. 根据布局信息 -> 绘制节点样式\n6. 合成所有图层 -> 显示在屏幕上\n\n这个过程是逐步进行的，浏览器会优先渲染首屏内容，同时继续解析和渲染剩余内容。理解渲染过程有助于优化页面性能（如减少布局和绘制次数）。","src/content/interview/详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制.mdx","184e28f94a046acb","详细解释浏览器的渲染过程，包括 DOM 树、CSSOM 树的构建以及页面布局和绘制.mdx","请设计一个大型前端项目的目录结构并说明其设计思路",{id:458,data:460,body:463,filePath:464,digest:465,legacyId:466,deferredRender:21},{title:461,category:288,pubDate:462,heroImage:15},"请设计一个大型前端项目的目录结构，并说明其设计思路",["Date","2025-07-15T16:50:28.000Z"],"大型前端项目的目录结构设计需满足 **可扩展性**、**可维护性** 和 **团队协作效率**，核心思路是“按功能职责拆分、按业务模块鳄梨、规范通用资源位置”。以下是一个典型的目录接哦顾设计：\n\n```ts\nsrc/\n├── api/                 # 接口层：统一管理API请求\n│   ├── index.js         # 接口入口（导出所有API）\n│   ├── user.js          # 用户相关接口（登录、信息等）\n│   └── order.js         # 订单相关接口\n├── assets/images/              # 静态资源：不经过编译的资源\n│   ├── images/          # 图片资源（按业务模块子目录划分）\n│   ├── fonts/           # 字体文件\n│   └── styles/          # 全局样式（如reset.css、variables.scss）\n├── components/          # 组件库\n│   ├── common/          # 通用组件（按钮、输入框等，可复用至全项目）\n│   ├── business/        # 业务组件（如订单卡片、商品列表，与业务强相关）\n│   └── layout/          # 布局组件（头部、侧边栏、页脚等）\n├── config/              # 配置文件\n│   ├── constants.js     # 常量定义（如状态码、路由路径）\n│   ├── theme.js         # 主题配置（颜色、字体大小等）\n│   └── env.js           # 环境变量（区分开发/测试/生产）\n├── hooks/               # 自定义钩子：封装可复用的逻辑\n│   ├── useAuth.js       # 权限相关钩子（如登录状态判断）\n│   └── usePagination.js # 分页逻辑钩子\n├── layouts/             # 页面布局：不同页面的整体结构\n│   ├── MainLayout.vue   # 主布局（带侧边栏和头部）\n│   └── BlankLayout.vue  # 空白布局（如登录页）\n├── router/              # 路由配置\n│   ├── index.js         # 路由入口（创建路由实例）\n│   ├── routes.js        # 路由规则（按模块拆分）\n│   └── guard.js         # 路由守卫（权限控制、登录拦截）\n├── store/               # 状态管理\n│   ├── index.js         # 状态入口（导出store实例）\n│   ├── modules/         # 模块化状态（用户、购物车等）\n│   └── plugins/         # 状态插件（如持久化）\n├── utils/               # 工具函数\n│   ├── format.js        # 格式化工具（日期、金额等）\n│   └── validator.js     # 校验工具（表单验证规则）\n├── views/               # 页面层：与路由一一对应\n│   ├── user/            # 用户模块页面\n│   │   ├── login.vue    # 登录页\n│   │   └── profile.vue  # 个人资料页\n│   └── order/           # 订单模块页面\n├── App.vue              # 根组件\n└── main.js              # 入口文件（初始化应用）\n```\n\n## 设计思路\n\n- **分层职责清晰**：从接口层（api）、状态层（store）到视图层（views），每层专注单一职责，避免代码混杂。\n- **业务与通用分离**：`components/common` 存放全项目复用组件，`components/business` 存放业务专属组件，便于维护和复用。\n- **模版化组织**：按业务模块（如 user、order）划分目录，团队成员可聚焦各自负责的模块，减少代码冲突。\n- **资源集中管理**：静态资源、配置文件、工具函数统一存放，避免散落各处导致查找困难。\n- **可扩展性预留**：通过 `plugins`、`hooks` 等目录，方便后期接入新功能（如埋点、性能监控）而不侵入核心代码。","src/content/interview/请设计一个大型前端项目的目录结构，并说明其设计思路.mdx","b1393ce996970247","请设计一个大型前端项目的目录结构，并说明其设计思路.mdx","谈谈你对-es6-中箭头函数的理解它与普通函数有哪些区别",{id:467,data:469,body:472,filePath:473,digest:474,legacyId:475,deferredRender:21},{title:470,category:194,pubDate:471,heroImage:15},"谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别",["Date","2025-07-13T06:57:23.000Z"],"ES6 中的箭头函数是一种简洁的函数声明方式，语法上使用 `=>` 来定义函数，其基本语法为 `(args) => {/* function body */}`，当参数只有一个时可以省略括号，函数体只有一条语句时可省略大括号和 `return` 关键字。\n\n## 箭头函数与普通函数的区别\n\n### 1. this指向\n\n这是最核心的区别。普通函数的 `this` 指向调用它的对象，在不同调用场景下（比如全局调用、对象方法调用、构造函数调用等） `this` 指向会动态变化；箭头函数没有自己的 `this`，它的 `this` 继承自外层作用域的 `this`，且在函数定义时就已确定，不会随调用方式改变。\n\n```js\nconst obj = {\n  name: '箭头函数',\n  normalFunc: function() {\n    // 普通函数 this 指向调用者 obj，输出 ‘箭头函数’\n    console.log(this.name);\n  },\n  arrowFunc: () => {\n    // 箭头函数 this 继承自外层，若外层是全局则为 undefined\n    console.log(this.name);\n  }\n}\n\nobj.normalFunc();\nobj.arrowFunc();\n```\n\n### 2. 构造函数\n\n普通函数可以作为构造函数使用 `new` 关键字创建实例，箭头函数不能作为构造函数，使用 `new` 调用会报错，因为箭头函数没有 `prototype` 属性。\n\n```js\nfunction NormalFunc() {}\nconst normalObj = new NormalFunc(); // 正常创建实例\n\nconst ArrowFunc = () => {};\nconst arrowObj = new ArrowFunc(); // 报错：ArrowFunc is not a constructor\n```\n\n### 3. arguments 对象\n\n普通函数内部有 `arguments` 对象，用于获取函数接收的所有参数；箭头函数没有 `arguments` 对象，若需获取参数可使用剩余参数 `...args`。\n\n```js\nfunction normalFunc() {\n  console.log(arguments); // 输出传入的参数列表\n}\nnormalFunc(1, 2, 3);\n\nconst arrowFunc = (...args) => {\n  console.log(args); // 使用剩余参数获取参数，输出[1, 2, 3]\n  // console.log(arguments); // 报错：arguments is not defined\n};\narrowFunc(1, 2, 3);\n```\n\n### 4. 原型\n\n普通函数有 `prototype` 原型对象，箭头函数没有 `prototype`。\n\n```js\nfunction normalFunc() {}\nconsole.log(normalFunc.prototype); // 存在原型对象\n\nconst arrowFunc = () => {};\nconsole.log(arrowFunc.prototype); // undefined\n```\n\n### 5. yield 关键字\n\n箭头函数不能用作 Generator 函数，不能使用 `yield` 关键字，普通函数可以通过 `function*` 定义 Generator 函数并使用 `yield`。","src/content/interview/谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别.mdx","feee0dc0efdf0e3b","谈谈你对 ES6 中箭头函数的理解，它与普通函数有哪些区别.mdx","请详细解释-html5-中的语义化标签及其作用",{id:476,data:478,body:481,filePath:482,digest:483,legacyId:484,deferredRender:21},{title:479,category:214,pubDate:480,heroImage:15},"请详细解释 HTML5 中的语义化标签及其作用",["Date","2025-07-10T16:59:10.000Z"],"HTML5 中的语义化标签是指那些能清晰描述自身内容含义的标签，例如：`<header>`、`<nav>`、`<aside>`、`<header>`、`<main>`、`<footer>`、`<article>`、`<section>`等。\n\n## 标签介绍\n\n常见的 HTML5 语义化标签如下\n\n### \\<header>\n\n用于定义页面或页面中某个区块的头部，通常包含标题、Logo、导航等内容。_比如网站的顶部导航栏区域可以用 `<header>` 标签包裹。_\n\n### \\<nav>\n\n专用于表示页面中的导航部分，集中放置链接，方便用户快速跳转到其他页面或页面内的其他部分，向网站的主导航菜单就适合放在 `<nav>` 标签中。\n\n### \\<aside>\n\n表示与主要内容相关但又可以独立的辅助内容信息，_如侧边栏的广告位、相关文章推荐、作者介绍等。_\n\n### \\<main>\n\n表示页面的主要内容区域，一个页面中通常只有一个 `<main>` 标签，它包含了与页面核心主题相关的内容，帮助开发者和浏览器快速定位页面的核心信息。\n\n### \\<footer>\n\n定义页面或者页面某个区块的底部，一般包含版本信息、联系方式、隐私政策链接等内容，_例如页面当中的版权声明区域一般用 `<footer>` 标签包裹。_\n\n### \\<article>\n\n用于定义独立的、完整的内容块，*如一篇博客文章、一条新闻、一个论坛帖子等，*这些内容即使脱离页面其他部分也能独立存在并被理解。\n\n### \\<section>\n\n用于将页面内容划分为多个不同的区块，每个区块通常有自己的主题，它可以包括标题、段落等内容，_比如在一篇博客文章内可以通过 `<section>` 标签来分隔不同章节。_\n\n## 总结\n\n语义化标签的作用主要体现在以下几个方面：\n\n- **提升代码的可读性和可维护性**：开发者通过页面标签就可以快速了解页面结构，便于团队协作和代码后期维护。\n- **有利于搜索引擎优化（SEO）**：搜索引擎可以通过语义化标签更准确地抓取和理解页面内容，提高页面在搜索结果中的排名。\n- **改善无障碍访问**：屏幕阅读器等辅助设备能借助语义化标签更好地解析页面内容，帮助残障人士更好地获取页面信息。\n- **规范页面结构**：是页面结构更清晰、合理，符合 Web 标准，减少了因使用无意义标签导致的结构混乱问题。","src/content/interview/请详细解释 HTML5 中的语义化标签及其作用.mdx","859ad070b8e0caa5","请详细解释 HTML5 中的语义化标签及其作用.mdx","谈谈你对-react-hooks-的理解它解决了什么问题常用的-hooks-有哪些",{id:485,data:487,body:490,filePath:491,digest:492,legacyId:493,deferredRender:21},{title:488,category:184,pubDate:489,heroImage:15},"谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些",["Date","2025-07-13T19:20:47.000Z"],"React Hooks 是 React 16.8 引入的特性，允许开发者在函数组件中使用状态（state）和其他 React 特性（如生命周期、上下文等），无需编写类组件。它的核心是将组件逻辑拆分为可复用的函数，让代码更简洁、易维护。\n\n## 解决的问题\n\n1. **类组件的复杂性**：类组件中存在 `this` 指向混乱、生命周期钩子函数中逻辑混杂（如同一逻辑分散在 `componentDidMount` 和 `componentDidUpdate` 中）等问题，Hooks 通过函数式编程简化了组件写法。\n2. **代码复用难题**：类组件中复用逻辑需依赖高阶组件（HOC）或渲染属性（Render Props），容易导致组件嵌套过深（“嵌套地狱”），Hooks 可直接将逻辑封装为自定义 Hook，实现更直观的复用。\n3. **状态与逻辑耦合**：类组件中相关的状态和操作逻辑常被拆分在不同生命周期中，Hooks 能将关联逻辑聚合在同一函数中，增强代码可读性。\n\n## 常用的 Hooks\n\n- **useState**：用于在函数中定义状态。\n- **useEffect**：处理组件的副作用（如数据请求、订阅、DOM 操作等），替代类组件的生命周期钩子。\n  - 第二个参数为空数组 `[]` 时，仅在组件挂载和卸载时执行（类似于 `componentDidMount` 和 `componentWillUnmount`）。\n  - 传入依赖数组 `[dep]`，当 `dep` 发生改变时执行（类似于 `componentDidUpdate`）。\n- **useContext**：用于访问 React 的上下文（Context），避免通过 Props 层层传递数据。\n- **useReducer**：用于管理复杂状态逻辑，类似 Redux 的 reducer，适合状态之间存在依赖或需要复杂更新的场景。\n- **useCallback**：缓存函数，避免因组件重新渲染导致子组件不必要的重新渲染（配合 `React.memo` 使用）。\n- **useMemo**：缓存计算结果，避免每次渲染时重复执行昂贵的计算。\n- **useRef**：用于获取 DOM 元素或存储跨渲染周期的可变值（其值改变不会触发组件重渲染）。\n\n此外，开发者还可以基于内置 Hooks 封装自定义 Hook（比如 useRequest 处理请求逻辑，useLocalStorage 操作本地存储）,进一步提升代码复用性。","src/content/interview/谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些.mdx","df992168ff5cd7d6","谈谈你对 React Hooks 的理解，它解决了什么问题？常用的 Hooks 有哪些.mdx","谈谈你对前端微服务的理解它的实现方式和优势",{id:494,data:496,body:499,filePath:500,digest:501,legacyId:502,deferredRender:21},{title:497,category:288,pubDate:498,heroImage:15},"谈谈你对前端微服务的理解，它的实现方式和优势",["Date","2025-07-15T17:22:50.000Z"],"前端微服务（又称微前端）是将大型前端应用拆分为 **独立开发**、**独立部署**、**技术栈无关** 的小型应用（微应用），通过主应用集成运行的架构模式。\n\n## 核心思想\n\n- **技术栈无关**：每个微应用可选择不同框架（如 React、Vue、Angular），团队自主决策。\n- **独立部署**：微应用单独构建、发布，不影响其他应用，CI/CD 流程高效。\n- **运行时集成**：主应用负责微应用的加载、路由分发和通信，用户体验一致。\n\n## 实现方式\n\n### 1. 基于路由分发（最常用）\n\n主应用通过路由匹配加载对应微应用（如 `/user` 加载用户微应用，`/order` 加载订单微应用）。\n\n- 代表工具：`qiankun`（基于 single-spa 封装，支持沙箱隔离和预加载）。\n- 原理：主应用动态加载微应用的 JS/CSS，通过生命周期钩子（`bootstrap`、`mount`、`unmount`）管理微应用状态。\n\n### 2. 基于 Web Components\n\n微应用封装为 Web Components 自定义元素，主应用通过标签（如 `<user-app>`）直接使用。\n\n- 优势：天然隔离（Shadow DOM），跨框架兼容。\n- 局限：适合组件级集成，复杂应用路由管理较繁琐。\n\n### 3. 基于 iframe\n\n主应用通过 iframe 嵌入微应用，利用 iframe 的天然隔离型。\n\n- 优势：实现简单，完全隔离（样式、JS 互不干扰）。\n- 局限：性能损耗大，通信依赖 `postMessage`，用户体验割裂（如导航同步困难）。\n\n## 优势\n\n- **团队自治**：不同团队负责不同微应用，减少协作冲突。\n- **增量升级**：可逐步将旧系统迁移为微应用，无需一次型重构。\n- **技术栈灵活**：新功能可尝试新技术栈，降低技术选型风险。\n- **故障隔离**：单个微应用崩溃不影响整个系统。","src/content/interview/谈谈你对前端微服务的理解，它的实现方式和优势.mdx","d63ced796997b606","谈谈你对前端微服务的理解，它的实现方式和优势.mdx","谈谈你对-css-预处理器如-sassless的理解它们有哪些特性和优势",{id:503,data:505,body:508,filePath:509,digest:510,legacyId:511,deferredRender:21},{title:506,category:362,pubDate:507,heroImage:15},"谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势",["Date","2025-07-13T15:48:24.000Z"],"CSS 预处理器是一种扩展 CSS 语法的工具，它引入了编程语言的特性（如变量、函数、嵌套、混合等），允许开发者使用更高效的可维护的方式编写 CSS 代码，最终会被编译成普通的 CSS 代码供浏览器识别。常见的预编译器有 Sass、Less、Stylus 等。\n\n## 核心特性\n\n- **变量（Variables）**：可定义重复使用的值（如颜色、尺寸等），修改变量时所有引用处自动更新，减少冗余。\n- **嵌套（Nesting）**：允许样式按 HTML 层级嵌套编写，清晰反映 DOM 结构，避免重复书写父选择器。\n- **混入（Mixins）**：封装可复用的样式片段（如兼容代码、复杂布局），通过 `@include` 调用，支持参数传递。\n- **继承（Inheritance）**：通过 `@extend` 让一个选择器继承另一个选择器的样式，减少代码重复。\n- **函数与运算（Functions & Operations）**：支持数学计算（如加减、颜色计算等）和自定义函数，动态生成样式值。\n- **模块化（Modules）**：可将样式拆分到多个文件，通过 `@import` 合并，便于大型项目的代码组织。\n\n## 优势\n\n1. **提高开发效率**：变量、混入等特性减少重复代码，嵌套语法简化层级样式编写。\n2. **增强可维护性**：模块化拆分使代码结构清晰，变量和继承让样式修改更便捷，降低维护成本。\n3. **支持复杂逻辑**：通过函数、条件判断、循环等特性，实现动态样式生成（如主题切换、响应式适配）。\n4. **规范开发流程**：强制团队采用统一的变量命名、文件结构，提高代码一致性。\n5. **兼容旧环境**：可通过混入生成浏览器前缀（如 `-webkit-`、`-moz-` 等），简化兼容处理。\n\n总之，预处理器解决了原生 CSS 在大型项目中面临的冗余、维护难等问题，是现代前端工程化中不可或缺的工具。","src/content/interview/谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势.mdx","f11194c21922b290","谈谈你对 CSS 预处理器（如 Sass、Less）的理解，它们有哪些特性和优势.mdx","谈谈你对懒加载和预加载的理解它们的实现方式和适用场景",{id:512,data:514,body:517,filePath:518,digest:519,legacyId:520,deferredRender:21},{title:515,category:298,pubDate:516,heroImage:15},"谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景",["Date","2025-07-14T06:31:58.000Z"],"## 懒加载（Lazy Loading）\n\n懒加载是一种 \"按需加载\" 的策略，指资源（如图片、组件、数据）在初始化时不加载，仅当用户需要访问（如滚动到可视区域）时才加载，目的是减少首屏加载时间和资源消耗。\n\n### 实现方式\n\n1. **图片懒加载**：\n\n- 初始化时，图片的 `src` 属性设为占位符（或不设置），将真实地址存放在 `data-src` （或 `data-lazy`）属性中。\n- 通过监听 `scroll`、`resize` 事件或使用 `IntersectionObserver` API，判断图片是否进入可视区域。\n- 当图片进入可视区域时，将 `data-src` 的指赋给 `src`，触发图片加载。\n\n```html\n<img\n  class=\"lazy\"\n  src=\"placeholder.jpg\"\n  data-src=\"real.jpg\"\n  alt=\"Lazy Loaded Image\"\n/>\n\n<script>\n  const observer = new IntersectionObserver((entries) => {\n    entries.forEach((entry) => {\n      if (entry.isIntersecting) {\n        const img = entry.target;\n\n        img.src = img.dataset.src;\n        // 加载后停止观察\n        observer.unobserve(img);\n      }\n    });\n  });\n\n  document.querySelectorAll(\".lazy\").forEach((img) => observer.observe(img));\n</script>\n```\n\n2. **组件/路由懒加载**：\n\n- 在 SPA（单页应用）中，通过 Webpack 的 `import()` 语法实现路由组件按需加载。\n- 示例（React）：const Home = React.lazy(() => import('./Home'));\n- 示例（Vue）：const Home = () => import('./Home.vue');\n\n### 适用场景\n\n- 长列表图片（如电商商品列表、社交媒体 feed 流）。\n- 内容较多的页面（如新闻详情页中的非首屏图片）。\n- 路由组件较多的 SPA，避免首屏加载所有组件导致的性能问题。\n\n## 预加载（Preloading）\n\n预加载是一种“提前加载”策略，指在浏览器空闲时或提前加载用户可能即将需要的资源（如后续页面的图片、关键 JS/CSS），当用户访问时可直接从缓存中获取，提升响应速度。\n\n### 实现方式\n\n- `<link rel=\"preload\">`：\n  - 用于提前加载关键资源（如字体、核心 JS/CSS），浏览器会优先加载这些资源，不阻塞页面渲染。\n  - 示例：`<link rel=\"preload\" href=\"critical.css\" as=\"style>`（`as`指定资源类型，确保正确加载）。\n- `<link rel=\"prefetch\">`：\n  - 用于加载未来可能需要的资源（如下一页数据、非首屏组件），浏览器会在空闲时加载，优先级较低。\n  - 示例：`<link rel=\"prefetch\" href=\"next-page.js\">`。\n- **JS 动态预加载**：\n  - 通过 `new Image()` 预加载图片，或 `import()` 预加载 JS 模块。\n  - 示例：`const img = new Image(); img.src = 'future-image.jpg';`。\n\n### 适用场景\n\n- 首屏关键资源（如核心 CSS、字体文件），确保快速渲染。\n- 用户大概率会访问的后续内容（如分页列表的下一页数据、导航菜单对应的页面资源）。\n- 交互触发的资源（如点击按钮后弹出的弹窗组件）。\n\n## 懒加载与预加载的区别\n\n| 维度       | 懒加载                     | 预加载                            |\n| ---------- | -------------------------- | --------------------------------- |\n| 加载时机   | 资源进入可视区域/需要时    | 浏览器空闲时/提前加载             |\n| 目的       | 减少首屏加载时间，节省带宽 | 提升后续操作的响应速度            |\n| 资源优先级 | 低（按需加载）             | 高（`preload`）或低（`prefetch`） |\n| 适用资源   | 非首屏、非关键资源         | 即将需要的关键/可能需要的资源     |\n\n## 注意事项\n\n- 懒加载避免过度使用，否则可能导致用户滚动时资源加载延迟、影响体验（可配合占位符优化）。\n- 预加载需合理选择资源，避免加载过多不必要的资源导致带宽浪费和性能损耗（如 `prefetch` 过多会占用空闲资源）。\n\n两者结合使用可最大化优化用户体验：懒加载减少首屏负担，预加载提升后续交互速度，是前端性能优化的重要手段。","src/content/interview/谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景.mdx","cc91412e3c899160","谈谈你对懒加载和预加载的理解，它们的实现方式和适用场景.mdx","谈谈你对模块化的理解commonjsamdcmd-和-es6-模块有哪些区别",{id:521,data:523,body:526,filePath:527,digest:528,legacyId:529,deferredRender:21},{title:524,category:204,pubDate:525,heroImage:15},"谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别",["Date","2025-07-14T17:57:44.000Z"],"模块化是将复杂程序拆分为可复用、可维护的独立模块的开发模式，每个模块拥有自己的作用域，通过特定语法暴露接口供其他模块使用，同时可依赖其他模块。其核心价值在于解决代码复用、命名冲突、依赖管理等问题，是现代前端工程化的基础。\n\n## CommonJS、AMD、CMD 和 ES6 模块的区别\n\n| 维度     | CommonJS                      | AMD                      | CMD                                    | ES6模块（ESM）             |\n| ------------ | ----------------------------- | ------------------------ | -------------------------------------- | -------------------------- |\n| **适用环境** | 服务端（Node.js） ｜ 浏览器端 | 浏览器端                 | 浏览器端、服务端（Node.js 13.2+ 支持） |\n| **加载方式** | 同步加载（运行时加载）        | 异步加载（提前加载依赖） | 异步加载（就近加载依赖）               | 静态加载（编译时确定依赖） |\n| **依赖处理** | 运行时才解析依赖，加载顺序由代码执行顺序决定 | 定义模块时需提前声明所有依赖（`deps` 数组） | 依赖就近书写，在 `require` 时才加载 | 编译时分析依赖，`import` 必须放在模块顶部 |\n| **暴露模块方式** | `module.exports` 或 `exports` | `define` 函数的返回值 | `define` 函数的返回值 | `export`（命名导出）或`export default`（默认导入） |\n| **引入模块方式** | `require('模块路径')` | `require`回调函数中获取依赖 | `require('模块路径')` | `import('命名导入')` 或 `import ... from`（默认导入） |\n| **执行时机** | 模块加载时执行，缓存结果，再次加载直接取缓存 | 依赖加载完成后执行模块回调 | 模块加载后，遇到 `require` 时执行依赖 | 编译时静态分析，模块内代码在导入时执行（只执行一次） |\n| **典型实现/工具** | Node.js原生支持 | RequireJS | SeaJS | 浏览器原生支持（`<script type=\"module\">`）、Webpack等 | \n\n## 关键差异解析\n\n### 1. 加载机制\n\n- CommonJS 为同步加载，适合服务器端（文件存储在本地，加载速度快），但不适合浏览器端（同步加载会阻塞页面渲染）。\n- AMD/CMD 为异步加载，专为浏览器端设计，避免阻塞。AMD 强调 “依赖前置”（提前声明所有依赖），CMD 强调“依赖就近”（用到时再加载）。\n\n### 2. 模块作用域\n\n- CommonJS 模块中，`module.exports` 是模块的对外接口，每个模块是一个独立的 `module` 对象。\n- ES6 模块中，`export` 导出的是绑定（而非值），导入的变量会跟随导出端变化（动态关联），而 CommonJS 导出的是值的拷贝。\n\n### 3. 循环依赖处理\n\n- CommonJS 处理循环依赖时，会返回未完全执行的模块缓存，可能导致部分变量未定义。\n- ES6 模块通过静态分析，循环依赖时能正确饮用模块的实时状态，更可靠。\n\n## 总结\n\n- CommonJS 是服务器端模块化的标准，同步加载合适本地文件。\n- AMD/CMD 是浏览器端早期异步模块化方案，现已逐渐被 ES6 模块取代。\n- ES6 模块是官方标准，兼顾浏览器和服务器端，静态加载、动态绑定等特性使其成为现代前端模块化的首选，也是 Webpack、Vite等构建工具的默认模块系统。","src/content/interview/谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别.mdx","6c7f93eb66cce5c8","谈谈你对模块化的理解，CommonJS、AMD、CMD 和 ES6 模块有哪些区别.mdx"];

export { _astro_dataLayerContent as default };
