<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/jpeg" href="/images/favicon.jpeg"><meta name="generator" content="Astro v5.12.0"><!-- Canonical URL --><link rel="canonical" href="https://lihaizhong.github.io/blog/"><!-- RSS Feed Discovery --><link rel="alternate" type="application/rss+xml" title="RSS" href="/rss.xml"><!-- Primary Meta Tags --><title>竹简记书</title><meta name="title" content="竹简记书"><meta name="description" content="合抱之木生于毫末，九层之台起于累土，千里之行始于足下"><!-- Open Graph / Facebook --><!-- <meta property="og:type" content="website" />
<meta property="og:url" content={Astro.url} />
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:image" content={new URL(image, Astro.url)} /> --><!-- Twitter --><!-- <meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={new URL(image, Astro.url)} /> --><link rel="stylesheet" href="/astro_assets/asset.CTGH2W9s.css">
<style>.post-list[data-v-c357ad79]{list-style-type:none;padding:unset}.post-list .post-item[data-v-c357ad79]{display:flex}time{flex:0 0 130px;font-style:italic;color:#595959}.post-list .post-category[data-v-c357ad79]{white-space:nowrap}.post-list .post-item .post-link[data-v-c357ad79]:visited{color:#8e32dc}.pagination-container[data-v-c357ad79]{margin-top:60px}
</style></head> <body> <header class="box-border mt-9 mx-auto py-5 site-header" data-astro-cid-3ef6ksr2> <!-- <h2 class="mb-1 text-3xl font-bold">{SITE_TITLE}</h2> --> <nav class="mb-2" data-astro-cid-3ef6ksr2> <a href="/" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 首页 </a> <a href="/blog" class="text-xl inline-block no-underline font-bold underline" data-astro-cid-3ef6ksr2="true"> 博客 </a> <a href="/interview" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 面试题 </a> <a href="/archive" class="text-xl inline-block no-underline" data-astro-cid-3ef6ksr2="true"> 归档 </a> <a href="https://github.com/lihaizhong" class="text-xl inline-block no-underline" target="_blank" data-astro-cid-3ef6ksr2="true"> GitHub </a> </nav> <p class="my-3 text-base text-gray-400" data-astro-cid-3ef6ksr2>合抱之木生于毫末，九层之台起于累土，千里之行始于足下</p> </header>  <article> <style>astro-island,astro-slot,astro-static-slot{display:contents}</style><script>(()=>{var e=async t=>{await(await t())()};(self.Astro||(self.Astro={})).only=e;window.dispatchEvent(new Event("astro:only"));})();</script><script>(()=>{var A=Object.defineProperty;var g=(i,o,a)=>o in i?A(i,o,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[o]=a;var d=(i,o,a)=>g(i,typeof o!="symbol"?o+"":o,a);{let i={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t),11:t=>1/0*t},o=t=>{let[l,e]=t;return l in i?i[l](e):void 0},a=t=>t.map(o),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([l,e])=>[l,o(e)]));class y extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var b;if(!this.hydrator||!this.isConnected)return;let e=(b=this.parentElement)==null?void 0:b.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let c=this.querySelectorAll("astro-slot"),n={},h=this.querySelectorAll("template[data-astro-template]");for(let r of h){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("data-astro-template")||"default"]=r.innerHTML,r.remove())}for(let r of c){let s=r.closest(this.tagName);s!=null&&s.isSameNode(this)&&(n[r.getAttribute("name")||"default"]=r.innerHTML)}let p;try{p=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(r){let s=this.getAttribute("component-url")||"<unknown>",v=this.getAttribute("component-export");throw v&&(s+=` (export ${v})`),console.error(`[hydrate] Error parsing props for component ${s}`,this.getAttribute("props"),r),r}let u;await this.hydrator(this)(this.Component,p,n,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),c.disconnect(),this.childrenConnectedCallback()},c=new MutationObserver(()=>{var n;((n=this.lastChild)==null?void 0:n.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});c.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),c=this.getAttribute("client");if(Astro[c]===void 0){window.addEventListener(`astro:${c}`,()=>this.start(),{once:!0});return}try{await Astro[c](async()=>{let n=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),n?import(n):()=>()=>{}]),u=this.getAttribute("component-export")||"default";if(!u.includes("."))this.Component=h[u];else{this.Component=h;for(let f of u.split("."))this.Component=this.Component[f]}return this.hydrator=p,this.hydrate},e,this)}catch(n){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,n)}}attributeChangedCallback(){this.hydrate()}}d(y,"observedAttributes",["props"]),customElements.get("astro-island")||customElements.define("astro-island",y)}})();</script><astro-island uid="11ImcU" component-url="/astro_assets/app.PYHgcz_E.js" component-export="default" renderer-url="/astro_assets/app.CHmg8Y6V.js" props="{&quot;posts&quot;:[1,[[0,{&quot;id&quot;:[0,&quot;即时通信技术——SSE.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;即时通信技术——SSE&quot;],&quot;description&quot;:[0,&quot;有时候服务端并不能及时更新数据，导致客户端需要通过一些手段来获取真正最新的数据。这类的手段有很多种，例如轮询、长轮询、WebSocket以及我们今天要讲的SSE通信技术。这篇文章主要介绍SSE的使用以及它与其它技术之间的异同。&quot;],&quot;pubDate&quot;:[3,&quot;2023-11-20T19:14:07.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;import wxRequest from \&quot;../../assets/images/request.png\&quot;;\n\n有这样一种场景，我们提交了一份表单，服务端进行处理。由于这份表单的处理非常复杂，服务端处理需要非常长的时间或者服务端依赖第三方无法给出确切的时间，为了避免影响用户操作，你会使用什么方式呢？\n\n我觉得这里核心思想是将 **提交表单** 和 **查询状态** 拆分，这样就仅仅只是 **查询状态** 的问题了。我想到了以下几种方式：\n\n- 提交表单后，**轮询** 查询状态\n- 提交表单后，马上发起一个 **长轮询** 查询状态\n- 提交表单后，通过 **WebSocket** 查询状态\n- 提交表单后，马上发起一个 **SSE** 查询状态\n\n方法有很多，我在这里就依次介绍它们的优缺点，当然重点还是讲讲我们的新工具 **SSE**。\n\n## 介绍\n\n### 轮询（Polling）\n\n轮询是客户端按照固定时间间隔（如每1秒、每5秒）主动向服务器发送请求，询问是否有新数据。服务器收到请求后，无论是否有新数据，都会立即响应。\n\n- 优点：\n  - **实现简单**：客户端只需定时发送 HTTP 请求，服务器正常处理即可，无需特殊逻辑，开发成本低。\n  - **兼容性好**：基于标准的 HTTP 协议，所有浏览器和服务器都支持，无需考虑兼容性问题。\n  - **资源可控**：客户端可以通过调整轮询间隔（如用户操作时缩短间隔，空闲时延长间隔），灵活控制请求频率，减少不必要的资源消耗。\n- 缺点：\n  - **实时性差**：数据更新的延迟取决于轮询间隔。_例如，间隔 10 秒时，新数据可能最多延迟 10 秒才能被客户端获取。_\n  - **资源浪费严重**：大部分请求是“无效”的（服务器无新数据），但仍会消耗客户端的网络带块、CPU/内存，以及服务器的处理能力和连接资源。尤其在高并发场景下，可能导致服务器压力过大。\n  - **频繁连接**：每次请求都需要建立 HTTP 连接（虽然 HTTP/1.1 有长连接优化，但仍有请求头、握手等开销），增加网络负载。\n- 适用场景：\n  - 实时性要求低（如天气预报、新闻列表等）、用户量小、服务资源有限的场景。\n- 不适用场景：\n  - 实时性要求高（如聊天、实时监控）、高并发场景。\n\n### 长轮询（Long Polling）\n\n场论序是对轮询的改进：客户端发送请求后，服务端不会立即返回响应，而是将请求“挂起”（保持连接），等待有新数据产生或超时后，再返回响应；客户端收到响应后，立即发送下一个请求，重复此过程。\n\n- 优点：\n  - **实时性较好**：服务器一旦有新数据，会立即通过挂起的连接返回，延迟远低于轮询（仅取决于数据产生时间和网络传输耗时）。\n  - **减少无效请求**：相比轮询，长轮询避免了固定间隔的无效请求，只有当数据更新或超时后才会返回，降低了网络和服务器的资源消耗。\n  - **兼容性好**：同样基于 HTTP 协议，大部分浏览器和服务器都支持，无需依赖特殊技术。\n- 缺点：\n  - **服务器资源占用高**：服务器需要保持大量“挂起”的连接（每个客户端一个），这会消耗服务器的内存和文件描述符（尤其在高并发场景下），对服务器的并发处理能力要求较高。\n  - **超时处理复杂**：需要合理设置超时时间（避免连接过久导致客户端断开），同时客户端需处理连接异常中断的情况（如网络波动），开发逻辑比较复杂。\n  - **仍有连接开销**：虽然减少了请求次数，但每次连接仍有 HTTP 头、握手等开销，且连接挂起期间仍占用网络资源。\n- 适用场景：\n  - 实时性要求中等（如社交媒体通知、在线客服）、用户量适中的场景。\n- 不适用场景：\n  - 超大规模并发（如百万级用户同时连接）、服务器资源紧张的场景（可能因挂起连接过多崩溃）。\n\n### WebSocket\n\nWebSocket是一种 **全双工通信协议**（RFC6455 定义），通过一次 HTTP 握手后，建立持久化的 TCP 连接，允许客户端和服务器 **双向实时发送数据**（客户端可主动发，服务器也可主动发），且数据传输格式灵活（文本、二进制等）。\n\n- 优点：\n  - **实时性极强**\n    - 建立连接后，客户端和服务器可随时双向发送数据，无需像轮询/长轮询那样反复建立连接，延迟极低（仅受网络传输和数据处理耗时影响），适合高频实时交互场景（如在线游戏、实时协作工具）。\n  - **低开销**\n    - 仅需一次 HTTP 握手，之后基于 TCP 连接直接传输数据，无需重复发送 HTTP 头信息，减少网络带宽消耗。\n    - 数据帧格式简洁（相比 HTTP 协议），进一步降低传输成本。\n  - **全双工通信**\n    - 客户端和服务器可平等地主动发送数据，无需依赖“客户端请求-服务器响应”的模式，灵活满足双向交互需求（如连天中双方互发消息）。\n  - **支持二进制数据**\n    - 可直接传输二进制数据（如图片、音频片段），无需像 HTTP 那样进行 Base64 等编码转换，节省处理时间和带宽。\n- 缺点：\n  - **实现复杂**\n    - 需要服务器和客户端都支持 WebSocket 协议（需处理握手、数据帧解析、连接保活等逻辑），开发成本高于轮询/长轮询。\n    - 部分老旧浏览器不支持（如 IE10 及以下版本），需要额外做兼容处理（如降级为长轮询）。\n  - **服务器压力**\n    - 长时间保持大量 TCP 连接（每个客户端一个），对服务器的并发处理能力（如文件描述符、内存）要求较高，高并发场景下需特殊优化（如使用异步 IO 框架）。\n  - **网络兼容性问题**\n    - 部分代理服务器、防火墙可能拦截 WebSocket 连接（因协议升级过程涉及非标准 HTTP 方法）。\n    - 连接断开后需手动重连，需实现重连逻辑（如指数退避策略）以保证稳定性。\n- 适用场景\n  - 实时游戏、在线聊天、协作工具、高频交互场景\n- 不适用场景\n  - 仅需单向推送、老旧环境、服务器资源有限的场景\n\n### SSE\n\nSSE是一种 **单向通信协议**，基于 HTTP 协议：客户端通过一次HTTP请求建立持久连接，之后 **只能由服务器向客户端单向发送数据**，客户端无法通过该连接主动向服务器发送数据（若需客户端发送数据，需额外用 HTTP 请求）。数据以“文本事件流”格式传输，客户端通过监听事件处理数据。\n\n- 优点\n  - **实现简单**\n    - 基于标准 HTTP 协议，客户端只需用 `EventSourceAPI` 建立连接并监听事件，服务器只需格式持续输出数据（无需处理复杂的协议帧），开发成本低。\n    - 兼容性较好（除IE全系外，主浏览器均支持），且可通过 polyfill 兼容老旧浏览器。\n  - **轻量级**\n    - 复用 HTTP 长连接，无需协议升级，对代理服务器和防火墙兼容性优于 WebSocket。\n    - 服务器发送的数据格式为文本（或嵌套 JSON），解析简单，适合传输结构化文本数据。\n  - **自动重连**\n    - 客户端 `EventSource` 会自动处理连接断开后的重连（默认重试间隔逐渐增加），无需手动实现重连逻辑，稳定性较高。\n  - **资源消耗较低**\n    - 相比 WebSocket，SSE连接的维护成本更低（基于HTTP长连接，服务器处理逻辑简单），适合服务器向大量客户端单向推送数据的场景（如新闻推送、实时日志）。\n- 缺点\n  - **单向通信限制**\n    - 仅支持服务器向客户端发送数据，若客户端需向服务器反馈（如确认收到消息），必须额外使用HTTP请求，增加了逻辑复杂度（相比WebSocket的双向通信）。\n  - **仅支持文本数据**\n    - 只能传输 UTF-8 编码的文本数据，无法直接传输二进制数据（需先编码为Base64等格式，增加开销），不适合二进制场景（如实时图片传输）。\n  - **浏览器连接限制**\n    - 浏览器对单个域名的SSE并发连接数有限制（通常为6个），若需多连接，需通过多个子域名绕过，增加架构复杂度。\n  - **实时性略逊于 WebSocket**\n    - 虽然延迟较低，但因基于HTTP长连接，数据传输格式和协议 overhead 略高于 WebSocket，极端高频场景下性能稍差。\n- 适用场景\n  - 新闻推送、实时通知、股票行情、日志监控\n- 不适用场景\n  - 需客户端主动发送数据、传输二进制数据的场景\n\n通过介绍，你应该大概了解了各种即时通信技术的区别，下面我重点讲解下 **SSE**。\n\n## SSE数据的基本结构\n\nSSE是通过事件来响应实时数据的。每个事件之间通过空行来分隔。对于每一行来说，冒号（“:”）前面表示的是该行的类型，冒号后面则是对应的值。可能的类型包括：\n\n- 类型为空白，表示该行是注释，会在处理时被忽略。\n- 类型为 data，表示该行包含的是数据。以 data 开头的行可以出现多次。所有这些行都是该事件的数据。\n- 类型为 event，表示该行用来声明事件的类型。浏览器在收到数据时，会产生对应类型的事件。\n- 类型为 id，表示该行用来声明事件的标识符。\n- 类型为 retry，表示该行用来声明浏览器在连接断开之后进行再次连接之前的等待时间。\n\n## 如何使用SSE\n\n### 服务端\n\n```javascript\nclass ServerSentEvents {\n  constructor(req, res) {\n    this.request = req;\n    this.response = res;\n    this.count = 0;\n\n    // 必须设置这个headers\n    res.writeHead(200, {\n      \&quot;Content-Type\&quot;: \&quot;text/event-stream\&quot;,\n      Connection: \&quot;keep-alive\&quot;,\n      \&quot;Cache-Control\&quot;: \&quot;no-cache\&quot;,\n    });\n  }\n\n  /**\n   * 自定义事件--连接\n   */\n  connect() {\n    this.response.write(\&quot;event: connected\\n\&quot;);\n    this.response.write(\&quot;data: You are now subscribed\\n\&quot;);\n    this.response.write(`id: ${this.count}\\n\\n`);\n    this.count += 1;\n  }\n\n  /**\n   * 通用事件--消息\n   */\n  send(message) {\n    this.response.write(\&quot;event: message\\n\&quot;);\n    this.response.write(`data: ${message}\\n`);\n    this.response.write(`id: ${this.count}\\n\\n`);\n    this.count += 1;\n  }\n\n  /**\n   * 关闭连接\n   */\n  close() {\n    this.response.end(\&quot;OK\&quot;);\n  }\n}\n\n// router function\nfunction subscribe(req, res) {\n  const sse = new ServerSentEvents(req, res);\n\n  // Send a message on connection\n  sse.connect();\n\n  // Send a subsequent message every five seconds\n  setInterval(() =&gt; {\n    sse.send(new Date().toLocaleString());\n  }, 5000);\n\n  // Close the connection when the client disconnects\n  req.on(\&quot;close\&quot;, () =&gt; sse.close());\n}\n```\n\n### 浏览器端\n\n```javascript\n/**\n * 警告：当不通过HTTP/2使用时，SSE（server-sent events）会受到最大连接数的限制，这在打开多个选项卡时特别麻烦，\n * 因为该限制时针对每个浏览器的，并且被设置为一个非常低的数字（6）。该问题在Chrome和Firefox中被标记为”不会解决“。\n * 此限制是针对每个浏览器+域的，因此这意味着你可以跨所有选项卡打开6个SSE连接到www.example1.com，并打开6个SSE连\n * 接到www.example2.com。\n * 使用HTTP/2时，同一时间内HTTP最大连接数由服务器和客户端之间协商（默认为100）。\n */\nconst subscription = new EventSource(\&quot;/subscribe\&quot;);\n\n// Default Events\nsubscription.addEventListener(\&quot;open\&quot;, () =&gt; {\n  writeMessage(\&quot;Connection opened\&quot;);\n});\n\nsubscription.addEventListener(\&quot;error\&quot;, (err) =&gt; {\n  writeError(err);\n});\n\nsubscription.addEventListener(\&quot;message\&quot;, (event) =&gt; {\n  writeMessage(event.data);\n});\n\n// Define Custom Events\nsubscription.addEventListener(\&quot;connected\&quot;, () =&gt; {\n  writeMessage(\&quot;Subscription successful\&quot;);\n});\n\ndocument.getElementById(\&quot;close-btn\&quot;).addEventListener(\n  \&quot;click\&quot;,\n  () =&gt; {\n    subscription.close();\n    writeMessage(\&quot;Subscription closed\&quot;);\n  },\n  false,\n);\n```\n\n这样SSE整套流程就已经完成了。相对于WebSocket，SSE对服务端非常友好，只需要很小的改动，就可以支持整套流程。\n\n## 小程序如何做兼容\n\n&lt;img src={wxRequest.src} alt=\&quot;wx.request\&quot; width=\&quot;600\&quot; /&gt;\n\n我们看到虽然微信不支持完整的SSE，但是通过`enableChunked`属性我们可以实现流式数据接收。如果需要，通过我们合理的封装，完全可以实现绝大部分SSE功能。\n\n## SSE与WebSocket\n\n|                    | SSE  | WebSocket |\n| :----------------: | :--: | :-------: |\n| 是否支持服务端下发 |  是  |    是     |\n|  是否支持相互通信  |  否  |    是     |\n|  是否支持断线重连  |  是  |    否     |\n|  是否支持断点续传  |  是  |    否     |\n|   服务端接入成本   | 简单 |   复杂    |\n| 是否支持自定义事件 |  是  |    否     |\n\n\n## 增强版SSE\n\n浏览器原生的EventSource API在请求时存在诸多限制：\n\n- 仅支持 `GET` 请求，无法使用其他HTTP方法；\n- 不能传递请求体（body），需将所有信息编码到URL中，2️⃣URL长度通常限制在2000字符左右；\n- 无法自定义请求头；\n- 连接中断时，重试策略完全由浏览器控制（静默重试几次后停止），不适用于高可靠性应用。\n\n为此微软自研了一套基于Fetch API的增强型SSE -- [fetch-event-source](https://github.com/Azure/fetch-event-source)。它兼容标准事件流格式，同时解决了原生 API 的问题，提供了更多控制权：\n\n- 支持任意HTTP方法、自定义请求头和请求体，具备Fetch API的全部功能，甚至可替换默认的 `fetch` 实现；\n- 能访问响应对象，便于在解析事件前进行自定义验证（例如处理API网关的错误响应）；\n- 连接中断或出错时，可完全自定义重试策略；\n- 集成浏览器页面可见性 API：页面隐藏时自动关闭连接，重新可见时给予最后一个事件ID重试，减少服务器无效连接压力（可手动关闭此功能）。\n\n简而言之，这个库在保持服务器发送事件兼容性的同时，大幅提升了请求的灵活性、错误处理能力和资源优化能力。\n\n## 总结\n\n这就是SSE的基本功能与实现。SSE支持**自动重连**、**事件ID**和**自定义事件**的功能很大程度上减少了我们额外的开发工作。在我接触到的大部分场景下，它比WebSocket更适合，实现也更简单。如果你遇到这种需要异步处理的场景，可以优先考虑它。当然，如果你希望得到更强大的功能和更多的控制权，可以考虑微软推出的[fetch-event-source](https://github.com/Azure/fetch-event-source)作为企业级的解决方案。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/即时通信技术——SSE.mdx&quot;],&quot;digest&quot;:[0,&quot;9fdab71b539f2764&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;即时通信技术sse&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Git中reset和revert的区别.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;Git中reset和revert的区别&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2023-08-29T13:15:19.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;在现代程序开发过程中，我们常常使用**Git**作为我们的版本控制工具。**Git**的功能非常丰富，这里我就不做过多的介绍，只是介绍回退功能。在日常团队开发中，我们偶尔会遇到操作不当导致需要回退到特定版本的情况。这个时候，我们今天的主角就登场了————`git reset`和`git revert`。\n\n首先，我们可以使用`git log --pretty=oneline --abbrev-commit`来展示`commit记录`信息。大概会长这样：\n\n```bash\n51b41d2d3 (HEAD -&gt; dev_gift, origin/v11.1.35, origin/pianli_dev, origin/dev_gift) chore: @2dfire/meal-meta@1.0.117\nd5aa83954 share页面，售后详情页跳转模式修改\n8df946cf6 Merge branch &#39;v11.1.35&#39; of git.2dfire.net:firecode/firecode-mercury into v11.1.35\n39ad07ff2  share页面，会员卡页面跳转模式修改\n8ab1f776d update: AuthBox 渲染修复\n4eca779d2 Merge branch &#39;v11.1.35&#39; of https://git.2dfire.net/firecode/firecode-mercury into v11.1.35\na32cdfe32 update: AuthBox 组件 appId 获取改造，模版菜单特权卡0元商品领取流程修复\n720b4910b 小程序appId获取修改\naf22a2c0e update: meta sync\n6693f6337 Merge branch &#39;dev_message&#39; into v11.1.35\n405c45b8e Merge branch &#39;v11.1.35&#39; of git.2dfire.net:firecode/firecode-mercury into v11.1.35\n17bdd051b Merge branch &#39;dev_entrance&#39; into v11.1.35\nbb8ab8bf9 update: version\n8bc1418b4 Merge branch &#39;dev_meal_code&#39; into v11.1.35\n21c8aa53f Merge branch &#39;dev_gift_0821&#39; into v11.1.35\n```\n\n## git reset\n\n最先想到的应该是`git reset`，这是**Git**很早就有的功能。它会将`HEAD`指向指定的`commit记录`，并遗弃在它之后的所有记录。\n\n![git reset](../../assets/images/git-reset.png)\n\n```bash\n# 后面的commit内容存入工作区\ngit reset B&lt;commit id&gt;\n\n# 后面的commit内容直接丢弃\ngit reset --hard B&lt;commit id&gt;\n\n# 后面的commit内容存入暂存区\ngit reset --soft B&lt;commit id&gt;\n```\n\n从图中我们可以看到，这个过程会将`HEAD`指针指向记录B的位置。后续的提交会紧跟着记录B进行，而记录C和记录D将被抛弃。\n\n这里需要注意，`git reset`有一些参数，不同的参数会有不同的影响，可以指定是否复原索引或工作树内容。\n\n- **--mixed**（默认）：**重置索引，但不重置工作树**。即HEAD指向指定的`commit记录`，该`commit记录`后面所有的更改被存入工作区。\n- **--hard**：**重置索引和工作树**。即HEAD指向指定的commit记录，该`commit记录`后面所有更改被全部丢弃。\n- **--soft**：**不重置索引和工作树，但重置HEAD位置**。即HEAD指向指定的`commit记录`，该`commit记录`后面所有的更改被存入暂存区。\n\n另外还有 **--merge** 和 **--keep** 指令，这里不做过多介绍。如果想要了解更多，可以去[官网](https://git-scm.com/docs/git-reset/zh_HANS-CN)了解。\n\n使用上面的命令就可以做到回退到某个`commit记录`。注意因为回退会导致本地仓库的记录落后于远程仓库而无法同步，如需同步这次操作，必须**使用`git push --force`强制推送**。\n\n&gt; **注意**\n&gt;\n&gt; 将`git reset`与`--hard`一起使用时要非常小心，因为它会重置你的提交、暂存区和你的工作树。如果为正确使用此选项，则最终可能会丢失所编写的代码。\n\n## git revert\n\n如果你已经将提交推送到远程仓库，则建议尽量不要使用`git reset`，因为它会重建提交的历史记录。这会使与其他开发人员一起处理仓库并维护一致的提交历史变得非常困难。**这时候使用`git revert`可能会更好**。它通过创建一个全新的相反的提交来撤销先前提交所做的更改，所有这些都不会改变原有的`commit记录`。\n\n![git revert](../../assets/images/git-revert.png)\n\n```bash\ngit revert B&lt;commit id&gt;\n```\n\n从图中我们看到，这个过程并不会回退`HEAD`，只是在原有的基础上添加一条`commit记录`。这条`commit记录`与需要回退的记录保持相反的操作，已达到行为上的回撤效果。\n\n## 结论\n\n好了，两种回退的方式我们都简单介绍过了，相信大家也已经基本掌握了吧。我认为，只要掌握这两条基本准则，我们就能在回退时尽最大可能保证保证其他合作者。\n\n1. 如果需要回退的`commit记录`没有同步远程仓库，使用`git reset`操作。\n2. 如果需要回退的`commit记录`已同步远程仓库，使用`git revert`操作。\n\n我这里只对`git reset`和`git revert`做我们相对常用的介绍，仍然推荐大家到[官网](https://git-scm.com/book/en/v2)接受最新的资料学习。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/Git中reset和revert的区别.mdx&quot;],&quot;digest&quot;:[0,&quot;5a202a66e1545757&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;git中reset和revert的区别&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;V8引擎的垃圾回收机制.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;V8引擎的垃圾回收机制&quot;],&quot;description&quot;:[0,&quot;V8引擎作为目前最流行的JavaScript引擎，在浏览器端和NodeJS端都有使用。尤其在浏览器端，正是V8引擎的保驾护航，奠定了Chrome在浏览器端的霸主地位。早期的V8引擎采用Full-Codegen+Crankshaft架构，现在已经更换为Ignition+TurboFan架构。在垃圾回收方面是基于弱分代假说实现，并做了很多优化策略，进一步提升性能。&quot;],&quot;pubDate&quot;:[3,&quot;2023-08-15T07:15:01.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;V8引擎作为目前最流行的JavaScript引擎，在浏览器端和NodeJS端都有使用。尤其在浏览器端，正是V8引擎的保驾护航，奠定了Chrome在浏览器端的霸主地位。早期的V8引擎采用`Full-Codegen` + `Crankshaft`架构，现在已经更换为`Ignition` + `TurboFan`架构。在垃圾回收方面是基于**弱分代假说**实现，并做了很多优化策略，进一步提升性能。\n\n**弱分代假说认为，大多数对象只会存在很短的时间，而另一部分对象则会接近于永生。** 根据这个理论，V8把需要执行GC的内存空间**分为新生代和老生代**两部分，分别放置生命周期长度不同的对象并**使用不同的GC策略，从而显著提升 GC 效率**。\n\n## V8的内存构成\n\nV8管理的内存是有限制的。在64位操作系统环境中，新生代的默认大小为**32MB**，老生代的默认大小约为**1.4GB**；在32位操作系统环境减半。这样的设置基本上能胜任浏览器环境，但是对于有大文件场景的NodeJS环境有些吃力了。不过不用担心，V8为此已经做了很多的优化工作，以尽可能保证应用的流畅性。今天，我们先简单了解下V8的内存划分：\n\n- 新生代内存区（Young Generation/New Space）：大多数对象都在这里。\n- 老生代内存区（Old Generation/Old Space）：常驻内存的对象在这里。\n- 大对象区（Large Object Space）：大于1MB的对象会被放在这里，GC不会回收这部分内存。\n- 代码区（Code Space）：唯一拥有执行权限的内存。\n- Cell区、PropertyCell区、Map区（Cell Space、Property Cell Space、Map Space）：隐藏类的存放位置。这些空间中的每个空间都包含相同大小的对象，并且对它们指向的对象有一些限制，从而简化了回收。\n\n![V8内存构成](../../assets/images/memory-structure-of-V8.png)\n\n&gt; 这些空间中的每一个都由一组Pages组成。Page是使用[mmap](https://baike.baidu.com/item/mmap/1322217?fr=ge_ala)从操作系统分配的连续内存块。除大对象空间外，每个页面的大小均为1MB。 **垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收。** 每个区里面的内存页开头都有一个header，里面包括：\n&gt; \n&gt; - 各种**元数据和flag**（比如本页数据哪个区），GC需要使用的各种统计数据，GC各个阶段在本页的进展状况等。\n&gt; - 一个**slots buffer**，记录了所有指向本页内对象的指针，以节省回收时的一些扫描操作。\n&gt; - 一个**skip list**，将本页划分位多个区（region）并维护各个区的边界，用于快速搜索页上的对象。\n&gt; \n&gt; 紧跟着header的是一个**bitmap**，上面的每个bit对应页上的一个字，用于后面会介绍的marking。前面的部分按32个字对齐后，剩余的空间才是用于存储对象的。\n\n**注意：** 我们这里说的垃圾回收器只作用于**堆内存**。因为**栈内存**由操作系统直接管理，不在我们本文的讨论范围内。\n\n## 新生代的GC策略\n\n垃圾回收算法：**Scavenge(具体实现上采用Cheney算法)**\n\n新生代会将内存分成相等大小的两块**Semi-Space**，分别叫做**From Space**和**To Space**。**From Space**是真正的使用内存，**To Space**是空闲的，在GC的时候才会用到。也就是说，实际利用起来的新生代内存只有整体新生代内存的一半。\n\n新生代使用的是Scavenge算法，具体实现使用了*Cheney算法*，流程如下：\n\n1. 广度优先遍历**From Space**中的对象，把存活的对象复制到**To Space**。\n2. 遍历完成后，清空**From Space**。\n3. **From Space**和**To Space**角色互换（称为翻转）。\n\n另外，复制后的对象在**To Space**中占用的内存空间是连续的，不会出现碎片的问题。因为新生代的GC相对比较频繁，所以更侧重速度上尽可能快。\n\n**注意：** **From Space**又会被划分为`Nursery`和`Intermediate`两块区域。对象第一次分配内存时在`Nursery`区域，经历过一次GC后转移到`Intermediate`区域。\n\n## 对象晋升策略\n\n新生代的对象不会一直存在于该区域。当满足一定条件的情况下，新生代的对象会得到**晋升（Promote）**，即从新生代转移到老生代。晋升的情况一般有两种：\n\n- 经历一次GC后仍然存活的对象，即`Intermediate`中的。\n- 对象复制到**To Space**时，**To Space**的空间已经使用了25%以上。\n\n## 老生代的GC策略\n\n垃圾回收算法：**Mark-Sweep(标记清除算法)** + **Mark-Compact(标记整理算法)**\n\n老生代内存也分为两部分：\n\n- **指针区（Old Pointer Space）**：如果对象可能有指向其他对象的指针，保存在这里。大多数晋升的对象都在这里。\n- **数据区（Old Data Space）**：只保存原始对象哎那个，没有指向其他对象的指针。\n\n老生代做垃圾回收时包含了两种算法：**标记清除(Mark Sweep)**和**标记整理（Mark Compact）**。只有三个步骤：\n\n1. Marking 标记\n2. Sweeping 清除\n3. Compacting 整理\n\n### Marking 标记\n\n标记就是找到所有可访问对象的过程。两种算法的标记流程是一样的。使用了**三色标记法**：\n\n- **00**：白色。表示未被引用。\n- **10**：灰色。表示被引用，但是其引用的对象还没有遍历完。\n- **11**：黑色。表示被引用，并且其引用的对象已经遍历完成。\n\n首先将所有对象标记为**白色**，然后从根集*Root Set*（执行栈和全局对象）开始，以**深度优先遍历**的方式为访问到的对象添加**灰/黑色**。\n\n### Sweeping 清除\n\n清除被标记为白色的对象。这个结果会造成内存空间不连续的情况。清除的本质是**将内存的地址标记位空闲**，代码层面上是把内存地址保存到一个叫`Free List`的数据结构中。\n\n### Compacting 整理\n\n修改仍然存活的对象的内存地址，将不同内存页上的对象整合到一起，使得内存空间紧凑有序。这个过程比较消耗性能。\n\n## 回收算法比较\n\n| 回收算法     | Scavenge           | Mark-Sweep   | Mark-Compact |\n|--------------|--------------------|--------------|--------------|\n| 速度         | 快                 | 中           | 慢           |\n| 空间         | 双倍空间（无碎片） | 少（有碎片） | 少（无碎片） |\n| 是否移动对象 | 是                 | 否           | 是           |\n\n基于**弱分代假说**理论，实现不同分代采用不同策略的垃圾回收算法，以达到空间与时间的最优平衡解。\n\n## 垃圾回收机制的进阶问题\n\n对于进阶问题，这里只做简单了解。如果你有兴趣，可以自行查阅资料了解更多信息。毕竟真正的知识不是一篇文章能够讲明白的。比起做一个知识的定义者，我更希望能够成为知识的启蒙者，让大家能带着更多的疑问去思考，去整理自己的知识库。\n\n### 为什么V8引擎需要限制内存大小\n\n1. 浏览器环境很少会遇到使用大量内存的场景，因此没有必要将最大内存设置得过高。\n2. JavaScript是单线程机制，垃圾回收同样会阻塞JS主线程逻辑的执行。\n3. 垃圾回收本身也是一件非常耗时的操作，所以使用内存过大会导致主线程出现卡顿现象（这种现象叫做全停顿`Stop The World`），造成浏览器长时间无法得到响应。\n\n按照官方的说法，以1.5GB的垃圾回收的堆内存为例，V8做一次**小的垃圾回收**需要**50ms**以上，而做一次**非增量式回收**甚至需要**1s以上**，可见其耗时之久，而在这1s的时间内，**应用的性能和响应时间会大大下降**，这样的情况无论是前端还是后端，都是无法接受的。因此在当时的情况下，直接限制堆内存是一个好的选择。\n\n### 什么是增量标记、延迟清除和增量整理\n\n为了进一步提升V8的性能，垃圾回收器已经开始往增量式、并发式、并行式改进了。目前主要的优化发生在老生代的GC上，因为新生代的GC一般很短暂，可优化的空间和意义不大。从官方的说法上我们可以得知，一次完整的垃圾回收非常耗时，采用增量的方式可以将时间拆分以达到更理想的效果（运行时间不超过5ms）。\n\n在标记阶段，V8引入了增量标记的概念；在清除阶段，V8引入了并发、并行和延迟清除的概念；在整理阶段，V8同样引入了增量整理的概念。\n\n*当然采用增量的方式最大的问题是如何保证对象的误标记。* 为了解决这个问题，V8在写屏障的基础上，额外添加了一个需要记录的情形：**每次产生从黑色对象指向白色对象的引用的时候，将被指的对象重新标记为灰色，放回标记的队列中，这样便不会误将存活的对象标记为死亡了。**\n\n### 什么是写屏障\n\n根据前面所学的知识，我们来想一个问题。**如果新生代有一个对象，它只有一个引用，而它的引用在老生代，这时候如果保证新生代进行垃圾回收时，这个对象不会被清除掉呢？**\n\n对于这个问题，V8选择的解决方案是使用**写屏障（write barrier）**，即每次往一个对象写入一个指针（*添加引用*）的时候，都执行一段代码，这段代码会检查这个被写入的指针是否是由老生代对象指向新生代对象的，这样我们就能明确地记录下所有从老生代指向新生代的指针了。这个用于记录的数据结构叫做**StoreBuffer**，每个堆维护一个，为了防止它无限增长下去，会定期地进行清理、去重和更新。这样，我们可以通过扫描，得知`根对象-&gt;新生代`和`新生代-&gt;新生代`的引用，通过检查**StoreBuffer**，得知`老生代-&gt;新生代`的引用，就没有漏网之鱼，可以安心地对新生代进行回收了。\n\n### 什么是隐藏类\n\n在阅读下面的内容之前，请明确两个重点：\n\n1. V8会为每个对象关联一个隐藏类。\n2. 隐藏类的目的是优化属性的访问速度。\n\n隐藏类的出现是为了优化JavaScript属性值的查找问题，提升这块的性能。由于JavaScript是动态语言，变量随时可以变换类型。也就是说它不能像Java那样，在运行时就确定属性的值（或者指针）在内存的偏移量，这就导致了JavaScript的属性查找相较于静态语言会慢很多。\n\nV8使用了**隐藏类**的方式来模拟类似静态语言的查找方式，做到尽可能地提升查找速度。从结构上来说，隐藏类和Java中的固定对象结构非常相似。\n\n### 什么是内联缓存\n\n除了隐藏类，V8还利用了**内联缓存**的方式，进一步提升了JavaScript的性能。V8会维护一个记录最近有一段时间内调用方法时传入的参数类型。一旦V8引擎对参数的类型进行了正确的预测，将使得引擎越过解析如何访问类属性的过程，直接使用之前缓存的信息直接获得隐藏类并对对象属性的进行访问。\n\n### 什么是HotSpot热点代码收集\n\n对于反复多次被使用的代码，V8会将这块代码的字节码编译成更为高效的机器码，然后当再次被执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就可以大大提升代码的执行效率。\n\n## 总结\n\n以上就是垃圾回收机制的内容了，那么最后我来做下总结：\n\n1. 垃圾回收分为`新生代`和`老生代`。\n2. 新生代采用的是`Scavenge算法`。\n3. 老生代采用的是`标记清除`+`标记整理`算法。\n\n## 提问\n\n1. 新生代变量是如何进行提升的？\n2. 新生代对象仅被老生代引用时，新生代检查时如何识别对象被引用？\n3. 由于JavaScript的灵活性，导致只有在运行时才能确定数据占用空间的大小，这样会使内存读时需要耗费更多的时间。那么V8内存管理机制是如何解决这个问题的？&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/V8引擎的垃圾回收机制.mdx&quot;],&quot;digest&quot;:[0,&quot;8b0101728e8107e9&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;v8引擎的垃圾回收机制&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Homebrew常用命令.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;Homebrew常用命令&quot;],&quot;description&quot;:[0,&quot;Homebrew是Mac上强大的包管理器，它用于更加方便和直观的帮助我们管理Mac上的软件包以及相关的服务。&quot;],&quot;pubDate&quot;:[3,&quot;2022-04-27T18:54:23.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;今天，我们主要讲的是Homebrew中对我们日常工作特别有帮助的指令。如果您还想了解更多的Homebrew知识，欢迎您访问[Homebrew文档官网](https://docs.brew.sh/)查看更多命令。\n\n## 安装软件包\n\n```bash\nbrew install $FORMULA\n```\n\n安装指定的包\n\n## 更新Homebrew\n\n要获取最新的包列表，首先得更新 Homebrew 自己。这可以用`brew update`。\n\n```bash\nbrew update\n\n# Updated 2 taps (homebrew/core and homebrew/cask).\n# ==&gt; Updated Formulae\n# adios2               cpufetch             etcd                 libopenmpt           mitmproxy            pwntools             vnstat\n# athenacli            croaring             etcd-cpp-apiv3       libpipeline          mpi4py               pygments             wcslib\n# aws-sdk-cpp          cruft                flowgrind            liquidprompt         ns-3                 rtorrent             xmlrpc-c\n# cgif                 deno                 gnu-getopt           luarocks             oh-my-posh           staticcheck          xpdf\n# charm-tools          duplicity            harfbuzz             macvim               parallel             termius              zeek\n# ciphey               eccodes              hlint                magic-wormhole       phoronix-test-suite  theharvester\n# ==&gt; Updated Casks\n# android-studio       calibre              gitfox               rambox               rectangle-pro        resolume-arena       tableau\n```\n\n## 更新软件包(formula)\n\n要获取需要更新的软件包列表，可以使用`brew outdated`。\n\n```bash\nbrew outdated\n```\n\n更新需要更新的软件包\n\n```bash\n# 更新所有的包\nbrew upgrade\n# 更新指定的包\nbrew upgrade $FORMULA\n```\n\n## 清理旧版本软件包\n\n一般情况下，新版本安装了，旧版本就不需要了。我们可以使用`brew cleanup`清除旧的软件包以及缓存文件。\n\n**PS：Homebrew只会清除比当前版本旧的软件包，所以不用担心没更新的包也被删了。**\n\n## 锁定不想更新的软件包\n\nHomebrew一次性更新包是一件非常方便的事。但是有时候我们会有一些包不想更新。比如我们在使用mongodb，数据库的跨版本更新需要同时更新数据，这样不利于我们方便的使用。\n\n这时候，我们可以使用`brew pin`来锁定这个包。当Homebrew更新操作时，会忽略掉被锁定的包。\n\n```bash\n# 锁定指定包\nbrew pin $FORMULA\n\n# 取消锁定指定包\nbrew unpin $FORMULA\n```\n\n## 查看软件包\n\n如果我们想知道自己已经安装了哪些软件包，可以使用`brew list`。\n\n```bash\nbrew list\n```\n\nHomebrew可以通过命令查看包的相关信息，这些信息会在包安装完成后自动显示。如果后期还想查看，可以通过`brew info`和`brew deps --installed --tree`进行指定的查看。\n\n```bash\n# 显示指定包的信息\nbrew info $FORMULA\n\n# 显示安装包的数量，文件数量，和总占用空间\nbrew info\n```\n\n我们可以通过`brew deps`查看包的依赖关系，当想删除指定包时，这非常有用。\n\n比如，我想删除`node@14`这个包，我使用`brew deps`查看依赖关系，知晓我是否能安全删除`node@14`这个包，最后发现我的`mongosh`依赖它。\n\n```bash\n# 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。\nbrew deps\n\n# 查看已安装的包的依赖，树形显示\nbrew deps --installed --tree\n\n# mongodb/brew/mongodb-community\n# ├── mongodb-database-tools\n# └── mongosh\n#     └── node@14\n#         ├── brotli\n#         ├── c-ares\n#         ├── icu4c\n#         ├── libnghttp2\n#         ├── libuv\n#         ├── openssl@1.1\n#         │   └── ca-certificates\n#         └── macos-term-size\n# node\n# ├── brotli\n# ├── c-ares\n# ├── icu4c\n# ├── libnghttp2\n# ├── libuv\n# └── openssl@1.1\n#     └── ca-certificates\n\n# node@14\n# ├── brotli\n# ├── c-ares\n# ├── icu4c\n# ├── libnghttp2\n# ├── libuv\n# ├── openssl@1.1\n# │   └── ca-certificates\n# └── macos-term-size\n```\n\n可以使用`brew search`来搜索软件包，支持使用正则表达式进行复杂的搜索。例如，我们查询下静态博客生成工具hugo。\n\n```bash\nbrew search hugo\n\n# ==&gt; Searching local taps...\n# hugo ✔\n# ==&gt; Searching taps on GitHub...\n# ==&gt; Searching blacklisted, migrated and deleted formulae...\n```\n\n## 服务管理\n\n`brew services`用于方便的管理brew安装的服务软件，类似于Linux下的service命令。\n\n```bash\n\n# List all running services for the current user (or root).\n# 获取当前用户（或者管理员）的所有服务列表\nbrew services list\n# Name              Status User File\n# mongodb-community none        \n# php               none \n\n# Run the service formula without registering to launch at login (or boot).\n# 运行指定的服务软件并且不注册到登录时启动。\nbrew services run $FORMULA\n# 运行所有服务软件并且不注册到登录时启动。\nbrew services run --all\n\n# Start the service formula immediately and register it to launch at login (or boot).\n# 运行指定的服务软件并且注册到登录时启动。\nbrew services start $FORMULA\n# 运行指定的服务软件并且注册到登录时启动。\nbrew services start --all\n\n# Stop the service formula immediately and unregister it from launching at login (or boot).\n# 停止运行指定的服务并且注销登录时启动。\nbrew services stop $FORMULA\n# 停止运行指定的服务并且注销登录时启动。\nbrew services stop --all\n\n# Stop (if necessary) and start the service formula immediately and register it to launch at login (or boot).\n# 立即停止并启动指定服务，并且注册到登录时启动。\nbrew services restart $FORMULA\n# 立即停止并启动所有服务，并注册到登录时启动。\nbrew services restart --all\n\n# Remove all unused services.\n# 移除所有无用的服务。\nbrew services cleanup\n\n\n# If sudo is passed, operate on /Library/LaunchDaemons (started at boot).\n# Otherwise, operate on ~/Library/LaunchAgents (started at login).\n```\n\n## 查看Homebrew的配置信息\n\n用于查看Homebrew所在环境及相关的配置情况。\n\n```bash\nbrew config\n```\n\n## 诊断问题\n\n诊断当前Homebrew存在哪些问题，并**给出解决方案**。\n\n```bash\nbrew doctor\n```\n\n## 仓库管理\n\n```bash\n# 已安装的仓库列表\nbrew tap\n\n# 添加仓库\nbrew tap [--full] user/repo [URL]\n\n# 移除仓库\nbrew untap tap\n```\n\n## Homebrew可视化管理\n\n如果你不想去记忆这么多复杂的命令，也可以使用[Cakebrew](https://www.cakebrew.com/)可视化管理。\n\n安装命令如下：\n\n```bash\nbrew cask install cakebrew\n```\n\n然后我们就可以愉快地使用Homebrew了。\n\n## Homebrew services 可视化管理\n\n[LaunchRocket](https://github.com/jimbojsb/launchrocket)是非常友好的图形界面，使用起来简单快捷。比如你使用Homebrew安装的 Mysql、Redis、MongoDB，是让它自启动呢，还是手动启动，传统方式需要使用命令行的命令，而使用`LaunchRocket`则可以在图形界面中进行管理了！\n\n以上是Homebrew常用功能。\n\n最后的最后，感谢您的阅读！！！&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/Homebrew常用命令.mdx&quot;],&quot;digest&quot;:[0,&quot;8a8bc0ebbb1dd5de&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;homebrew常用命令&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;JavaScript中的const、let和var的区别.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;JavaScript中的const、let和var的区别&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2020-06-01T14:03:00.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;JavaScript是一门弱类型语言。在ES3和ES5时期，我们都是通过 **var** 来声明一个变量的。那个时候的前端开发相对简单，JavaScript通常是被用来做些景上添花的小功能，所以完全能够应付我们的日常开发工作。随着移动互联网的兴起，H5应用适应快速迭代的属性使前端得到了快速发展，不断叠加的业务需求也凸显出了JavaScript在大型项目中的劣势（可维护性差）。因此，语言的升级势在必行，而变量声明的方式则是其中需要优化的内容之一。今天我们的主题就来说说变量声明 —— **const** 和 **let**。\n\n## 变量的创建\n\n首先，我要讲清楚变量声明存在三个步骤：\n1. **创建** 变量；\n2. **初始化** 变量；\n3. **更新** 变量。\n\n这三个步骤的 *微妙差异*，正是 **const**、**let**、 **var** 三者之间的不同之处。\n\n## const和let\n\n**`const`命令是声明一个常量。`const`只能进行变量的创建和变量初始化，而不能进行变量更新。** \n\n```javascript\nconst a = 1\na = 2 // Uncaught TypeError: Assignment to constant variable.\n```\n\n可以看到，当我们对 **const** 声明的变量进行更新时，浏览器报了相应的错误。\n\n**`let`命令是指声明一个变量。`let`可以进行变量的创建、变量的初始化和变量的更新。**\n\n```javascript\nlet a = 1\na = 2\nconsole.log(a) // 2\n```\n\n可以看到，当我们对 **let** 声明的变量进行更新时，变量对应的值会进行相应的改变。\n\n## const、let与var的区别\n\nJavaScript是一门弱类型语言。它不会在声明时要求变量确定类型，甚至你可以随时修改变量的类型。那既然是弱类型语言，**var** 似乎足以满足所有的需求了，为什么还需要 **const** 和 **let** 呢？\n\n**原因是`var`太灵活了。** 很多时候，我们无法对 **var** 进行约束，这会导致我们的程序中出现意想不到的问题。\n\n1. **`var`存在变量提升的问题。**\n2. **`var`不支持块级作用域。**\n3. **`var`可以在静默状态下重复声明。**\n\n而 **const** 和 **let** 就是用来约束我们变量的使用，尽可能地减少意想不到的问题。上面我们已经讲到了 **var** 的问题，那么我就从这三个问题出发来讲讲 **const**、**let** 在解决这些问题上做了哪些努力？\n\n## 作用域\n\n首先，我们先来聊下 **作用域**。**作用域在高级语言中是一个非常重要的概念**。它相当于一个容器，变量和函数都放在这个容器里面。理论上来说，容器外面不能访问容器里面声明的变量和函数，但容器内可以调用父祖级容器的变量和函数。*即外部不能访问内部，内部可以访问外部*。举个栗子：\n\n``` javascript\nvar a = 1\n\nfunction foo() {\n  var b = 2\n  console.log(a) // 1\n}\n\nfoo()\nconsole.log(b) // Uncaught ReferenceError: b is not defined\n```\n\n这里`function foo`创建了一个**foo（scope）**，全局有一个**global（scope）**。**global**中存在`a`（变量）和`foo`（函数），**foo**中存在`b`（变量）。\n\n1. 在 **global** 中，我们能访问到`a`，但访问不到`b`，这就是 **作用域**。\n2. 在 **foo** 中，我们不仅能访问到`b`，也能访问到`a`，我们称之为 **作用域链**。\n\nES3和ES5中，**作用域的创建方式**只有**function**、**with**和**catch**。\n\n- **function** 是常用的创建作用域的方式；\n- **with** 已经被抛弃，因为它会导致作用域链发生变化（因此，浏览器所有的优化都会失效）；\n- **catch** 经常用于捕获错误。\n\nES6有了 **块级作用域** 的概念。**const** 和 **let** 命令就是作用于块级作用域。\n\n```javascript\n{\n  var a = 1\n  let b = 2\n  const c = 3\n}\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\nconsole.log(c) // Uncaught ReferenceError: c is not defined\n```\n\n从上面的例子中可以看到，**var** 命令不受块级作用域的影响，可以正常访问；**const** 和 **let** 受到块级作用域的影响，在块级作用域以外无法正常访问。\n\n依据这个特性，我想理解 **for** 循环的这个问题应该会变得容易很多：\n\n```javascript\nfor (var i = 0; i &lt; 6; i++) {\n  setTimeout(function() {\n    console.log(i) // 6, 6, 6, 6, 6, 6\n  }, 20)\n}\n\nfor (let i = 0; i &lt; 6; i++) {\n  setTimeout(function() {\n    console.log(i) // 0, 1, 2, 3, 4, 5\n  }, 20)\n}\n```\n\n这道题非常的经典，从 **作用域** 和 **作用域链** 的角度能很好的解释问题产生的原因。\n\n## 变量提升\n\n谈到JavaScript，我们知道 **var** 和 **function** 会存在变量提升的情况，也就是即使调用在声明之前，变量和方法依然能够访问而不会报错。\n\n```javascript\nconsole.log(a) // undefined\nfoo() // foo\n\nvar a = 1\n\nfunction foo() {\n  console.log(&#39;foo&#39;)\n}\n```\n\n上面的例子我们发现，即使 **var** 定义的变量写在声明之前依然能够访问，只是返回的值为 **undefined**；**function** 也是能正常访问，还能得到预期的结果，**这就是变量提升**。\n\n在JavaScript中，变量首先会被 **创建**，然后 **初始化**，最后 **更新**。我们从上面的代码来看这三个操作：\n\n1. JavaScript引擎会找到`var a`，然后告诉作用域 **创建一个名称为a的变量**；\n2. **立即初始化** 变量`a`，此时初始化的值为 **undefined**；\n3. 代码执行到编写的位置时会将变量`a` **更新为1**。\n\n也就是说，我们`console.log(a)`的结果为`undefined`的原因是 **`a`的创建和初始化的过程被提升了**。\n\n```javascript\nconsole.log(a) // 1\nconsole.log(b) // Uncaught ReferenceError: b is not defined\nconsole.log(c) // Uncaught ReferenceError: c is not defined\n\nvar a = 1\nlet b = 2\nconst c = 3\n```\n\n这里我们试验一下 **const** 和 **let** 命令，发现他们都报错了。那么是不是说 **const** 和 **let** 不存在变量提升呢？\n\n其实严格意义上来讲， **`const`和`let`依然存在变量提升的情况** 。只是与 **var** 不同的是，**const** 和 **let** 只是创建被提升了。我们来看看ES6标准的原话。\n\n&lt;blockquote&gt;The variables are created when their containing Lexical Environment is instantiated but may not be accessed inany way until the variable’s LexicalBinding is evaluated.&lt;/blockquote&gt;\n\n*简单来说就是当环境作用域被创建时，变量就都已经被创建了*。只是这个时候我们还未进行声明，在这个时间点访问会导致直接报错。而从创建变量到声明变量这个时间段，我们就称它为**临时性死区（Temporal Dead Zone）**\n\n## 重复声明\n\n```javascript\nvar a = 1\nvar a = 2\nlet a = 3 // Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared\nlet b = 1\nlet b = 2\nvar b = 3 // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared\nconst a = 1 // Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared\nconst b = 3 // Uncaught SyntaxError: Identifier &#39;b&#39; has already been declared\nconst c = 1\nconst c = 2 // Uncaught SyntaxError: Identifier &#39;c&#39; has already been declared\nvar c = 3 // Uncaught SyntaxError: Identifier &#39;c&#39; has already been declared\nlet c = 4 // Uncaught SyntaxError: Identifier &#39;c&#39; has already been declared\n```\n\n上面的例子，我们进行了很多重复声明。结果发现，\n\n1. **var** 命令和 **let** 命令可以进行重复声明，**const** 命令不能进行重复声明。\n2. **var** 命令和 **let** 命令重复声明时，命令必须与之前的相同，否则会报错。\n\n## 总结\n\n1. **var** 没有块级作用域概念，**const** 和 **let** 有块级作用域概念。\n2. **var** 会提升创建和初始化，**const** 和 **let** 只会提升创建。\n3. **const** 不可以重复声明，**let** 和 **var** 可以重复声明。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/JavaScript中的const、let和var的区别.mdx&quot;],&quot;digest&quot;:[0,&quot;f9dbca12e123d802&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;javascript中的constlet和var的区别&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;HTTP的强缓存与协商缓存.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;HTTP的强缓存与协商缓存&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2020-04-10T02:47:15.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;对于前端而言，我们经常需要与后端进行数据交互，常用的数据交互方式就是**HTTP请求**。在HTTP请求的过程中，有一些静态资源很少发生变化，但每次都要重新请求并从服务端下载，这不仅影响资源的响应时长，还会增加了服务器的压力。为了解决这个问题就有了HTTP缓存机制。它是浏览器与服务器之间的一种优化策略，*为了加快用户的访问速度，增强用户体验，减轻服务器压力。*\n\n![HTTP缓存](../../assets/images/1355655874_6620.jpg)\n\n## HTTP缓存有什么优点\n\n1. 减少冗余的数据传输，节省网络资源。\n2. 减少服务器的负担，提升网站的性能。\n3. 加快客户端加载网页的速度，增强用户体验。\n\n**我们知道，HTTP的缓存分为强缓存和协商缓存。**\n\n- 那他们之间有什么区别呢？\n- 如何判断是否使用了缓存以及使用了哪种缓存？\n- 如何开启强缓存和协商缓存？\n\n带着这些问题，我们一起来探索HTTP缓存机制。\n\n## 强缓存与协商缓存的区别\n\n1. 强缓存不需要请求服务器，协商缓存需要请求服务器。\n2. 强缓存返回的HTTP状态码是200，协商缓存返回的HTTP状态码是304。\n\n他们之间的共同点是**强缓存与协商缓存都是从客户端获取缓存数据的**。\n\n## 如何判断浏览器是否使用了缓存，使用了哪种缓存\n\n我们可以打开Chrome浏览器的控制台工具，点击Network，可以查看我们的http请求情况。下面两个是我的真实请求情况。\n\n![强缓存](../../assets/images/WX20200416-142801.png)\n\n上图中有两条请求信息是从缓存中获得的。我们可以看右数第三列，这里告诉我们这个请求的数据是从磁盘缓存中获取的。\n\n![协商缓存](../../assets/images/WX20200416-142909.png)\n\n上图中有两条信息是通过协商缓存获得的。我们可以看左数第二列，他们的状态码都是304。\n\n## 如何开启强缓存和协商缓存\n\n### 开启HTTP强缓存\n\n对于强制缓存，可以通过在Nginx上配置**Expires**或者**Cache-Control**来开启。\n\n*Expires的值是一个固定的过期时间。在这个时间内，所有的信息都会从HTTP缓存中获取。这样的方式并不灵活。*\n\n1. 如果时间未过期，即使服务器更新了最新的数据，浏览器也可能在较长一段时间内不去更新数据。\n2. 如果时间过期了，即使服务器依然是老的数据，浏览器还是会重新去服务器请求。\n\n*Cache-Control的值是一个相对时间。也就是在一定时间内，浏览器依然会读取缓存，过了这个时间间隔，浏览器会再次请求数据，并重新计算相对时间。这种方案相对于第一种更加灵活，能更好地利用缓存，也能更及时地更新数据。*\n\n#### 客户端可以在HTTP中设置的Cache-Control指令。\n\n- Cache-Control: max-age=\\&lt;seconds\\&gt;\n- Cache-Control: max-stale\\[=\\&lt;seconds\\&gt;\\]\n- Cache-Control: min-fresh=\\&lt;seconds\\&gt;\n- Cache-Control: no-cache\n- Cache-Control: no-store\n- Cache-Control: no-transform\n- Cache-Control: only-if-cached\n\n#### 服务器可以在HTTP中设置的Cache-Control指令。\n\n- Cache-Control: must-revalidate\n- Cache-Control: no-cache\n- Cache-Control: no-store\n- Cache-Control: no-transform\n- Cache-Control: public\n- Cache-Control: private\n- Cache-Control: proxy-revalidate\n- Cache-Control: max-age=\\&lt;seconds\\&gt;\n- Cache-Control: s-maxage=\\&lt;seconds\\&gt;\n\n#### 扩展指令。不是核心HTTP请求标准的一部分，请谨慎使用，注意兼容性。\n\n- Cache-Control: immutable\n- Cache-Control: stale-while-revalidate=\\&lt;seconds\\&gt;\n- Cache-Control: stale-if-error=\\&lt;seconds\\&gt;\n\nCache-Control各种属性有很多，具体的含义可以参看[MDN上的Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control)。这里我们主要来讲讲**no-cache**、**no-store**以及**max-age**这三个属性。\n\n**no-cache** 在使用缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证（协商缓存验证）。也就是说，请求一定会发送，但请求的结果可能是直接返回数据，也可能告诉浏览器读取当前缓存。\n\n**no-store** 不在客户端存储任何请求的内容（包括请求内容和服务器响应的内容），即不使用任何缓存策略。\n\n**max-age** 设置缓存的最大存储周期。超过了这个时间（*单位：秒*），将不使用本地缓存。与Expires不同的是，这个时间是一个相对时间，是指请求返回后的*max-age*秒。\n\n**这两种方案都是不错的强缓存策略，但是对于频繁发布的系统，显然这两种方案都无法满足要求。**\n\n### 开启HTTP协商缓存\n\n协商缓存依然需要向服务器发送信息，但是服务器会根据相应的情况返回数据或者告诉浏览器可以从本地缓存中获得。当我们使用`Cache-Control: no-cache`时，服务器是怎么知道当前的缓存是否过期了呢？\n\n这里我们就讲讲服务器检查HTTP缓存是否过期的两个属性**Last-Modify/If-Modify-Since**和**Etag/If-None-Match**。\n\n对于**Last-Modify/If-Modify-Since**，浏览器第一次请求时会返回一个Last-Modify，这个属性表示服务器资源上次修改的时间。再次请求时，客户端会在request头中加上If-Modify-Since，用于服务器验证表示资源是否已过期。 **If-Modify-Since的值就是上次Last-Modify的值。** 如果时间匹配不一致，就返回新数据，并覆盖当前的缓存；否则服务器返回304请求（不返回任何数据），浏览器会从本地缓存中读取数据信息。\n\n*既然已经有了Last-Modify/If-Modify-Since，为什么还需要ETag呢？这里我们先讲讲ETag的值，然后在解释为什么，以及他们的优劣。*\n\n**ETag/If-None-Match**的值是hash值，表示当前文件对应的hash。随着文件的变化，hash也会相应改变。整体的验证流程与Last-Modify/If-Modify-Since相同，**ETag的生成由服务器决定**。\n\n*好了，讲完他们的定义，我们来看看它们两个有什么不同，怎么选择他们的设置呢？*\n\n1. **在多机运行的情况下，每台服务器的时间不一定一致，会导致Last-Modify失效；而ETag每次都会计算最新的文件hash值，确保了精度，在多机部署的情况下能保证hash值的一致性。**\n2. **在性能上，Last-Modify只需要获取文件改变的时间即可，而ETag需要算法计算最新的hash值。相对来说，Last-Modify的性能优于ETag。**\n3. **服务器校验时，优先考虑ETag的校验。**\n\n从上面的情况看，如果你只是单机运行，推荐使用Last-Modify/If-Modify-Since，这样相对来说能提升性能；如果你是多机运行，推荐使用ETag/If-None-Match，这样能解决服务器时间不一致导致的失效问题。\n\n### HTTP缓存的过程\n\n1. 第一次请求加载时，浏览器会下载远程资源，服务器返回HTTP STATUS为200。浏览器将response headers和请求数据一并缓存下来。\n2. 第二次请求加载时，浏览器会先计算当前时间和上一次200请求的时间差，与Cache-Control的有效时间进行比较，如果没有过期，则命中强缓存，不做HTTP请求；（如果浏览器不支持HTTP 1.1，则会比较Expires上的时间）\n3. 如果没有命中强缓存，浏览器会带上上次请求的信息（将Last-Modify的值设置到If-Modify-Since上；将ETag的值，设置到If-None-Match上）发送给服务器，服务器根据这两个属性判断是否命中协商缓存。\n4. 服务器收到请求后，优先判断ETag是否一致。如果一致，则返回HTTP STATUS为304，不返回数据，浏览器根据这个状态码，使用本地缓存数据；否则服务器返回HTTP STATUS为200，最新的ETag和新数据。\n5. 服务器如果没有收到ETag的值，服务器将比较Last-Modify是否一致。如果一致，则返回HTTP STATUS为304，不返回数据，浏览器根据这个状态码，使用本地缓存数据；否则服务器返回HTTP STATUS为200，返回最新的数据覆盖当前缓存。\n\n## 结论\n\n合理地使用缓存策略，能大大提升我们服务器的性能。Cache-Control属性的选择，ETag/If-None-Match与Last-Modify/If-Modify-Since的选择，需要根据实际情况来定。一些接口请求涉及到数据更新频率较高，不建议使用缓存策略。\n\n## 参考\n\n- [强制缓存和协商缓存的区别](https://blog.csdn.net/wsymcxy/article/details/82154397)\n- [浏览器缓存详解:expires,cache-control,last-modified,etag详细说明](https://blog.csdn.net/eroswang/article/details/8302191)&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/HTTP的强缓存与协商缓存.mdx&quot;],&quot;digest&quot;:[0,&quot;0fd2b3feaf21e504&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;http的强缓存与协商缓存&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;你需要知道的Git提交规范.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;你需要知道的Git提交规范&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-12-02T18:38:05.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;我们应该对Git不太陌生，它是目前最火的分布式版本管理工具。那你知道怎样编写提交信息才能帮助我们更好地管理Git记录吗？今天，我们就来讲讲如何编写提交信息。\n\n## 为什么我们需要规范\n\n**古语有云：“没有规矩，不成方圆”。** 这句话不仅适用于工作生活中的方方面面，同样适用于我们的编程开发。一套标准的规范不仅能帮助我们形成良好的开发习惯，还能减少开发中犯错的几率，甚至可以基于这套规范创造更多的价值（比如：生成`CHANGELOG.md`）。就说Git提交规范，一套良好的提交规范可以使我们在查看提交信息时不那么茫然；尤其在回滚操作时，我们能更清楚了解到我们回滚可能造成的影响。\n\n## Git 提交规范\n\n``` text\n&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n&lt;-- BLANK LINE --&gt;\n&lt;body&gt;\n&lt;-- BLANK LINK --&gt;\n&lt;footer&gt;\n```\n\n`&lt;type&gt;(&lt;scope&gt;):`与`&lt;subject&gt;`之间需要加一个空格。\n\n### 规范类型\n\n#### type\n\n用于说明提交的类型，所有的提交类型如下：\n\n- **feat**: 新增feature\n- **fix**: 修复bug\n- **docs**: 仅仅修改了文档，比如`README.md`、`CHANGELOG.md`等\n- **style**: 仅仅修改了代码风格，不影响代码逻辑与功能\n- **refactor**: 代码重构（即不是新增功能，也不是修改bug的代码变动）\n- **perf**: 优化相关，比如提升了项目的性能、体验\n- **test**: 测试用例（单元测试、e2e测试、集成测试）\n- **chore**: 改变构建流程、增加或者删除依赖库、工具等\n- **revert**: 回滚到上一个版本\n\n#### scope\n\n用于说明提交影响的范围，可以是具体的某个模块。\n\n#### subject\n\n- 对提交的简单描述，不超过50个字符\n- 结尾不加标点符号\n\n#### body\n\n- 对提交的详细描述，建议在72个字以内\n- 表明这个变更的目的、细节以及是否存在副作用或者风险\n\n#### footer\n\n添加链接到具体的issue地址或者文档地址，或者关闭某个issue。\n\n### 提交格式要求\n\n``` text\n# 标题行：50个字符以内，描述主要变更内容\n#\n# 主体内容：更详细的说明文本，建议72个字符以内。 需要描述的信息包括:\n#\n# * 为什么这个变更是必须的? 它可能是用来修复一个bug，增加一个feature，提升性能、可靠性、稳定性等等\n# * 他如何解决这个问题? 具体描述解决问题的步骤\n# * 是否存在副作用、风险?\n#\n# 尾部：如果需要的话可以添加一个链接到issue地址或者其它文档，或者关闭某个issue。\n```\n\n## 如何统一团队的提交规范\n\n规范很好，但是团队成员是否执行，执行的效果如何仍然是个问题。而为了检查团队成员的执行情况，花大量的时间、人力去监督明显是不合算的。所以，我们需要一套完整的工具去帮助我们团队成员执行这套规范。下面我先列举下我们需要的工具：\n\n- @commitlint/cli\n- @commitlint/config-conventional\n- husky\n- commitizen\n- conventional-changelog\n\n大致上，我们就需要这五个工具配合使用，来达到效果。首先介绍前三个工具 **@commitlint/cli**、**@commitlint/config-conventional**、**husky**。\n\n**@commitlint/cli**、**@commitlint/config-conventional**是用来检查`git commit`的提交是否符合规范的。**husky**是一个向Git仓库中注册钩子函数的工具。可以帮我们在提交信息时自动检查规范。使用很简单，只需要在我们的`package.json`中添加下面的配置即可。\n\n``` json\n// package.json\n\n{\n  ...\n  \&quot;husky\&quot;: {\n    \&quot;hooks\&quot;: {\n      \&quot;commit-msg\&quot;: \&quot;commitlint -E HUSKY_GIT_PARAMS\&quot;\n    }\n  }\n  ...\n}\n```\n\n这样我们就能保证我们的开发人员能遵守Git提交规范了。怎么样？很简单吧！但是仅仅能检查规范还不够，由于开发人员还未适应这样的代码提交规范，使用过程中往往会花很多时间在上面，那么我们就应该帮助开发人员适应这套规范。好了，**commitizen**就此登场了。**commitizen**是一个帮助遵照提交规范生成Git提交信息的工具。使用也非常简单，只需要在全局安装`npm i commitizen -g`就可以了。提交代码时，我们将`git commit`换成`git cz`，它会一步一步指导我们生成规范的提交。\n\n就此其实也已经差不多了。不过我还想扩展下，也许我们在上线后，想要一份本次项目的更改信息，我们可以添加**conventional-changelog**，这个工具将帮助我们生成一份当前版本的`CHANGELOG`。我们可以在`scripts`中添加任务，帮助我们生成`CHANGELOG`。\n\n``` json\n// package.json\n\n{\n  ...\n  \&quot;scripts\&quot;: {\n    \&quot;version\&quot;: \&quot;conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md”\n  },\n  ...\n}\n```\n\n这样配置之后，我们就可以在执行`npm run version`时，自动生成`CHANGELOG`了。\n\n## 结论\n\nGit提交规范本身不会对项目开发有任何的影响。但是，如果你是项目维护者，当项目出现问题需要回滚时，看着这一堆堆提交混乱的信息，你不觉得很头疼吗？当你回滚时，你能很放心地说‘这次回滚不会有问题，因为我了解回滚掉的所有改动！’吗？打江山难，守江山更难。维护是一件非常头疼却十分重要的事。如何起好一个开头对项目后期的维护至关重要。讲到这里，Git提交规范也基本已经讲解完了。如果你觉得很棒，赶快推荐给你们的团队吧！\n\n## 参考\n\n- [你可能忽略的Git提交规范](https://learnku.com/articles/25456?order_by=vote_count&amp;)\n- [Git commit message和工作流规范](https://my.oschina.net/qcloudcommunity/blog/870743)&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/你需要知道的Git提交规范.mdx&quot;],&quot;digest&quot;:[0,&quot;2adfd27ee22355de&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;你需要知道的git提交规范&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;发布属于你的NPM包.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;发布属于你的NPM包&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-11-10T04:12:56.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;有没有尝试过向npm库中发布自己的包呢？今天我们就来讲讲npm的发布流程。\n\n## npm发布流程\n\n1. 开发完成你的代码，并提交到git仓库中。\n2. 执行`npm login`，登录你的npm账号。\n3. 执行`npm version &lt;version tag&gt;`，修改版本号。\n4. 执行`npm publish`，等待自动执行发布操作。\n\n这就是一套非常简单的npm包发布流程。这个流程非常简单，但是这样说可能并不能满足您的需要，下面我们就来详细讲解下一些细节部分。\n\n在这里，我就不讲解第一步了，我想使用过版本管理软件（git）的用户应该都会使用它。\n\n### npm login\n\n![npm login --help](../../assets/images/WX20191111-103947.png)\n\n从上图可知，`login`、`adduser`和`add-user`是同一个指令。`npm login`可以创建或者验证`&lt;username&gt;`在指定注册表命名的用户，然后将凭据保存到 **.npmrc** 文件中。使用指令`npm whoami`可以或者当前登录用户的`&lt;username&gt;`。\n\n当然，如果您之前已经登录过了可以忽略这一步，并不是每次发布都必须执行一次登录操作的。\n\n### npm version\n\n![npm version --help](../../assets/images/WX20191111-005253.png)\n\n通过执行`npm version --help`我们可以看到，我们可以使用`major`、`minor`、`patch`、`premarjor`、`preminor`、`prepatch`、`prerealease [--preid=&lt;prerelease-id&gt;]`、`from-git`和自定义的版本号来定义版本号。\n\n其中，`major`、`minor`、`patch`主要用于**正式版本**使用；`premarjor`、`preminor`、`prepatch`、`prerealease [--preid=&lt;prerelease-id&gt;]`主要用于**预发布版本**使用；`from-git`和自定义版本一般不会使用（说实话，`from-git`我从来没有使用过，也不清楚具体怎么使用，哈哈）。\n\n具体的版本规则我一再上一篇文章中详细讲解过了。如果还不清楚，请查看[语义化版本控制](.../../assets/images/1571711706800/README.md)。今天我们主要来讲讲`prerealease [--preid=&lt;prerelease-id&gt;]`的使用。\n\n一般来说，我们发布正式版本都是使用标准的语义化版本格式（X.Y.Z）。但是很多时候，由于我们需要做大的升级，测试可能无法完全覆盖到所有的问题（尤其是使用环境当中产生的问题）或者有些API可能会有改动，我们会先发布一个预发布版本，通过公测的手段收集用户在使用中遇到的问题，然后加以修改。预发布版本的好处是\n\n1. 我们不会影响已有应用的正常使用。\n2. 我们可以通过公测的手段保证新版本的稳定性，修复各种环境中产生的bug。\n3. 我们可以使用户提前熟悉新版本。\n\n我们可以执行指令`npm version prerelease`来发布新的预发版本。执行完后，我们可以看到版本号变成了`X.Y.Z-N`的形式，这就是最简单的预发布版本的格式。当然我们可以给它添加一个`preid`，执行指令`npm version prerelease --preid=alpha`，这时候我们看到版本号变成`X.Y.Z-alpha.N`的形式了。\n\n### npm publish\n\n![npm publish --help](../../assets/images/WX20191111-112230.png)\n\n下面讲讲我们本文的最重点`npm publish`。`npm publish`会自动执行发布操作，从图上可知，默认`publish`会被打上`latest`标签。如果您想发布预发布版本，可以自定义标签。比如，如果你想发布`next`版本的包，可以执行`npm publish --tag next`。当然如果您失误将预发布包的标签打成了`latest`也是可以挽救的，您可以执行`npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;]`来修改标签。\n\n## 其他事项\n\n好了，发布的操作就是这么简单。下面我们来讲讲发布过程中可能遇到的问题，或者我觉得可以优化的点。\n\n### 登录失败问题\n\n有些时候，您可能已经输入了正确的账号、密码以及邮箱，但是返回的结果仍然是登录失败。这种情况有可能是因为您的registry地址有问题。在国内，由于访问速度的原因，我们往往会将库源设置为**淘宝镜像**，这时候我们有三种方式解决这类问题。\n\n第一种，我们可以通过指令`npm login --registry=https://registry.npmjs.org`的方式指定我们登录的地址。\n\n第二种，我们可以通过指令`npm config set registry https://registry.npmjs.org`的方式全局切换到npm源地址然后在执行`npm login`。\n\n第三种，我们可以通过指令`npm config delete registry`的方式删除用户配置的`registry`，然后在执行`npm login`。\n\n### 团队开发\n\n也许您发布的是一个类似`express`这样的大型框架。由于这样的项目需要一个完整的团队共同开发，所以您可以通过指令`npm owner  &lt;user&gt; [&lt;@scope&gt;/]&lt;pkg&gt;`来为这个包添加团队成员，保证团队中有多个人有权限发布项目。当然这样的方式并不安全，因为有高级权限的人越多，操作出问题的可能性就越大。所以我在这里非常推荐的方案是将发布权限集中在团队中较核心的一两个成员中，其他成员可以通过提交代码，待核心发布人员`code review`代码之后，发布代码。\n\n### 指定发布地址\n\n如果您经常在公司或者个人的npm库中发布项目，为了防止发布地址错误，您可以在`package.json`中添加以下配置\n\n``` json\n{\n  \&quot;publishConfig\&quot;: {\n    \&quot;registry\&quot;: \&quot;https://registry.npmjs.org\&quot;\n  }\n}\n```\n\n这样就不需要为平凡切换地址而烦恼了。\n\n### 指定发布的内容\n\n如果您的开发过程中，有一些测试内容或者个人的文件不想发布到npm库中去，有这几个方法可以帮到您\n\n方法一：在`package.json`中指定发布的文件或者目录。\n\n``` json\n{\n  \&quot;files\&quot;: [\n    \&quot;src\&quot;,\n    \&quot;README.md\&quot;,\n    \&quot;src/**/*.js\&quot;\n  ]\n}\n```\n\n方法二：在根目录下创建`.npmignore`文件，它类似于`.gitignore`文件。其实没有`.npmignore`文件，npm会使用`.gitignore`文件来取代它的功能。需要注意的是，`.npmignore`不会覆盖`files`字段。\n\n#### 无法通过配置排除的文件\n\n- package.json\n- README.md\n- CHANGES/CHANGELOG/HISTORY\n- LICENSE/LICENCE\n- NOTICE\n- main字段中的文件\n\n#### 无法通过配置包含的文件\n\n- .git\n- CVS\n- .svn\n- .DS_Store\n- ._*\n- ...\n\n## 结论\n\n1. 使用`npm login`可以登录npm账号。\n2. 可以通过`npm version prerealease [--preid=&lt;prerelease-id&gt;]`来发布预发布版本。这个在使用者众多的包发布时非常重要，合理的使用可以展现出您在操作上的规范和发布时的谨慎。尤其是`--preid`的使用，可以告诉用户您对当前版本的定义，一般的值为`next`、`beta`。\n3. `npm publish`可以设置标签。即使粗心设置错标签，您也可以通过`npm dist-tag add &lt;pkg&gt;@&lt;version&gt; [&lt;tag&gt;]`修改标签。\n4. 规范的发布流程可以保证您发布的包的健壮性和可维护性，也是使用者信任的保障。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/发布属于你的NPM包.mdx&quot;],&quot;digest&quot;:[0,&quot;b6ac10b6021e9bad&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;发布属于你的npm包&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;语义化版本控制.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;语义化版本控制&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-10-22T02:35:06.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;我想大家都对版本号这个名词并不陌生。在软件开发高速发展的今天，我们可以看到每个软件都会有版本号。版本号标志着当前软件的更新状态，传达的是当前应用是否是最新状态。版本号本身并不复杂，如何让版本号之间存在关联，如何让用户根据版本号获悉当前应用的更新状态是我们今天要讲的主题。\n\n## 什么是语义化版本\n\n有发布和维护过npm包的同学都清楚，我们在每一次发布前都需要更新一下版本号。版本号一般都有一个标准的格式（X.Y.Z），那么我们在每次发布前应该更新哪一位数字呢？这其中就有一个语义化版本的概念。\n\n语义化版本有一个基本的版本格式：`主版本号.次版本号.修订号`。版本号的递增规则如下：\n\n1. **主版本号\\(major\\)**：当你做了不向下兼容的API时，修改`主版本号`。\n2. **次版本号\\(minor\\)**：当你做了向下兼容的API或者新增了API时，修改`次版本号`。\n3. **修订号\\(patch\\)**：当你做了向下兼容的问题修订时，修改`修订号`。\n\n这是最基本的版本号设置，一般用于正式版本的发布。而在现实生活中，我们为了满足项目在不同阶段的发布，我们会在此基础上做一定的延伸。\n\n我们经常看到一些重大框架正式发布前，都会先出些`alpha`和`beta`版本，这些都是**预发布版本\\(prerelease\\)**。由于版本升级影响较大，所以会做预发布来达到公测的目的。*对于这种版本，个人开发者可以在尝鲜项目中使用，商业项目开发过程中应严禁使用。由于其尚未稳定，很多未知的bug可能会影响到你的业务开发，甚至使你的项目在开发过程中进退两难*。\n\n## 为什么要遵守语义化版本\n\n在软件管理的领域里存在着被称为**依赖地狱**的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中\n\n在讨论为什么要遵守语义化版本前，我们先来说说什么时候我们需要发布新版本。\n\n1. 现有版本存在一个bug需要修复。\n2. 在现有版本的基础上需要添加新功能。\n3. 现有版本某些功能需要做调整。\n4. 现有版本需要做大改动，甚至涉及到对外API的修改，返回结果的变化，以及功能的大幅调整。\n\n通过上面列出来的几种情况，我们可以看到，有些发布只是在现有版本中做一些修补，有些发布会在现有版本基础上开放更多功能，还有些发布会导致新版本与老版本几乎完全不兼容。\n\n这些情况下，如果我们只是通过一个简单的**数字**或者**hash值**作为版本号将会出现一个问题，要不升级到最新版本（*需要针对新版本对当前项目中的代码做一定的调整，项目越大，需要调整的地方可能就越多越复杂*），要不完全不升级（*即使知道当前版本存在某些严重的bug*）。这个问题让我们在项目维护中陷入了两难的境地，为此我们束手无策。\n\n上面的问题确实非常棘手，但是如果我们遵从语义化版本控制，这样的问题就可以迎刃而解了。**语义化版本控制的作用是拆分问题，将问题进行归类，划分级别**。基本的归类方式分为三类问题。根据版本号从右往左看\n\n1. **补丁号**，进行现有功能的兼容性补丁，修复一些现有功能的bug。\n2. **次版本号**，进行向下兼容的修改或者添加新功能。\n3. **主版本号**，进行非向下兼容的更新。与现有版本的功能不兼容，或者返回结果发生了改变。\n\n使用语义化版本控制，我们可以更好地针对某一个版本进行小版本的修改和升级，而不会影响当前项目的运行。具体的**语义化版本规范**可以[查看这里](https://semver.org/lang/zh-CN/#%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%A7%84%E8%8C%83semver)\n\n## 结论\n\n语义化版本控制可以使开发者更好地开发和维护软件，同时使用者同样可以在语义化版本控制中收益。在未知开发者具体开发的内容的情况下，使用者可以根据版本号判定是否可以安全升级当前版本。\n\n目前语义化版本控制已经广泛应用于前后端的包开发流程中。学习语义化版本控制既是一种知识思维的拓展，也是包开发中必不可少的一环。\n\n## 引用\n\n- [语义化版本官方文档](https://semver.org/)\n- [让你的版本号变得规则而有意义](https://www.bilibili.com/read/cv1643035/)&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/语义化版本控制.mdx&quot;],&quot;digest&quot;:[0,&quot;59d30b3b834c0d7e&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;语义化版本控制&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Vue源码解析之代理模式.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;Vue源码解析之代理模式&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-10-11T08:06:31.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;不知不觉，Vue从诞生到现在已经走过了四个年头了。在这期间，前端发生了天翻地覆的变化，前端工作越来越复杂，前端应用维护也越来越困难，传统的开发模式已经无法满足现阶段的开发与维护了，这时候各种工具的出现使我们从刀耕火种的*jQuery时代*进化到了以三大框架为基础的*工业化时代*。三大框架抽离了我们对DOM层的直接操作，使前端开发更加专注于对业务的梳理、数据的处理以及组件的复用。\n\n几天前，Vue作者尤雨溪宣布`Vue 3.0 pre-alpha`版本发布，有兴趣的同学可以[点击这里](https://github.com/vuejs/vue-next)查看。由于 3.0 还太新，本人还没有去了解其源码，在这里就不再多说。今天我们还是继续探讨 2.0 的源码，聊聊 2.0 源码中的一些思想和理念。\n\n我们在使用Vue的时候有没有发现，我们在`data`、`props`、`computed`、`methods`中写的属性或者方法，能直接使用**Vue的实例**或者**Vue组件的实例**访问。同学们在使用过程中有没有为此感到好奇呢？那Vue是如何实现的呢？今天我们就来好好讲讲藏在Vue中的设计模式 —— 代理模式。\n\n## 代理模式\n\n**代理模式的定义就是把对目标对象的访问，交给另一个代理对象来操作。**\n\n细心观察，其实在我们日常开发中就有很多代理模式的实现案例。比如我们与后端交互一定会使用到`Ajax`技术，但是原生的`Ajax`写法非常麻烦，我们往往都会使用第三方库来完成`Ajax`请求。在这个过程中，我们并不会直接使用`XMLHttpRequest`的实例进行各种操作，而是通过**代理人**（第三方`Ajax`库抛出的对象）来帮助我们调用`Ajax`请求，完成与后端的交互。这种不直接操作目标对象，而是通过代理对象帮助完成特定操作的方式就是一种典型的代理模式。\n\n## Vue中的代理模式\n\n前面我们已经举了一个代理模式的栗子，那Vue是如何实现对`data`、`props`、`computed`、`methods`中的属性的代理的呢？\n\n这里要讲的是在ES5之后出现的一个重要方法 —— `Object.defineProperty`。了解Vue的同学应该都知道，`Object.defineProperty`在Vue中起着至关重要的作用，Vue的响应式数据设计就是依赖这个方法完成的。然而Vue并不仅仅只是利用它来实现响应式数据，为了方便操作定义在各个对象上的属性，Vue利用这个方法实现了代理模式，使开发者在开发的过程中更加优雅和舒适。\n\n在Vue中有一个特定的方法`proxy`，这个方法就是Vue代理模式的具体实现。\n\n```javascript\n/**\n * @param {object} target 这里往往是Vue的实例或者Vue组件的实例\n * @param {object} sourceKey 这里往往是被代理对象，也就是我们实际要操作的对象\n * @param {string} key 被代理的属性名称，也是我们在Vue的实例或者Vue组件的实例上操作的属性名称\n */\nfunction proxy(target, sourceKey, key) {\n  // 修改属性的get操作\n  sharedPropertyDefinition.get = function proxyGetter() {\n    return this[sourceKey][key]\n  }\n\n  // 修改属性的set操作\n  sharedPropertyDefinition.set = function proxySetter(val) {\n    this[sourceKey][key] = val\n  }\n\n  // 实现代理的重要方法\n  Object.defineProperty(target, key, sharedPropertyDefinition)\n}\n\nproxy(vm, vm._data, key)\n```\n\nVue利用修改对象属性的`get`和`set`方法，实现了对`data`、`props`、`computed`、`methods`对象属性的代理。这样的实现方式，既可以保留我们习惯的编码方式，又可以使代码看上去更加的优雅。在我们的日常开发中，我们也可以学习使用这种方式来完成一些特定的操作。\n\n## 结论\n\n代理模式是一种思想，这种思想其实在我们开发中经常用到，有些时候可能只是我们没有意识到这本身就是一种设计模式。Vue很好的利用了代理模式和`Object.defineProperty`来实现优雅而舒适的编码方式。在日常开发中，我们应该好好利用代理模式来封装我们的代码。同时，合理的利用`Object.defineProperty`可以使我们的代码更加优雅，甚至可以提升我们的应用程序的性能（具体原因可以去查看[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)的描述符设置）。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/Vue源码解析之代理模式.mdx&quot;],&quot;digest&quot;:[0,&quot;75e1f8b217e565d4&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;vue源码解析之代理模式&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;Vue源码解析之依赖收集和派发更新.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;Vue源码解析之依赖收集和派发更新&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-09-23T18:43:54.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;相信大家都知道，如今的前端开发主要是使用最流行的三大框架 Angular、React、Vue。尤其 React 无论在国内还是国外都深受前端开发者的喜爱，市场占有率可以说是相当的高。另外两大框架也是不甘落后，因其各自的特点，牢牢把握住了一部分忠实的粉丝。今天我们要说的是三大框架之中的 Vue 框架。\n\nVue 由于其渐进式的开发方式、完善的脚手架工具以及简单易懂的开发文档，深受一部分国人的喜爱。使用过 Vue 的都知道，在我们修改`data`中某个数据的时候，相关依赖的`watch`、`computed`、`renderer`都会随之更新，那 Vue 是如何做到的呢？今天我们就来讲讲 Vue 在这块的实现方式——响应式数据更新。\n\n关于这个黑科技般的动作，我们在 Vue 的实现方式中有两个专有的名词（**依赖收集**和**派发更新**）。\n\nVue 利用了 JavaScript 的原生方法`Object.defineProperty`实现响应式数据。这个方法可以重写对象属性的`get`和`set`动作，使我们能保证原来的行为不变的同时，添加额外的行为。Vue 就是利用对象属性的`get`来实现**收集依赖**，以及利用对象属性的`set`来实现**派发更新**的。\n\n本文主要讲解的是 Vue 响应式数据的设计思想，对于具体代码及具体的实现方案不会有特别详细的讲解。关于这些细则，你可以浏览网上一些讲源码的文章或者可以自行查阅源码。\n\n## 响应式数据的三个重要类\n\n在说**依赖收集**和**派发更新**之前，我们先说说跟这两个动作强相关的三个类。Vue 内部定义了`Observer`类、`Dep`类、`Watcher`类。\n\n- `Observer`是用来管理响应式对象的。所有的响应式对象都有一个特点，你可以在它的属性中找到`__ob__`属性。\n- `Dep`主要就是做依赖收集和派发更新的。响应式对象的每一个属性都会被对应的创建一个 Dep 实例，用于收集 Watcher 和触发 Watcher 的更新。\n- `Watcher`的作用则是创建一个监听器。当 Watcher 关联的数据发生改变时，Watcher 会进行相应的更新。\n\n## 依赖收集\n\n![响应式数据之getter](../../assets/images/reactive_getter.png)\n\n```javascript\nconst dep = new Dep()\n...\n\nObject.defineProperty(data, key, {\n  get() {\n    dep.depend()\n    ...\n  },\n  ...\n})\n```\n\n从图上我们可知，当视图或者 computed 等 Watcher 读取依赖的响应式属性时，属性对应的 Dep 实例会执行`depend`方法，收集当前的 Watcher，以便属性发生改变时能通知到相应的 Watcher 更新，这个过程就叫做**依赖收集**。\n\n举个栗子，比如上图中的`data`有一个属性`message`，当视图需要展示`message`的值时，`message`的`get`动作就会被触发。这时候执行`dep.depend()`就会将当前的`renderer watcher`添加到 message 对应的 Dep 实例的依赖项中。\n\n## 派发更新\n\n![响应式数据之setter](../../assets/images/reactive_setter.png)\n\n```javascript\nconst dep = new Dep()\n...\n\nObject.defineProperty(data, key, {\n  set() {\n    ...\n    dep.notify()\n  },\n  ...\n})\n```\n\n**派发更新**的动作也很简单，当响应式对象中的某个属性发生变化时，对应这个属性的 Dep 实例就会执行`notify`方法，之前收集的 Watcher 会被通知进入异步队列中执行。这个过程叫做**派发更新**。\n\n举个栗子，比如上图中的`data`有一个属性`message`，当`message`的值发生变化时，`message`的`set`动作就会被触发。这时候，依赖`message`的`renderer watcher`就会执行`update`操作，重新渲染 DOM 元素；`computed watcher`就会将`dirty`置为`true`，并在下一次读取时更新计算属性的值。\n\n## 总结\n\n这就是 Vue 响应式数据的设计思想。具体实现上 Vue 做了很多处理，既保证了功能的完整性，又兼顾了性能。\n\n在整个响应式设计上，最关键的就是三个类（`Observer`类、`Dep`类、`Watcher`类），两个方法（`observe`方法和`defineReactive`方法）。\n\n其中，`observe`方法主要做的就是实例化一个`Observer`，与响应式对象挂钩；`defineReactive`方法主要做的是实例化一个`Dep`类，与响应式对象的属性挂钩；而`Watcher`类主要用于视图、`computed`和`watch`。这样，整个响应式对象的基础框架算是搭建好了。然后利用`defineReactive`方法，实现了依赖收集和派发。而`observe`方法主要用于响应式对象的注册。整体的设计就是这样一种思路，如果想了解 Vue 的实现，可以参考这篇文章读 Vue 的源码，相信会对你有所帮助。&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/Vue源码解析之依赖收集和派发更新.mdx&quot;],&quot;digest&quot;:[0,&quot;413e855027880fb6&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;vue源码解析之依赖收集和派发更新&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;探索JavaScript运行机制.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;探索JavaScript运行机制&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-08-17T17:26:28.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;在阅读本文前，需要你的JavaScript语言基础比较扎实，并在日常工作中经常会使用到这门语言。\n\n进入正题，我们在执行JavaScript脚本时，经常会用到setTimeout、Promise等各种前端异步技术，那么你有没有考虑过JavaScript到底是怎样运行的呢？同样是异步技术，它们之间又有什么区别呢？在执行过程中，我们怎么确定哪个异步先执行，哪个异步后执行呢？今天，就让我们一起带着这些疑问来探究下前端开发中的异步技术和JavaScript的运行机制。\n\n我们知道，JavaScript的执行是单线程的，所以JavaScript并不能同时处理多个任务，那么这些任务就需要排队按插入顺序执行。那么什么是任务呢？主体代码相当于一个任务，各种异步代码也相当于一个任务。JavaScript实现异步的方式有很多种，但是归根结底可以将它们划分为两大类 —— 宏任务和微任务。有了宏任务和微任务，那就需要一个调度器，适时的执行宏任务和微任务，以及配合UI渲染，这个调度器我们称之为EventLoop。\n\n## 宏任务\n\n宏任务是存放在宏任务队列中的任务。在一轮任务周期中，宏任务队列只推出一个任务执行。\n\n- setTimeout\n- setInterval\n- setImmediate\n- I/O\n- UI Rendering\n\n注意：这里没有将**主体代码**作为宏任务，是因为在这个概念上，网上存在较多的争议。每个人的理解不一样，但这个概念对`我们理解JS是如何运行的`不会产生太大的影响，这里就不做定论了。\n\n## 微任务\n\n微任务是存放在微任务队列中的任务。在一轮任务周期中，微任务队列会依次推出任务执行，直到微任务队列中没有任务为止（即一轮任务周期完成）。\n\n- 原生Promise（部分第三方实现的Promise会被放入宏任务队列中）\n- process.nextTick()\n- Object.observe（已废弃）\n- MutationObserver\n- MessageChannel\n\n## 宏任务与微任务的区别\n\n浏览器在执行脚本的过程中，会把不同的任务放入不同的队列当中去。当执行的时候，浏览器首先会从宏任务队列中推出一个任务并执行。当执行完当前的宏任务之后，浏览器会从微任务队列中逐个运行所有的任务。我把这个称为一个任务周期，循环往复，浏览器会执行很多个这样的任务周期。\n\n通俗点讲，就像你去银行办理业务，因为处理业务的人比较多，你就需要取号排队，这个就是**宏任务队列**。终于轮到你了，你跟柜台说你需要办理存款业务，柜台帮你办理了；你又说，你要办理理财业务，柜台又帮你办理了，就这样，你可以一次性办理完所有你想要办理的业务而不需要重新排队，这就是**微任务队列**。\n\n从上面的例子，我们可以看到宏任务每次都只能执行一个任务，微任务会把当前队列中的所有任务都执行完成后再处理下一个宏任务。\n\n## 举个栗子\n\n说了这么多，我们不如直接来看栗子，加深我们的印象。\n\n```javascript\nconsole.log(1)\n\nsetTimeout(() =&gt; {\n    Promise.resolve(7).then(r =&gt; console.log(r))\n\n    console.log(2)\n})\n\nPromise.resolve(3).then(r =&gt; console.log(r))\n\nPromise.resolve(4).then(r =&gt; console.log(r))\n\nsetTimeout(() =&gt; {\n    console.log(5)\n\n    Promise.resolve(8).then(r =&gt; console.log(r))\n})\n\nconsole.log(6)\n```\n\n上面是一个观察浏览器宏任务和微任务的列子，你们觉得执行结果会是什么呢？\n\n![执行结果](../../assets/images/WX20190818-175457@2x.png)\n\n跟你想的一样吗？下面我来讲解下这段代码的执行过程吧！\n\n1. script标签引入的脚本是主体任务，先执行；\n2. 第一行代码是同步代码，所以直接执行并打印结果 `1`；\n3. 第三行代码遇到了setTimeout，setTimeout是宏任务，所以推入宏任务队列中，等待执行；\n4. 第九行代码遇到了Promise，Promise是微任务，所以推入微任务队列中，等待执行；\n5. 第十一行代码又遇到了Promise，推入微任务队列中，等待执行；\n6. 第十三行代码又遇到了setTimeout，推入宏任务队列中，等待执行；\n7. 第十九行代码是同步代码，直接执行并打印结果`6`。\n\n第一个任务执行结束了，现在宏任务队列中有2个任务，微任务队列中也有2个任务。下面浏览器会执行刚刚推入微任务队列中的所有任务。\n\n1. 第一个微任务是第九行代码创建的，执行并打印结果`3`。\n2. 第二个微任务是第十一行代码创建的，执行并打印结果`4`。\n\n就这样一个任务周期就结束了。我前面说过，现在宏任务中还有2个任务，所以我们继续下一个任务周期。\n\n**执行宏任务**\n\n1. 执行第一个setTimeout中的回调函数。\n2. 遇到Promise，推入微任务队列，等待执行。\n3. 遇到同步代码，直接执行并打印结果`2`。\n\n执行微任务\n\n1. 执行Promise的then方法，直接执行并打印结果`7`。\n\n**执行宏任务**\n\n1. 执行第2个setTimeout中的回调函数。\n2. 遇到同步代码，直接执行并打印结果`5`。\n3. 遇到Promise，推入微任务队列，等待执行。\n\n**执行微任务**\n\n1. 执行Promise的then方法，直接执行并打印结果`8`\n\n好了，执行结束，这就是所有异步任务的执行顺序。讲解之后是不是很清晰！&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/探索JavaScript运行机制.mdx&quot;],&quot;digest&quot;:[0,&quot;fd1998dfac1a1fbe&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;探索javascript运行机制&quot;],&quot;render&quot;:[0,null]}],[0,{&quot;id&quot;:[0,&quot;ECMAScript之箭头函数.mdx&quot;],&quot;data&quot;:[0,{&quot;title&quot;:[0,&quot;ECMAScript之箭头函数&quot;],&quot;description&quot;:[0,&quot;&quot;],&quot;pubDate&quot;:[3,&quot;2019-04-09T11:19:09.000Z&quot;],&quot;heroImage&quot;:[0,&quot;&quot;]}],&quot;body&quot;:[0,&quot;随着前端最近几年的快速发展，前端语言也带来翻天覆地的变化，沉寂多年的 JavaScript 也迎来大变革，许多新特性加入到了 JavaScript 语言当中。今天我们就来聊聊 ES6 带来的一个新特性 —— 箭头函数。\n\n## 什么是箭头函数\n\n箭头函数是 ES6 引入的新特性。相对于普通函数，箭头函数的写法非常简单，同时箭头函数还有很多与普通函数不同的特点。在下面的篇幅中，我会详细介绍这些特点。\n\n## 箭头函数的特点\n\n前面我们讲了箭头函数是 ES6 引入的新特性，那么它到底与普通函数有什么区别呢？在使用箭头函数时，我们需要注意些什么呢？\n\n《ES 6标准入门》(第二版)中有这样四个注意点：\n\n1. **函数体内的`this`对象就是定义时所在的对象，而不是使用时所在的对象。**\n2. **不可以当做构造函数。也就是说，不可以使用`new`命令，否则会抛出一个错误。**\n3. **不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以使用rest参数代替。**\n4. **不可以使用`yield`命令，因此箭头函数不能用作`Generator`函数。**\n\n这本书简单概括了箭头函数的特点，但是我觉得还不够详细。下面我就来将每一个特点展开讲解，并配合代码示例，希望能帮助大家更好地理解箭头函数。\n\n## 更简单的语法\n\n相对于普通的函数，箭头函数的语法更加的简单。下面我们来举几个例子。\n\n```javascript\n// 普通函数声明\nvar func1 = function() {}\n// 箭头函数声明\nvar func1 = () =&gt; {}\n\n// 普通函数带一个参数\nvar func2 = function(arg0) {}\n// 箭头函数带一个参数\nvar func2 = arg0 =&gt; {}\n\n// 普通函数带多个参数\nvar func3 = function(arg0, arg1) {}\n// 箭头函数带多个参数\nvar func3 = (arg0, arg1) =&gt; {}\n\n// 普通函数返回值\nvar func4 = function() { return &#39;返回值&#39; }\n// 箭头函数返回值\nvar func4 = () =&gt; &#39;返回值&#39;\n\n// 普通函数多条语句\nvar func5 = function() {\n  var a = &#39;一条语句&#39;\n  return a\n}\n// 箭头函数多条语句\nvar func5 = () =&gt; {\n  var a = &#39;一条语句&#39;\n  return a\n}\n```\n\n怎么样，是不是感觉箭头函数更加的简单明了。我们不仅写起来方便快捷，还增加了代码的可读性。简洁的语法使它受到了许多开发者的喜爱。目前在我经历的项目中，能用箭头函数的，绝不会使用普通函数。尤其是在回调函数的时候，我会优先考虑使用箭头函数代替普通函数，当然这不仅仅因为它的简洁性，还有一个非常重要的特性让我选择使用它，那就是箭头函数的`this`指向。\n\n## this 指向问题\n\n箭头函数的`this`指向规则和普通函数有很大的区别。这里我用代码来解释下箭头函数的`this`指向问题，请看下面的代码。\n\n```javascript\nvar obj ={\n  a: function() {\n    console.log(this)\n  },\n  b: () =&gt; {\n    console.log(this)\n  }\n}\n\n// { a: ..., b: ... } 返回obj对象\nobj.a()\n// Window{...} 返回window对象\nobj.b()\n\nvar a = obj.a\n// Window{...} 返回window对象\na()\n\nvar b = obj.b\n// Window{...} 返回window对象\nb()\n```\n\n![执行结果](../../assets/images/WX20190411-015056.png)\n\n我们可以看到，我同样在`obj`对象中定义了属性方法，并且使用同样的方式执行它们，但是结果却不一样。这是为什么呢？\n\n刚接触不久的前端同学应该深有感触，在 JavaScript 语言中，`this`是个淘气的孩子，总喜欢调皮捣蛋，有时候你看着外套都一样，可以一叫才发现已经换了一个人儿。所以使用`this`时，我们总是非常谨慎，深怕一不注意就出错了。但是在箭头函数中不会出现这样的问题。原因是普通函数是在使用时才能确定`this`的指向（即`this`是调用这个函数的对象，如果在全局调用，那调用的对象就是`window`或者`undefined`，这与是否是严格模式有关），而箭头函数的`this`是在定义时就已经确定了。\n\n### 箭头函数本身没有`prototype`（原型）对象，所以箭头函数本身是没有`this`的。\n\n```javascript\nvar a = () =&gt; {}\nconsole.log(a.prototype) // undefined\n```\n\n![执行结果](../../assets/images/WX20190411-015358.png)\n\n### 箭头函数的`this`指向在定义时就继承了外层第一个普通函数的`this`。\n\n请看下面这段代码，它能更好地让我们理解这条规则。\n\n```javascript\nvar a, b;\nvar bar = { xxx: &#39;this 指向 bar&#39; }\nvar foo = { xxx: &#39;this 指向 foo&#39; }\n\nfunction barFn() {\n  // 我们在 barFn 函数中定义了箭头函数 a\n  a = () =&gt; console.log(this)\n  // 我们在 barFn 函数中定义了普通函数 b\n  b = function() { console.log(this) }\n}\n\nfunction fooFn() {\n  // 我们在 fooFn 函数中调用函数 a\n  a()\n  // 我们在 fooFn 函数中调用函数 b\n  b()\n}\n\n// 我们修改 barFn 的 `this` 指向\nbarFn.call(bar)\n// 我们修改 fooFn 的 `this` 指向\nfooFn.call(foo)\n```\n\n![执行结果](../../assets/images/WX20190411-014914.png)\n\n这个例子我们可以得出两个结论：\n\n1. 箭头函数的`this`指向定义时所在的第一个外层函数，跟使用的位置无关。\n2. 当被继承的外层函数的`this`发生改变时，箭头函数的`this`也会跟着改变。\n\n### 我们不能直接修改箭头函数的this指向\n\n下面我们对上面的fooFn函数做一些修改\n\n```javascript\nfunction fooFn() {\n  a.call(this)\n  b.call(this)\n}\n```\n\n![执行结果](../../assets/images/WX20190411-015235.png)\n\n这里我们可以看到即使我们手动修改了`this`的指向，也不会影响到箭头函数的`this`指向。\n\n使用`bind`、`apply`、`call`无法改变箭头函数的`this`指向，但是仍然可以将实参传入箭头函数。当然箭头函数的`this`并非完全不可修改，我们可以修改被继承的外层函数的`this`来间接地修改箭头函数的`this`指向。这个在上一个例子中有所体现。\n\n### 箭头函数外层没有普通函数包裹时，无论是否在严格模式下，this 都会指向 window 对象。\n\n之前我们说了 “箭头函数的`this`指向第一个外层函数的`this`” 这句话确实没错。但是仔细想想，如果箭头函数外层没有函数时它又指向哪里呢？\n\n我们知道普通函数在非严格模式下`this`是指向`window`的，而在严格模式下`this`是`undefined`。但是箭头函数的规则不同，无论是否在严格模式下，`this`都会指向`window`。\n\n以上就是箭头函数中，`this`的特点。正是这些特点，我们在回调函数和多层嵌套的函数中经常会使用它，尤其是函数内正好需要使用外层函数的`this`时。这使我们不需要专门定义一个变量来保存`this`，增强了代码的可读性。\n\n## 不能将箭头函数作为构造函数使用\n\n```javascript\nvar A = () =&gt; {}\nnew A()\n```\n\n![执行结果](../../assets/images/WX20190731-110410.png)\n\n上图我们可以看到，我们使用箭头函数`new`了一个实例，结果却报了语法错误。\n\n```javascript\nfunction A() {\n  this.arrow = () =&gt; {\n    super()\n  }\n}\n\nvar a = new A()\n\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-024631@2x.png)\n\n上面的执行结果，当箭头函数中执行`super`时报错了，因为箭头函数不是构造函数，函数体中没有`super`函数。\n\n```javascript\nfunction A() {\n  this.arrow = () =&gt; {\n    console.log(new.target)\n  }\n}\n\nvar a = new A()\n\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-024807@2x.png)\n\n```javascript\nfunction A() {\n  \n}\n\nA.prototype.b = function() {\n  this.arrow = () =&gt; {\n    console.log(new.target)\n  }\n}\n\nvar a = new A()\n\na.b()\na.arrow()\n```\n\n![执行结果](../../assets/images/WX20190411-025710@2x.png)\n\n从上面两个例子中，我们可以看出，`new.target`的值是不一样的，这也证明了箭头函数不能作为构造函数。\n\n## 箭头函数没有 arguments 对象\n\n```javascript\nvar a = () =&gt; { console.log(arguments) }\na(1, 2)\n```\n\n![执行结果](../../assets/images/WX20190411-020421.png)\n\n这里可以看到，当在箭头函数中调用`arguments`会出现报错的情况。但是你以为这样就完了吗？通过图片我们可以看到错误信息是指引用错误`ReferenceError`。那么，如果我们在`this`对象上定义一个`arguments`参数会怎么样呢？我们试试吧。\n\n```javascript\nwindow.arguments = [&#39;a&#39;, &#39;b&#39;]\nvar a = () =&gt; { console.log(arguments) }\na(1, 2)\n```\n\n![执行结果](../../assets/images/WX20190411-021151.png)\n\n没错，正如我们所想。`arguments`返回的是我们全局定义的属性的值。\n\n到这里我们可以看到，箭头函数的函数体中并不存在`arguments`对象。我们知道`arguments`方便了我们获取函数的参数，在箭头函数中，是否可以有一种方式能获取函数的所有参数呢？答案当然是肯定的，而且比`arguments`的功能更加的强大。这就不得不讲到的另一个 ES 6 引入的特性——`rest参数`。而且`rest参数`返回的是一个真正的数组（`arguments`返回的是一个类数组，不能调用数组的一些方法，需要手动做一次转义）。对于`rest参数`，我这里就不细讲了，感兴趣的同学可以自己去查阅资料，内容也不复杂，非常容易理解，使用也非常方便。\n\n```javascript\nvar a = (...rest) =&gt; console.log(rest)\na(1, 3, 5)\n```\n\n![执行结果](../../assets/images/WX20190411-023144.png)\n\n## 箭头函数不能使用 yield 命令\n\n```javascript\nvar a = num =&gt; {\n  var b = yield num + 1\n  return b\n}\n```\n\n![执行结果](../../assets/images/WX20190411-105952.png)\n\n```javascript\nvar a = *(num) =&gt; {\n  var b = yield num + 1;\n  return b;\n}\n```\n\n![执行结果](../../assets/images/WX20190411-110824.png)\n\n首先，箭头函数没有`function`关键字，所以实际是不能写成 Generator 函数，这样`yield`自然也是没有用了。\n\n## 总结\n\n1. 什么是箭头函数\n2. 箭头函数的特点\n3. 更简单的语法\n4. this 指向问题\n   1. 箭头函数本身没有`prototype`（原型）对象，所以箭头函数本身是没有`this`的。\n   2. 箭头函数的`this`指向在定义时就继承了外层第一个普通函数的`this`。\n   3. 我们不能直接修改箭头函数的this指向\n   4. 箭头函数外层没有普通函数包裹时，无论是否在严格模式下，this 都会指向 window 对象。\n5. 不能将箭头函数作为构造函数使用\n6. 箭头函数没有 arguments 对象\n7. 箭头函数不能使用 yield 命令\n8. 总结&quot;],&quot;filePath&quot;:[0,&quot;src/content/blog/ECMAScript之箭头函数.mdx&quot;],&quot;digest&quot;:[0,&quot;5cf322795b9d4f56&quot;],&quot;deferredRender&quot;:[0,true],&quot;collection&quot;:[0,&quot;blog&quot;],&quot;slug&quot;:[0,&quot;ecmascript之箭头函数&quot;],&quot;render&quot;:[0,null]}]]],&quot;prefix&quot;:[0,&quot;blog&quot;]}" ssr client="only" opts="{&quot;name&quot;:&quot;PostList&quot;,&quot;value&quot;:&quot;vue&quot;}"></astro-island> </article> <footer class="p-6 text-center"> <a class="no-underline text-inherit" href="javascript: void(0);">&copy; 2025 lihzsky.</a> All rights reserved.
</footer> </body></html>